<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/github.com/yuweijun/yuweijun.github.io/vim-zh/change.cnx.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="molokai">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #d0d0d0; background-color: #121212; }
body { font-family: monospace; color: #d0d0d0; background-color: #121212; }
* { font-size: 1em; }
.String { color: #afaf87; }
.Type { color: #5fd7ff; }
.Statement { color: #d7005f; font-weight: bold; }
.PreProc { color: #87ff00; }
.Identifier { color: #ff8700; }
.Comment { color: #5f5f5f; }
.Special { color: #5fd7ff; }
.Ignore { color: #808080; background-color: #080808; padding-bottom: 1px; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span class="String">change.txt</span><span class="Ignore">*</span>    For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年7月


		  VIM 参考手册    by Bram Moolenaar
				译者: Willis
				<span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>


本文档描述删除和修改文本的命令。在本文中，修改文本意味着用单个命令删除部分文本
并将其替换成其他文本。所有本文描述的命令都可以被撤销。其中非命令行 (Ex) 的命令
可以用 &quot;.&quot; 命令重复。

1. 删除文本			<span class="Ignore">|</span><span class="Identifier">deleting</span><span class="Ignore">|</span>
2. 删除并插入			<span class="Ignore">|</span><span class="Identifier">delete-insert</span><span class="Ignore">|</span>
3. 简单修改			<span class="Ignore">|</span><span class="Identifier">simple-change</span><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">changing</span><span class="Ignore">*</span>
4. 复杂修改			<span class="Ignore">|</span><span class="Identifier">complex-change</span><span class="Ignore">|</span>
   4.1 过滤命令			   <span class="Ignore">|</span><span class="Identifier">filter</span><span class="Ignore">|</span>
   4.2 替代			   <span class="Ignore">|</span><span class="Identifier">:substitute</span><span class="Ignore">|</span>
   4.3 搜索与替代		   <span class="Ignore">|</span><span class="Identifier">search-replace</span><span class="Ignore">|</span>
   4.4 调整制表			   <span class="Ignore">|</span><span class="Identifier">change-tabs</span><span class="Ignore">|</span>
5. 复制并移动文本		<span class="Ignore">|</span><span class="Identifier">copy-move</span><span class="Ignore">|</span>
6. 文本排版			<span class="Ignore">|</span><span class="Identifier">formatting</span><span class="Ignore">|</span>
7. 文本排序			<span class="Ignore">|</span><span class="Identifier">sorting</span><span class="Ignore">|</span>

关于插入文本部分，参阅 <span class="Ignore">|</span><span class="Identifier">insert.txt</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
1. 删除文本						<span class="Ignore">*</span><span class="String">deleting</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E470</span><span class="Ignore">*</span>

[&quot;x]<span class="Special">&lt;Del&gt;</span>	或					<span class="Ignore">*</span><span class="String">&lt;Del&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">x</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">dl</span><span class="Ignore">*</span>
[&quot;x]x			删除 <span class="Special">[count]</span> 个光标之下和之后的字符 [到寄存器 x 里]
			(非 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作)。和 &quot;dl&quot; 相同。
			<span class="Special">&lt;Del&gt;</span> 键不使用 <span class="Special">[count]</span> 计数。相反，如果有计数，它删
			除该计数的最后一位。
			如果 <span class="Special">&lt;Del&gt;</span> 键的操作与你预期的不符，参见 <span class="Ignore">|</span><span class="Identifier">:fixdel</span><span class="Ignore">|</span>。关
			于如何删除换行符 (连接行)，参见 <span class="Ignore">|</span><span class="Identifier">'whichwrap'</span><span class="Ignore">|</span>。
			<span class="Special">{Vi 不支持 &lt;Del&gt;}</span>

							<span class="Ignore">*</span><span class="String">X</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">dh</span><span class="Ignore">*</span>
[&quot;x]X			删除 <span class="Special">[count]</span> 个光标之前的字符 [到寄存器 x 里] (非
			<span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作)。和 &quot;dh&quot; 相同。另见 <span class="Ignore">|</span><span class="Identifier">'whichwrap'</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">d</span><span class="Ignore">*</span>
[&quot;x]d<span class="Special">{motion}</span>		删除 <span class="Special">{motion}</span> 动作跨越的文本 [到寄存器 x 里]。例外见
			下。

							<span class="Ignore">*</span><span class="String">dd</span><span class="Ignore">*</span>
[&quot;x]dd			删除 <span class="Special">[count]</span> 行 [到寄存器 x 里]，<span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作。

							<span class="Ignore">*</span><span class="String">D</span><span class="Ignore">*</span>
[&quot;x]D			删除光标所在的字符到行尾及其后的 <span class="Special">[count]</span>-1 行 [到寄
			存器 x 里] (非 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作)。和 &quot;d$&quot; 同义。
			如果 <span class="Type">'cpoptions'</span> 里有 '#' 标志位，忽略计数。

<span class="Special">{Visual}</span>[&quot;x]x	或					<span class="Ignore">*</span><span class="String">v_x</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_d</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_&lt;Del&gt;</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]d   或
<span class="Special">{Visual}</span>[&quot;x]<span class="Special">&lt;Del&gt;</span>	删除高亮文本 [到寄存器 x 里] (关于 <span class="Special">{Visual}</span> 见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

<span class="Special">{Visual}</span>[&quot;x]<span class="Special">CTRL-H</span>   或					<span class="Ignore">*</span><span class="String">v_CTRL-H</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_&lt;BS&gt;</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]<span class="Special">&lt;BS&gt;</span>	在选择模式时，删除高亮文本 [到寄存器 x 里]。

<span class="Special">{Visual}</span>[&quot;x]X	或					<span class="Ignore">*</span><span class="String">v_X</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_D</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_b_D</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]D		删除高亮行 [到寄存器 x 里] (关于 <span class="Special">{Visual}</span> 见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。在可视列块模式里，&quot;D&quot; 删除高亮的文本直
			到行尾。<span class="Special">{Vi 无此功能}</span>

					<span class="Ignore">*</span><span class="String">:d</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:de</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:del</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:delete</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:dl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:dp</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>d[elete] [x]	删除 <span class="Special">[range]</span> 范围的行 (缺省: 当前行) [到寄存器 x 里]。
			注意 这些奇异的缩写:
			   :dl		删除并列出 (list)
			   :dell	同上
			   :delel	同上
			   :deletl	同上
			   :deletel	同上
			   :dp		删除并显示 (print)
			   :dep		同上
			   :delp	同上
			   :delep	同上
			   :deletp	同上
			   :deletep	同上

:<span class="Special">[range]</span>d[elete] [x] <span class="Special">{count}</span>
			从 <span class="Special">[range]</span> 指定的范围开始，删除 <span class="Special">{count}</span> 行 (缺省: 当前
			行 <span class="Ignore">|</span><span class="Identifier">cmdline-ranges</span><span class="Ignore">|</span>) [到寄存器 x 里]。

这些命令删除文本。你可以用 <span class="Ignore">`</span><span class="Comment">.</span><span class="Ignore">`</span> 命令重复它们 (除了 <span class="Ignore">`</span><span class="Comment">:d</span><span class="Ignore">`</span>)，也可以撤销它们。用可
视模式可以删除文本列块。关于寄存器的解释，参见 <span class="Ignore">|</span><span class="Identifier">registers</span><span class="Ignore">|</span>。

d<span class="Special">{motion}</span> 命令的一个特例: 如果动作不面向行，动作的开始和结束处不在同一行，开始
位置之前只有空白，并且结束位置之后没有非空白的话，该删除会转为行动作。这意味着
删除命令可能删除你还想保留的空白行。<span class="Ignore">|</span><span class="Identifier">o_v</span><span class="Ignore">|</span> 操作符强制该动作面向字符。

如果 <span class="Type">'cpoptions'</span> 包括 'E' 标志位，删除文本里的空区域 (例如，在首列上 &quot;d0&quot;) 会
报错。

							<span class="Ignore">*</span><span class="String">J</span><span class="Ignore">*</span>
J			连接 <span class="Special">[count]</span> 行，但至少包含两行。删除缩进，插入不多于
			两个的空格 (见下)。在缓冲区末行此操作会失败。<span class="Special">[count]</span>
			如果过多，会自行缩减至余下可用的行。

							<span class="Ignore">*</span><span class="String">v_J</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>J		连接高亮行，但至少包含两行。删除缩进，插入不多于两个的
			空格 (见下)。<span class="Special">{Vi 无此功能}</span>。

							<span class="Ignore">*</span><span class="String">gJ</span><span class="Ignore">*</span>
gJ			连接 <span class="Special">[count]</span> 行，但至少包含两行。不插入或删除任何空
			格。<span class="Special">{Vi 无此功能}</span>。

							<span class="Ignore">*</span><span class="String">v_gJ</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>gJ		连接高亮行，但至少包含两行。不插入或删除任何空格。
			<span class="Special">{Vi 无此功能}</span>。

							<span class="Ignore">*</span><span class="String">:j</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:join</span><span class="Ignore">*</span>
<span class="Special">[range]</span>j[oin][!] <span class="Special">[flags]</span>
			连接 <span class="Special">[range]</span> 范围的行。和 &quot;J&quot; 相同，但如有 [!] 时，连
			接不插入或删除任何空格。如果 <span class="Special">[range]</span> 包括相同的开始和
			结束行，该命令不做任何事。缺省行为是连接当前行与下一
			行。<span class="Special">{Vi: 没有 !}</span>
			<span class="Special">[flags]</span> 部分可参见 <span class="Ignore">|</span><span class="Identifier">ex-flags</span><span class="Ignore">|</span>。

:<span class="Special">[range]</span>j[oin][!] <span class="Special">{count}</span> <span class="Special">[flags]</span>
			连接 <span class="Special">[range]</span> 开始的 <span class="Special">{count}</span> 行 (缺省: 当前行
			<span class="Ignore">|</span><span class="Identifier">cmdline-ranges</span><span class="Ignore">|</span>)。和 &quot;J&quot; 相同，但如有 [!] 时，连接不
			插入或删除任何空格。<span class="Special">{Vi: 没有 !}</span>
			<span class="Special">[flags]</span> 部分可参见 <span class="Ignore">|</span><span class="Identifier">ex-flags</span><span class="Ignore">|</span>。

这些命令删除行间的 <span class="Special">&lt;EOL&gt;</span>，即换行符，从而实际上使多行连接成一行。除了 <span class="Ignore">`</span><span class="Comment">:j</span><span class="Ignore">`</span> 之
外，你可以重复这些命令或者撤销之。

这些命令，除了 &quot;gJ&quot; 以外，插入一个空格以代替 <span class="Special">&lt;EOL&gt;</span>，除非当前行的结尾已经有空白
或者下一行以 ')' 开始。这些命令，除了 &quot;gJ&quot; 之外，也删除下一行所有开头的空白。
如果 <span class="Type">'joinspaces'</span> 选项打开，这些命令在 '.'、'!' 或者 '?' 之后插入两个空格 (但
如果 <span class="Type">'cpoptions'</span> 包括 'j' 标志位，只有在 '.' 之后插入两个空格)。
<span class="Type">'formatoptions'</span> 里的 'B' 和 'M' 标志位改变在多字节字符之前或者之后插入空格的行
为 <span class="Ignore">|</span><span class="Identifier">fo-table</span><span class="Ignore">|</span>。

'[ 标记指向被连接的首行之原行尾处，'] 则指向合并后的行尾。


<span class="PreProc">==============================================================================</span>
2. 删除并插入					<span class="Ignore">*</span><span class="String">delete-insert</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">replacing</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">R</span><span class="Ignore">*</span>
R			进入替换模式: 每个输入的字符替代一个现有的字符，从光标
			所在的位置开始。重复输入的文本 <span class="Special">[count]</span> - 1 次。参见
			<span class="Ignore">|</span><span class="Identifier">Replace-mode</span><span class="Ignore">|</span> 以了解相关详情。

							<span class="Ignore">*</span><span class="String">gR</span><span class="Ignore">*</span>
gR			进入虚拟替换模式: 每个输入的字符替代屏幕位置一个现有的
			字符。因而，一个 <span class="Special">&lt;Tab&gt;</span> 可以一次替换若干个字符。重复输
			入的文本 <span class="Special">[count]</span>-1 次。参见 <span class="Ignore">|</span><span class="Identifier">Virtual-Replace-mode</span><span class="Ignore">|</span> 以
			了解相关详情。{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+vreplace</span><span class="Ignore">|</span> 特性有效}

							<span class="Ignore">*</span><span class="String">c</span><span class="Ignore">*</span>
[&quot;x]c<span class="Special">{motion}</span>		将 <span class="Special">{motion}</span> 跨过的文本删除 [到寄存器 x 里] 并开始插
			入。如果 <span class="Type">'cpoptions'</span> 包括 'E' 标志位并且没有任何文本实
			际需要删除时 (例如，&quot;cTx&quot; 而光标刚在 'x' 之后的时候)，
			报错并拒绝开始插入模式 (这与 Vi 兼容)。如果
			<span class="Type">'cpoptions'</span> 没有 'E'，&quot;c&quot; 命令总是启动插入模式，即使没
			有文本要删除也是如此。

							<span class="Ignore">*</span><span class="String">cc</span><span class="Ignore">*</span>
[&quot;x]cc			删除 <span class="Special">[count]</span> 行 [到寄存器 x 里] 并开始插入。
			<span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作。如果置位 <span class="Type">'autoindent'</span>，保留首行的缩
			进。

							<span class="Ignore">*</span><span class="String">C</span><span class="Ignore">*</span>
[&quot;x]C			从当前光标位置删除到行尾，再删除 <span class="Special">[count]</span>-1 行 [到寄存
			器 x 里]，并开始插入。和 c$ 等价 (非 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动
			作)。

							<span class="Ignore">*</span><span class="String">s</span><span class="Ignore">*</span>
[&quot;x]s			删除 <span class="Special">[count]</span> 个字符 [到寄存器 x 里]，并开始插入。(s 代
			表替代 (Substitute))。和 &quot;cl&quot; 等价 (非 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动
			作)。

							<span class="Ignore">*</span><span class="String">S</span><span class="Ignore">*</span>
[&quot;x]S			删除 <span class="Special">[count]</span> 行 [到寄存器 x 里] 并开始插入。和 &quot;cc&quot; 等
			价 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作。

<span class="Special">{Visual}</span>[&quot;x]c	or					<span class="Ignore">*</span><span class="String">v_c</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_s</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]s		删除高亮文本 [到寄存器 x 里]，并开始插入 (关于
			<span class="Special">{Visual}</span> 参见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>。

							<span class="Ignore">*</span><span class="String">v_r</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]r<span class="Special">{char}</span>	把所有高亮的字符替换成 <span class="Special">{char}</span>。

							<span class="Ignore">*</span><span class="String">v_C</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]C		删除高亮行 [到寄存器 x 里] 并开始插入。在可视列块模式
			下有所不同 <span class="Ignore">|</span><span class="Identifier">v_b_C</span><span class="Ignore">|</span>。<span class="Special">{Vi 无此功能}</span>。
							<span class="Ignore">*</span><span class="String">v_S</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]S		删除高亮行 [到寄存器 x 里] 并开始插入 (关于 <span class="Special">{Visual}</span>
			参见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>。
							<span class="Ignore">*</span><span class="String">v_R</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]R		现在和 <span class="Special">{Visual}</span>[&quot;x]S 相同。以后的版本可能会有所改变
			<span class="Special">{Vi 无此功能}</span>。

注意:
- 你可以用 <span class="Special">&lt;Esc&gt;</span> 退出插入和替换模式。
- 参见 &quot;插入和替换模式&quot; 一节 <span class="Ignore">|</span><span class="Identifier">mode-ins-repl</span><span class="Ignore">|</span> 以了解其他这些模式下的特殊字符。
- <span class="Special">[count]</span> 的效果只有在 Vim 退出插入或替换模式时才会体现。
- 当 <span class="Type">'cpoptions'</span> 选项包含 '$' 并且所做的修改在一行之内，Vim 继续显示被删除的文
  本，并在最后一个被删除的字符之后加上一个 '$'。

关于寄存器的解释，参见 <span class="Ignore">|</span><span class="Identifier">registers</span><span class="Ignore">|</span>。

替换模式和插入模式类似，除了每输入一个字符同时删除一个字符以外。如果到达行尾，
Vim 把其后的字符插入在行尾 (和插入模式相同)。在替换模式下，退格键恢复原来的文
本 (如果有的话)。(参见 &quot;插入和替换模式&quot; 一节 <span class="Ignore">|</span><span class="Identifier">mode-ins-repl</span><span class="Ignore">|</span>)。

						<span class="Ignore">*</span><span class="String">cw</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">cW</span><span class="Ignore">*</span>
特殊情况: 如果光标在单词内部，&quot;cw&quot; 和 &quot;cW&quot; 不包含单词后的空白而只修改到词尾。
这是因为 Vim 把 &quot;cw&quot; 解释为 修改-单词，而单词并不包括其后的空白。<span class="Special">{Vi: 在其后还</span>
<span class="Special">有空白的空白字符上 &quot;cw&quot; 只修改第一个空白；这也许是一个漏洞，因为 &quot;dw&quot; 删除所有</span>
<span class="Special">空白；用 'cpoptions' 里的 'w' 标志位来设置类似于 Vi 的工作方式}</span>

如果你希望 &quot;cw&quot; 包括单词之后的空格，使用如下的映射:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map cw dwi</span>
或者，用 &quot;caw&quot; (见 <span class="Ignore">|</span><span class="Identifier">aw</span><span class="Ignore">|</span>)。

							<span class="Ignore">*</span><span class="String">:c</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:ch</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:change</span><span class="Ignore">*</span>
:<span class="Special">{range}</span>c[hange][!]	用另外的文本替换若干文本行。输入只包含 &quot;.&quot; 的行结束替
			换。如果没有 <span class="Special">{range}</span>，该命令只置换当前行。
			加上 [!] 后，在本命令的执行期间切换 <span class="Type">'autoindent'</span>。

<span class="PreProc">==============================================================================</span>
3. 简单修改						<span class="Ignore">*</span><span class="String">simple-change</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">r</span><span class="Ignore">*</span>
r<span class="Special">{char}</span>			把光标下的字符换成 <span class="Special">{char}</span>。如果 <span class="Special">{char}</span> 是 <span class="Special">&lt;CR&gt;</span> 或者
			<span class="Special">&lt;NL&gt;</span>，则把该字符变成换行符。要换成一个真正的 <span class="Special">&lt;CR&gt;</span>，使
			用 <span class="Special">CTRL-V</span> <span class="Special">&lt;CR&gt;</span>。<span class="Special">CTRL-V</span> <span class="Special">&lt;NL&gt;</span> 则换成 <span class="Special">&lt;Nul&gt;</span>。

			<span class="Special">{Vi: CTRL-V &lt;CR&gt; 还是换成换行符。没有办法换成 &lt;CR&gt;}</span>。

			若 <span class="Special">{char}</span> 为 <span class="Special">CTRL-E</span> 或 <span class="Special">CTRL-Y</span>，使用下一行或上一行的
			字符来代替，就象 <span class="Ignore">|</span><span class="Identifier">i_CTRL-E</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">i_CTRL-Y</span><span class="Ignore">|</span> 一样。这里
			计数也适用，所以 <span class="Ignore">`</span><span class="Comment">10r&lt;C-E&gt;</span><span class="Ignore">`</span> 从下一行复制 10 个字符。

			如果你给出 <span class="Special">[count]</span>，Vim 替换 <span class="Special">[count]</span> 个字符为 <span class="Special">[count]</span>
			个 <span class="Special">{char}</span>。不过如果 <span class="Special">{char}</span> 为 <span class="Special">&lt;CR&gt;</span> 或者 <span class="Special">&lt;NL&gt;</span>，Vim 只插
			入一个换行符: &quot;5r<span class="Special">&lt;CR&gt;</span>&quot; 替换五个字符为一个换行符。

			当 <span class="Special">{char}</span> 为 <span class="Special">&lt;CR&gt;</span> 或者 <span class="Special">&lt;NL&gt;</span>，Vim 会自动缩进。这和先执
			行删除要替换的字符在执行 &quot;i<span class="Special">&lt;CR&gt;&lt;Esc&gt;</span>&quot; 类似。

			<span class="Special">{char}</span> 可以输入二合字母 <span class="Ignore">|</span><span class="Identifier">digraph-arg</span><span class="Ignore">|</span>。

			<span class="Ignore">|</span><span class="Identifier">:lmap</span><span class="Ignore">|</span> 映射会应用在 <span class="Special">{char}</span> 上。插入模式下的 <span class="Special">CTRL-^</span> 命
			令可以切换这一功能 <span class="Ignore">|</span><span class="Identifier">i_CTRL-^</span><span class="Ignore">|</span>。

			参见 <span class="Ignore">|</span><span class="Identifier">utf-8-char-arg</span><span class="Ignore">|</span> 以了解在 <span class="Type">'encoding'</span> 为 Unicode
			编码时如果使用合成用字符。

							<span class="Ignore">*</span><span class="String">gr</span><span class="Ignore">*</span>
gr<span class="Special">{char}</span>		替换光标下的虚拟字符。替换发生在屏幕位置而不是文件位置
			上。参见 <span class="Ignore">|</span><span class="Identifier">gR</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">Virtual-Replace-mode</span><span class="Ignore">|</span> 以了解相关详
			情。和 <span class="Ignore">|</span><span class="Identifier">r</span><span class="Ignore">|</span> 一样，可以使用计数。<span class="Special">{char}</span> 输入的方式也相同
			{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+vreplace</span><span class="Ignore">|</span> 特性有效}。

						<span class="Ignore">*</span><span class="String">digraph-arg</span><span class="Ignore">*</span>
普通模式下的命令，像 <span class="Ignore">|</span><span class="Identifier">r</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">t</span><span class="Ignore">|</span>，需要一个单字符的参数。如果 <span class="Type">'cpo'</span> 不包含 'D'
标志位，该字符可以用 <span class="Ignore">|</span><span class="Identifier">digraphs</span><span class="Ignore">|</span> 那样的方式输入: 先键入 <span class="Special">CTRL-K</span> 然后输入二合字母
的两个字符 {仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+digraphs</span><span class="Ignore">|</span> 特性有效}。

						<span class="Ignore">*</span><span class="String">case</span><span class="Ignore">*</span>
下面的命令根据当前的 <span class="Ignore">|</span><span class="Identifier">locale</span><span class="Ignore">|</span> 改变字母的大小写。参见 <span class="Ignore">|</span><span class="Identifier">:language</span><span class="Ignore">|</span>。这里会用到
LC_CTYPE 的值。

							<span class="Ignore">*</span><span class="String">~</span><span class="Ignore">*</span>
~			<span class="Type">'notildeop'</span> 选项: 切换光标下字符的大小写，并把光标向右
			移。如果给出 <span class="Special">[count]</span>，应用在那么多数目的字符上。
			<span class="Special">{Vi: 没有 count}</span>

~<span class="Special">{motion}</span>		<span class="Type">'tildeop'</span> 选项: 切换 <span class="Special">{motion}</span> 跨越的文本的大小写。<span class="Special">{Vi:</span>
			<span class="Special">~ 不能用作操作符}</span>

							<span class="Ignore">*</span><span class="String">g~</span><span class="Ignore">*</span>
g~<span class="Special">{motion}</span>		切换 <span class="Special">{motion}</span> 跨越的文本的大小写。<span class="Special">{Vi 无此功能}</span>

g~g~							<span class="Ignore">*</span><span class="String">g~g~</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">g~~</span><span class="Ignore">*</span>
g~~			切换当前行的大小写。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_~</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>~		切换高亮文本的大小写 (关于 <span class="Special">{Visual}</span> 见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_U</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>U		使高亮文本成为大写 (关于 <span class="Special">{Visual}</span> 见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gU</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">uppercase</span><span class="Ignore">*</span>
gU<span class="Special">{motion}</span>		使 <span class="Special">{motion}</span> 跨越的文本成为大写。<span class="Special">{Vi 无此功能}</span>
			例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:map! &lt;C-F&gt; &lt;Esc&gt;gUiw`]a</span>
<span class="Ignore">&lt;</span>			可以用在插入模式下: 按 <span class="Special">CTRL-F</span> 使光标之前的单词成为大
			写。这使得输入大写单词很方便，只要输入小写单词再一次转
			换就行了。


gUgU							<span class="Ignore">*</span><span class="String">gUgU</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">gUU</span><span class="Ignore">*</span>
gUU			使得当前行成为大写。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_u</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>u		使高亮文本成为小写 (关于 <span class="Special">{Visual}</span> 见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gu</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">lowercase</span><span class="Ignore">*</span>
gu<span class="Special">{motion}</span>		使 <span class="Special">{motion}</span> 跨越的文本成为小写。<span class="Special">{Vi 无此功能}</span>

gugu							<span class="Ignore">*</span><span class="String">gugu</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">guu</span><span class="Ignore">*</span>
guu			使得当前行成为小写。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">g?</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">rot13</span><span class="Ignore">*</span>
g?<span class="Special">{motion}</span>		用 Rot13 对 <span class="Special">{motion}</span> 跨越的文本进行编码。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_g?</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>g?		用 Rot13 对高亮文本进行编码 (关于 <span class="Special">{Visual}</span> 见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

g?g?							<span class="Ignore">*</span><span class="String">g?g?</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">g??</span><span class="Ignore">*</span>
g??			用 Rot13 对当前行进行编码。<span class="Special">{Vi 无此功能}</span>

要以标题大写 (title cap) 方式改写一行，亦即使每个单词的首字母大写:<span class="Ignore"> &gt;</span>
<span class="Comment">	:s/\v&lt;(.)(\w*)/\u\1\L\2/g</span>


<span class="PreProc">递 增 与 递 减</span><span class="Ignore"> ~</span>
							<span class="Ignore">*</span><span class="String">CTRL-A</span><span class="Ignore">*</span>
<span class="Special">CTRL-A</span>			把当前光标之上或之后的数值或者字母加上 <span class="Special">[count]</span>。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_CTRL-A</span><span class="Ignore">*</span>
<span class="Special">{Visual}CTRL-A</span>		给高亮文本内的数值或者字母加上 <span class="Special">[count]</span>。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_g_CTRL-A</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>g <span class="Special">CTRL-A</span>	给高亮文本内的数值或者字母加上 <span class="Special">[count]</span>。如果高亮超过一
			行，每行会加上额外的 <span class="Special">[count]</span> (即生成 <span class="Special">[count]</span> 为增量的
			递增数列)。<span class="Special">{Vi 无此功能}</span>
			例如，假定有如下数字的列表:
				<span class="PreProc">1.</span><span class="Ignore"> ~</span>
				<span class="PreProc">1.</span><span class="Ignore"> ~</span>
				<span class="PreProc">1.</span><span class="Ignore"> ~</span>
				<span class="PreProc">1.</span><span class="Ignore"> ~</span>
			移动至第二个 &quot;1.&quot;，可视地选择后三行，按 g <span class="Special">CTRL-A</span> 会生
			生成:
				<span class="PreProc">1.</span><span class="Ignore"> ~</span>
				<span class="PreProc">2.</span><span class="Ignore"> ~</span>
				<span class="PreProc">3.</span><span class="Ignore"> ~</span>
				<span class="PreProc">4.</span><span class="Ignore"> ~</span>

							<span class="Ignore">*</span><span class="String">CTRL-X</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span>			把当前光标之上或之后的数值或者字母减去 <span class="Special">[count]</span>。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_CTRL-X</span><span class="Ignore">*</span>
<span class="Special">{Visual}CTRL-X</span>		给高亮文本内的数值或者字母减去 <span class="Special">[count]</span>。
			<span class="Special">{Vi 无此功能}</span>

			MS-Windows 上，此键被映射到剪切可视文本
			<span class="Ignore">|</span><span class="Identifier">dos-standard-mappings</span><span class="Ignore">|</span>。要屏蔽该映射，可用:<span class="Ignore"> &gt;</span>
<span class="Comment">				silent! vunmap &lt;C-X&gt;</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">v_g_CTRL-X</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>g <span class="Special">CTRL-X</span>	给高亮文本内的数值或者字母减去 <span class="Special">[count]</span>。如果高亮超过一
			行，每行会减去额外的 <span class="Special">[count]</span> (即生成 <span class="Special">[count]</span> 为增量的
			递减数列)。

<span class="Special">CTRL-A</span> 和 <span class="Special">CTRL-X</span> 命令可用于:
- 带符号或无符号十进制数
- 无符号二进制、八进制和十六进制数
- 字母

这取决于 <span class="Type">'nrformats'</span> 选项:
- 当 <span class="Type">'nrformats'</span> 包括 &quot;bin&quot; 时，Vim 假设 '0b' 或 '0B' 开始的数值为二进制。
- 当 <span class="Type">'nrformats'</span> 包括 &quot;octal&quot; 时，Vim 假设 '0' 开始的数值为八进制，除非该数值
  里包含 '8' 或 '9'。其他的数值为十进制，并可以在开始带一个可选的负号。
  如果光标已经在数值上，命令应用于该数值；否则，应用于光标右侧的数值。
- 当 <span class="Type">'nrformats'</span> 包括 &quot;alpha&quot; 时，Vim 会改变光标之上或之后的字母。这可用于构造
  字母编号的列表。
- 当 <span class="Type">'nrformats'</span> 包括 &quot;hex&quot; 时，Vim 假设 '0x' 或者 '0X' 开始的数值为十六进制。
  这个数值最右端的字母决定所产生十六进制数值的大小写。如果当前数值没有字母，
  Vim 使用上一次检测到的大小写。

增减操作会考虑十进制开始的负号。二进制、八进制和十六进制值则不会。要忽略正负
号，可视地选择数值本身。然后再应用 <span class="Special">CTRL-A</span> 或 <span class="Special">CTRL-X</span>。

对零开头的数值 (包括八进制和十六进制的)，Vim 尽可能保留相同数量的字符。<span class="Special">CTRL-A</span>
在 &quot;0077&quot; 上产生 &quot;0100&quot;，<span class="Special">CTRL-X</span> 在 &quot;0x100&quot; 上产生 &quot;0x0ff&quot;。
有一个例外: 在发现某数值以零开始但不是八进制 (包含 '8' 或 '9')，而 <span class="Type">'noformats'</span>
却包含 &quot;octal&quot; 的时候，引导的零会被删除，以免结果被误认为八进制。

注意 如果 <span class="Type">'nrformats'</span> 包括 &quot;octal&quot;，开头有零的十进制数会产生错误，因为会和八进
制数产生混淆。

同样类似的要 注意，如果 <span class="Type">'nrformats'</span> 包括 &quot;bin&quot;，开头有 '0x' 或 '0X' 的二进制数
被认作十六进制，因为 '0b' 是合法的十六进制数字。

<span class="Special">CTRL-A</span> 命令在宏命令里很有用。例如: 使用以下的步骤构造一个数字编号的列表。

1. 建立第一个列表项。确保它以数字开始。
2. qa	     - 用寄存器 'a' 开始记录
3. Y	     - 抽出这个列表项
4. p	     - 把该项的一个副本放置在下一行上
5. <span class="Special">CTRL-A</span>    - 增加计数
6. q	     - 停止记录
7. <span class="Special">&lt;count&gt;</span>@a - 重复抽出、放置和增加计数操作 <span class="Special">&lt;count&gt;</span> 次


将 文 本 左 移 或 右 移					<span class="Ignore">*</span><span class="String">shift-left-right</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">&lt;</span><span class="Ignore">*</span>
&lt;<span class="Special">{motion}</span>		将 <span class="Special">{motion}</span> 跨越的行左移 <span class="Type">'shiftwidth'</span> 列。

							<span class="Ignore">*</span><span class="String">&lt;&lt;</span><span class="Ignore">*</span>
&lt;&lt;			将 <span class="Special">[count]</span> 行左移 <span class="Type">'shiftwidth'</span> 列。

							<span class="Ignore">*</span><span class="String">v_&lt;</span><span class="Ignore">*</span>
<span class="Special">{Visual}[count]</span>&lt;	将高亮行左移 <span class="Special">[count]</span> 个 <span class="Type">'shiftwidth'</span> 列 (关于 <span class="Special">{Visual}</span>
			见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">&gt;</span><span class="Ignore">*</span>
 &gt;<span class="Special">{motion}</span>		将 <span class="Special">{motion}</span> 跨越的行右移 <span class="Type">'shiftwidth'</span> 列。

							<span class="Ignore">*</span><span class="String">&gt;&gt;</span><span class="Ignore">*</span>
 &gt;&gt;			将 <span class="Special">[count]</span> 行右移 <span class="Type">'shiftwidth'</span> 列。

							<span class="Ignore">*</span><span class="String">v_&gt;</span><span class="Ignore">*</span>
<span class="Special">{Visual}[count]</span>&gt;	将高亮行右移 <span class="Special">[count]</span> 个 <span class="Type">'shiftwidth'</span> 列 (关于 <span class="Special">{Visual}</span>
			见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:&lt;</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>&lt;		将 <span class="Special">[range]</span> 指定的行左移 <span class="Type">'shiftwidth'</span> 列。多个 '&lt;' 左移
			多个 <span class="Type">'shiftwidth'</span> 列。

:<span class="Special">[range]</span>&lt; <span class="Special">{count}</span>	左移 <span class="Special">[range]</span> 开始的 <span class="Special">{count}</span> 行 <span class="Type">'shiftwidth'</span> 列 (缺省从
			当前行 <span class="Ignore">|</span><span class="Identifier">cmdline-ranges</span><span class="Ignore">|</span>)。多个 '&lt;' 左移多个
			<span class="Type">'shiftwidth'</span> 列。

:<span class="Special">[range]</span>le[ft] <span class="Special">[indent]</span>	左对齐 <span class="Special">[range]</span> 指定的行。设置缩进距离为 <span class="Special">[indent]</span> (缺省
			为 0)。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:&gt;</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>&gt; <span class="Special">[flags]</span>	将 <span class="Special">[range]</span> 指定的行右移 <span class="Type">'shiftwidth'</span> 列。多个 '&gt;' 右移
			多个 <span class="Type">'shiftwidth'</span> 列。
			<span class="Special">[flags]</span> 部分可参见 <span class="Ignore">|</span><span class="Identifier">ex-flags</span><span class="Ignore">|</span>。

:<span class="Special">[range]</span>&gt; <span class="Special">{count}</span> <span class="Special">[flags]</span>
			右移 <span class="Special">[range]</span> 开始的 <span class="Special">{count}</span> 行 <span class="Type">'shiftwidth'</span> 列 (缺省从
			当前行 <span class="Ignore">|</span><span class="Identifier">cmdline-ranges</span><span class="Ignore">|</span> 开始)。多个 '&gt;' 右移多个
			<span class="Type">'shiftwidth'</span> 列。
			<span class="Special">[flags]</span> 部分可参见 <span class="Ignore">|</span><span class="Identifier">ex-flags</span><span class="Ignore">|</span>。

&quot;&gt;&quot; 和 &quot;&lt;&quot; 命令可以用来方便地调整程序的缩进。使用 <span class="Type">'shiftwidth'</span> 选项设置这些命
令增加或者减少的空白的数量。通常，<span class="Type">'shiftwidth'</span> 选项是 8，但你也可以设置为，比
如说，3，使得缩进更小些。如果已经没有缩进，左移命令会停止。另一方面，右移命令
则不会影响空白行。

如果 <span class="Type">'shiftround'</span> 选项打开，缩进距离被取整到 <span class="Type">'shiftwidth'</span> 的倍数。

如果 <span class="Type">'smartindent'</span> 选项打开，或者 <span class="Type">'cindent'</span> 打开并且 <span class="Type">'cinkeys'</span> 包含带零值的
'#'，右移不影响 '#' 开始的行 (这些应该是 C 预处理行，它们应该保持在第一列)。

如果 <span class="Type">'expandtab'</span> 选项关闭 (这是缺省值)， Vim 尽可能使用 <span class="Special">&lt;Tab&gt;</span> 来构成缩进。你可
以用 &quot;&gt;&gt;&lt;&lt;&quot; 来把缩进尽可能从空格替换成同样缩进距离的 <span class="Special">&lt;Tab&gt;</span> (如有需要，还有少量
的空格)。如果 <span class="Type">'expandtab'</span> 选项打开，Vim 只使用空格。这样你可以使用 &quot;&gt;&gt;&lt;&lt;&quot; 把
<span class="Special">&lt;Tab&gt;</span> 替换成空格 (或者可以用 <span class="Ignore">`</span><span class="Comment">:retab!</span><span class="Ignore">`</span>)。

要移动一行多个 <span class="Type">'shiftwidth'</span> 列，使用可视模式或者 <span class="Ignore">`</span><span class="Comment">:</span><span class="Ignore">`</span> 命令。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	Vjj4&gt;		右移三行四个缩进位</span>
<span class="Comment">	:&lt;&lt;&lt;		左移当前行三个缩进位</span>
<span class="Comment">	:&gt;&gt; 5		右移五行两个缩进位</span>
<span class="Comment">	:5&gt;&gt;		右移第五行两个缩进位</span>

<span class="PreProc">==============================================================================</span>
4. 复杂修改						<span class="Ignore">*</span><span class="String">complex-change</span><span class="Ignore">*</span>

4.1 过滤命令						<span class="Ignore">*</span><span class="String">filter</span><span class="Ignore">*</span>

过滤程序是一个接受文本作为标准输入，作某些修改，并把结果放到标准输出的程序。你
可以用下面的命令把若干文本发送给过滤程序，然后用过滤的输出结果替换。一个过滤程
序的例子是 &quot;sort&quot;，按字母顺序给行排序；还有 &quot;indent&quot;，排版 C 程序文件 (你需要
一个能以过滤程序方式工作的版本，并非所有的版本都可以)。<span class="Type">'shell'</span> 选项指定 Vim 使
用的外壳程序，用以执行过滤程序 (另见 <span class="Type">'shelltype'</span> 选项)。你可以用 &quot;.&quot; 重复过滤
命令。Vim 不会识别 <span class="Ignore">`</span><span class="Comment">:!</span><span class="Ignore">`</span> 命令之后的注释 (用 '&quot;' 开始)。

							<span class="Ignore">*</span><span class="String">!</span><span class="Ignore">*</span>
!<span class="Special">{motion}{filter}</span>	将 <span class="Special">{motion}</span> 跨越的行用外部程序 <span class="Special">{filter}</span> 过滤。

							<span class="Ignore">*</span><span class="String">!!</span><span class="Ignore">*</span>
!!<span class="Special">{filter}</span>		将 <span class="Special">[count]</span> 行用外部程序 <span class="Special">{filter}</span> 过滤。

							<span class="Ignore">*</span><span class="String">v_!</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>!<span class="Special">{filter}</span>	将高亮行用外部程序 <span class="Special">{filter}</span> 过滤。(关于 <span class="Special">{Visual}</span>
			见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

:<span class="Special">{range}</span>![!]<span class="Special">{filter}</span> [!]<span class="Special">[arg]</span>				<span class="Ignore">*</span><span class="String">:range!</span><span class="Ignore">*</span>
			将 <span class="Special">{range}</span> 指定的行用外部程序 <span class="Special">{filter}</span> 过滤。Vim 把可
			选的感叹号替换成最后一次使用的命令，并附加上可选的参数
			<span class="Special">[arg]</span>。Vim 把过滤命令的输出保存到临时文件，并把文
			件内容读到一个缓冲区里 <span class="Ignore">|</span><span class="Identifier">tempfile</span><span class="Ignore">|</span>。Vim 使用
			<span class="Type">'shellredir'</span> 选项把过滤程序的结果重定向到临时文件。
			不过，如果关闭了 <span class="Type">'shelltemp'</span> 选项且可以的话，使用管道
			机制 (Unix 上)。
			如果 <span class="Type">'cpoptions'</span> 包含 'R' 标志位，过滤行里的位置标记被
			删除，除非使用了 <span class="Ignore">|</span><span class="Identifier">:keepmarks</span><span class="Ignore">|</span> 命令。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:keepmarks '&lt;,'&gt;!sort</span>
<span class="Ignore">&lt;</span>			如果过滤后的行数变少，删去的行里的位置标记无论如何不会
			保存。

							<span class="Ignore">*</span><span class="String">=</span><span class="Ignore">*</span>
=<span class="Special">{motion}</span>		把 <span class="Special">{motion}</span> 跨越的行用 <span class="Type">'equalprg'</span> 选项指定的外部程序过
			滤。如果 <span class="Type">'equalprg'</span> 选项为空 (缺省)，使用内部的排版机
			制 <span class="Ignore">|</span><span class="Identifier">C-indenting</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">'lisp'</span><span class="Ignore">|</span>，除非 <span class="Type">'indentexpr'</span> 非空，
			此时使用 <span class="Ignore">|</span><span class="Identifier">indent-expression</span><span class="Ignore">|</span> 机制来代替。反之，如果
			Vim 编译时没有包含内部排版机制，最后手段是使用外部的
			&quot;indent&quot; 程序。

							<span class="Ignore">*</span><span class="String">==</span><span class="Ignore">*</span>
==			和 =<span class="Special">{motion}</span> 类似，过滤 <span class="Special">[count]</span> 行。

							<span class="Ignore">*</span><span class="String">v_=</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>=		和 =<span class="Special">{motion}</span> 类似，过滤高亮行。<span class="Special">{Vi 无此功能}</span>


						<span class="Ignore">*</span><span class="String">tempfile</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">setuid</span><span class="Ignore">*</span>
Vim 使用临时文件来处理过滤、执行比较和用于 tempname()。Unix 上，该文件会放在一
个私人的目录里 (只能被当前用户访问)，以防堵安全上的漏洞 (例如，符号链接攻击或
文件被其他用户读取等)。Vim 退出时，自动删除该目录及之下的所有文件。如果 Vim 本
身设置了 setuid 位，这样或许会有问题。临时文件由 setuid 用户拥有，但过滤程序以
原来用户的权限执行。
MS-DOS 和 OS/2 上，使用以下目录中首个可用者: $TMP、$TEMP、c:\TMP、c:\TEMP。
Unix 上，使用的目录依次为: $TMPDIR、/tmp、当前目录、$HOME。
MS-Windows 上，使用 GetTempFileName() 系统函数。
其它系统上使用 tmpnam() 库函数。


4.2 替代						<span class="Ignore">*</span><span class="String">:substitute</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">:s</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:su</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>s[ubstitute]/<span class="Special">{pattern}</span>/<span class="Special">{string}</span>/[flags] <span class="Special">[count]</span>
			对 <span class="Special">[range]</span> 指定的行把 <span class="Special">{pattern}</span> 的匹配替代成
			<span class="Special">{string}</span>。
			关于 <span class="Special">{pattern}</span>，参见 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span>。
			<span class="Special">{string}</span> 可以是按字面意义的，也可以包含特殊字符。
			参见 <span class="Ignore">|</span><span class="Identifier">sub-replace-special</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">E939</span><span class="Ignore">*</span>
			如果不指定 <span class="Special">[range]</span> 和 <span class="Special">[count]</span>，仅在当前行进行替代。
			如果指定 <span class="Special">[count]</span>，在 <span class="Special">[range]</span> 最后一行开始的 <span class="Special">[count]</span>
			行进行替代。如果不指定 <span class="Special">[range]</span> ，则从当前行开始。
			<span class="Special">[count]</span> 必须为正数。
			另见 <span class="Ignore">|</span><span class="Identifier">cmdline-ranges</span><span class="Ignore">|</span>。

			关于 <span class="Special">[flags]</span>，参见 <span class="Ignore">|</span><span class="Identifier">:s_flags</span><span class="Ignore">|</span>。

:<span class="Special">[range]</span>s[ubstitute] <span class="Special">[flags]</span> <span class="Special">[count]</span>
:<span class="Special">[range]</span>&amp;[&amp;][flags] <span class="Special">[count]</span>					<span class="Ignore">*</span><span class="String">:&amp;</span><span class="Ignore">*</span>
			使用最后一次 :substitute 相同的模式和替代字符串，但不
			包括相同的标志位。你可以另加 <span class="Special">[flags]</span> (见 <span class="Ignore">|</span><span class="Identifier">:s_flags</span><span class="Ignore">|</span>)。
			注意 在 <span class="Ignore">`</span><span class="Comment">:substitute</span><span class="Ignore">`</span> 之后，不能使用 '&amp;' 标志位。它被
			认为是一个模式分隔符。
			<span class="Ignore">`</span><span class="Comment">:substitute</span><span class="Ignore">`</span> 和 'c'、'g'、'i'、'I' 和 'r' 标志位之间
			的空格不是必需的，但在脚本里为了避免混淆起见，最好保留
			它。

:<span class="Special">[range]</span>~[&amp;][flags] <span class="Special">[count]</span>					<span class="Ignore">*</span><span class="String">:~</span><span class="Ignore">*</span>
			使用最后一次 :substitute 相同的替代字符串，但使用最近
			使用的搜索模式作为匹配模式。这类似于 <span class="Ignore">`</span><span class="Comment">:&amp;r</span><span class="Ignore">`</span>。
			关于 <span class="Special">[flags]</span>，参见 <span class="Ignore">|</span><span class="Identifier">:s_flags</span><span class="Ignore">|</span>。

								<span class="Ignore">*</span><span class="String">&amp;</span><span class="Ignore">*</span>
&amp;			等价于 <span class="Ignore">`</span><span class="Comment">:s</span><span class="Ignore">`</span> (重复上次的 substitute)。注意 这里不记住标
			志位，所以实际工作方式可能不尽相同。你可以用 <span class="Ignore">`</span><span class="Comment">:&amp;&amp;</span><span class="Ignore">`</span> 来
			保持相同的标志位。

								<span class="Ignore">*</span><span class="String">g&amp;</span><span class="Ignore">*</span>
g&amp;			等价于 <span class="Ignore">`</span><span class="Comment">:%s//~/&amp;</span><span class="Ignore">`</span> (在所有行上重复上次的 substitute 并
			使用相同的标志位，但使用前次的匹配模式)。
			例如，如果先用了替代 <span class="Ignore">`</span><span class="Comment">:s/pattern/repl/flags</span><span class="Ignore">`</span> 然后
			<span class="Ignore">`</span><span class="Comment">/search</span><span class="Ignore">`</span> 搜索了其他模式，<span class="Ignore">`</span><span class="Comment">g&amp;</span><span class="Ignore">`</span>  会执行
			<span class="Ignore">`</span><span class="Comment">:%s/search/repl/flags</span><span class="Ignore">`</span>。
			助记: 全局 (global) 替代 (substitute)。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:snomagic</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sno</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>sno[magic] ...	和 <span class="Ignore">`</span><span class="Comment">:substitute</span><span class="Ignore">`</span> 相同，但总使用 <span class="Type">'nomagic'</span>。
			<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:smagic</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sm</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>sm[agic] ...	和 <span class="Ignore">`</span><span class="Comment">:substitute</span><span class="Ignore">`</span> 相同，但总使用 <span class="Type">'magic'</span>。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:s_flags</span><span class="Ignore">*</span>
你可以在 substitute 命令里使用以下标志位:

							<span class="Ignore">*</span><span class="String">:&amp;&amp;</span><span class="Ignore">*</span>
[&amp;]	必须是首个使用的标志位: 保留和上次 substitute 相同的标志位。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		:&amp;&amp;</span>
<span class="Comment">		:s/this/that/&amp;</span>
<span class="Ignore">&lt;</span>	注意 <span class="Ignore">`</span><span class="Comment">:s</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:&amp;</span><span class="Ignore">`</span> 不保留标志位。
	<span class="Special">{Vi 无此功能}</span>

[c]	确认每个替代。Vim 高亮匹配的字符串 (如果使用了 <span class="Ignore">|</span><span class="Identifier">hl-IncSearch</span><span class="Ignore">|</span>)。你可以
	输入:						<span class="Ignore">*</span><span class="String">:s_c</span><span class="Ignore">*</span>
	    'y'	    来替代这次匹配
	    'l'	    来替代这次匹配并退出 (助记: &quot;last&quot;，最后)
	    'n'	    来跳过这次匹配
	    <span class="Special">&lt;Esc&gt;</span>   来退出替代过程
	    'a'	    来替代这次和以后所有的匹配
	    'q'	    来退出替代过程 <span class="Special">{Vi 无此功能}</span>
	    <span class="Special">CTRL-E</span>  来上卷屏幕 <span class="Special">{Vi 无此功能，仅当编译时加入 </span><span class="Ignore">|</span><span class="Identifier">+insert_expand</span><span class="Ignore">|</span>
			<span class="Special">特性才有此功能}</span>
	    <span class="Special">CTRL-Y</span>  来下卷屏幕 <span class="Special">{Vi 无此功能，仅当编译时加入 </span><span class="Ignore">|</span><span class="Identifier">+insert_expand</span><span class="Ignore">|</span>
			<span class="Special">特性才有此功能}</span>
	如果 <span class="Type">'edcompatible'</span> 选项打开，Vim 记住 [c] 标志位并在每次使用它时切换
	是否确认，但在给出一个新的匹配模式时复位。
	<span class="Special">{Vi 没有高亮匹配部分和除了 'y' 和 'n' 之外的选择}</span>

[e]     如果模式搜索不成功，不给出错误信息。因为没产生错误，映射的过程得以继
	续。这主要用来防止在映射执行过程的无匹配 (&quot;No match&quot;) 错误中断映射。
	不过，Vim 不会抑制以下的错误信息:
		Regular expressions can't be delimited by letters (正规表达式
			不能以字母分隔)
		\ should be followed by /, ? or &amp; (\ 必须后面跟 /、? 或者 &amp;)
		No previous substitute regular expression (没有上次的替代正规
			表达式)
		Trailing characters (结尾有多余的字符)
		Interrupted (中断)
	<span class="Special">{Vi 无此功能}</span>

[g]	对行内所有的匹配进行替代。如果没有这个参数，替代只对每行的第一个匹配进
	行。如果 <span class="Type">'edcompatible'</span> 选项打开，Vim 记住这个标志并在你每次使用该标志
	时切换，但在给出一个新的匹配模式时复位。如果 <span class="Type">'gdefault'</span> 选项打开，这个
	标志缺省打开，而 [g] 参数关闭之。

[i]	忽略模式的大小写。不使用 <span class="Type">'ignorecase'</span> 和 <span class="Type">'smartcase'</span> 选项。
	<span class="Special">{Vi 无此功能}</span>

[I]	不忽略模式的大小写。不使用 <span class="Type">'ignorecase'</span> 和 <span class="Type">'smartcase'</span> 选项。
	<span class="Special">{Vi 无此功能}</span>

[n]	报告匹配的次数，并不实际进行替代。忽略 [c] 标志位。匹配报告的发生就像
	<span class="Type">'report'</span> 总是为零那样。可用于 <span class="Ignore">|</span><span class="Identifier">count-items</span><span class="Ignore">|</span>。
	如果使用 \= <span class="Ignore">|</span><span class="Identifier">sub-replace-expression</span><span class="Ignore">|</span>，该表达式对每一个匹配的执行都在
	<span class="Ignore">|</span><span class="Identifier">sandbox</span><span class="Ignore">|</span> 里进行。

[p]	显示包含最后一次替代的行。

[#]	类似 [p]，且在前面加上行号。

[l]	类似 [p]，但显示的方式类似于 <span class="Ignore">|</span><span class="Identifier">:list</span><span class="Ignore">|</span>。

[r]	仅对于不带参数的 <span class="Ignore">`</span><span class="Comment">:&amp;</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:s</span><span class="Ignore">`</span> 有用。<span class="Ignore">`</span><span class="Comment">:&amp;r</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:~</span><span class="Ignore">`</span> 工作的方式相同: 如果
	匹配模式为空，使用上一次使用的搜索模式，而不是上一次的 substitute 或者
	<span class="Ignore">`</span><span class="Comment">:global</span><span class="Ignore">`</span> 所使用的模式。如果最近一次使用搜索的命令就是 substitute 或者
	<span class="Ignore">`</span><span class="Comment">:global</span><span class="Ignore">`</span>，那就没有区别了。如果最近的命令的是 &quot;/&quot; 那样的搜索命令，使用
	那个命令的搜索模式。
	带参数的 <span class="Ignore">`</span><span class="Comment">:s</span><span class="Ignore">`</span>，则不论如何，总是如此:<span class="Ignore"> &gt;</span>
<span class="Comment">		:s/blue/red/</span>
<span class="Comment">		/green</span>
<span class="Comment">		:s//red/   或  :~   或  :&amp;r</span>
<span class="Ignore">&lt;</span>	最后的命令把 &quot;green&quot; 替代成 &quot;red&quot;。<span class="Ignore"> &gt;</span>
<span class="Comment">		:s/blue/red/</span>
<span class="Comment">		/green</span>
<span class="Comment">		:&amp;</span>
<span class="Ignore">&lt;</span>	最后的命令把 &quot;blue&quot; 替代成 &quot;red&quot;。
	<span class="Special">{Vi 无此功能}</span>

注意这里没有标志位可以改变模式的 &quot;魔术性&quot; (magicness)。你可以用别的命令或
<span class="Ignore">|</span><span class="Identifier">/\v</span><span class="Ignore">|</span> 之类。原因是标志位只能在跳过模式之后才能找到，而要跳过模式，必须先知道模
式的 &quot;魔术性&quot;。第二十二条军规！

如果 substitute 命令所用的 <span class="Special">{pattern}</span> 为空，该命令使用上次的 substitute 或者
<span class="Ignore">`</span><span class="Comment">:global</span><span class="Ignore">`</span> 命令用过的模式。如果不存在，但有上次搜索模式，使用之。如果有 [r] 标
志位，该命令使用上次 substitute、 <span class="Ignore">`</span><span class="Comment">:global</span><span class="Ignore">`</span> 或者搜索命令使用的模式。

如果 <span class="Special">{string}</span> 省略，替代命令假定它为空。这样就把匹配文本删除了。这时，
<span class="Special">{pattern}</span> 之后的分隔符也可省略。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:%s/TESTING</span>
删除所有行上的 &quot;TESTING&quot;，但每行只删一个。

为了和 Vi 的兼容性，有两个例外:
&quot;\/<span class="Special">{string}</span>/&quot; 和 &quot;\?<span class="Special">{string}</span>?&quot; 等同于 &quot;//<span class="Special">{string}</span>/r&quot;。
&quot;\&amp;<span class="Special">{string}</span>&amp;&quot; 等同于 &quot;//<span class="Special">{string}</span>/&quot;。
							<span class="Ignore">*</span><span class="String">E146</span><span class="Ignore">*</span>
除了用 '/' 来包围模式和替代字符串之外，你可以使用任何其他的单字节字符，除了
字母、数字、'\'、'&quot;' 或 '|' 之外。这可以用于 '/' 是搜索模式或替代字符串一部
分的场合。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:s+/+//+</span>

关于模式的定义，参见 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span>。在可视列块模式下，如果模式中使用了 <span class="Ignore">|</span><span class="Identifier">/\%V</span><span class="Ignore">|</span>，那
么替代只在列块内进行，否则它作用于整行。

					<span class="Ignore">*</span><span class="String">sub-replace-special</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:s\=</span><span class="Ignore">*</span>
<span class="Special">{string}</span> 以 &quot;\=&quot; 开始时，它被作为表达式来执行，参见 <span class="Ignore">|</span><span class="Identifier">sub-replace-expression</span><span class="Ignore">|</span>。
你可以用此功能实现复杂替换，也可用来使用特殊字符。

否则，<span class="Special">{string}</span> 字符串里的字符有如下的特殊含义:
								<span class="Ignore">*</span><span class="String">:s%</span><span class="Ignore">*</span>
如果 <span class="Special">{string}</span> 等于 &quot;%&quot;，且 <span class="Type">'cpoptions'</span> 选项包含 '/'，重复使用上次替代命令的
<span class="Special">{string}</span>，见 <span class="Ignore">|</span><span class="Identifier">cpo-/</span><span class="Ignore">|</span>

<span class="PreProc">magic	nomagic	  动作   </span><span class="Ignore"> ~</span>
  &amp;	  \&amp;	  替代为完整的匹配				     <span class="Ignore">*</span><span class="String">s/\&amp;</span><span class="Ignore">*</span>
 \&amp;	   &amp;	  替代为 &amp;
      \0	  替代为完整的匹配			 	   <span class="Ignore">*</span><span class="String">\0</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">s/\0</span><span class="Ignore">*</span>
      \1	  替代为匹配的第一个 () 里面的内容		     <span class="Ignore">*</span><span class="String">s/\1</span><span class="Ignore">*</span>
      \2	  替代为匹配的第二个 () 里面的内容		     <span class="Ignore">*</span><span class="String">s/\2</span><span class="Ignore">*</span>
      ..	  ..						     <span class="Ignore">*</span><span class="String">s/\3</span><span class="Ignore">*</span>
      \9	  替代为匹配的第九个 () 里面的内容		     <span class="Ignore">*</span><span class="String">s/\9</span><span class="Ignore">*</span>
  ~	  \~	  替代为前一个 substitute 的替代字符串		     <span class="Ignore">*</span><span class="String">s~</span><span class="Ignore">*</span>
 \~	   ~	  替代为 ~					     <span class="Ignore">*</span><span class="String">s/\~</span><span class="Ignore">*</span>
      \u	  下一个字符成为大写				     <span class="Ignore">*</span><span class="String">s/\u</span><span class="Ignore">*</span>
      \U	  其后字符成为大写，直到 \E 出现		     <span class="Ignore">*</span><span class="String">s/\U</span><span class="Ignore">*</span>
      \l	  下一个字符成为小写				     <span class="Ignore">*</span><span class="String">s/\l</span><span class="Ignore">*</span>
      \L	  其后字符成为小写，直到 \E 出现		     <span class="Ignore">*</span><span class="String">s/\L</span><span class="Ignore">*</span>
      \e	  结束 \u、\U、\l 和 \L (注意: 不是 <span class="Special">&lt;Esc&gt;</span>!)	     <span class="Ignore">*</span><span class="String">s/\e</span><span class="Ignore">*</span>
      \E	  结束 \u、\U、\l 和 \L				     <span class="Ignore">*</span><span class="String">s/\E</span><span class="Ignore">*</span>
      <span class="Special">&lt;CR&gt;</span>	  把该行在此位置一分为二
		  (<span class="Special">&lt;CR&gt;</span> 以 <span class="Special">CTRL-V</span> <span class="Special">&lt;Enter&gt;</span> 方式输入)		     <span class="Ignore">*</span><span class="String">s&lt;CR&gt;</span><span class="Ignore">*</span>
      \r	  同上						     <span class="Ignore">*</span><span class="String">s/\r</span><span class="Ignore">*</span>
      \<span class="Special">&lt;CR&gt;</span>	  插入一个回车 (<span class="Special">CTRL-M</span>)
		  (<span class="Special">&lt;CR&gt;</span> 以 <span class="Special">CTRL-V</span> <span class="Special">&lt;Enter&gt;</span> 方式输入)		     <span class="Ignore">*</span><span class="String">s/\&lt;CR&gt;</span><span class="Ignore">*</span>
      \n	  插入一个 <span class="Special">&lt;NL&gt;</span> (文件里的 <span class="Special">&lt;NUL&gt;</span>)
		  (此处并不是换行)				     <span class="Ignore">*</span><span class="String">s/\n</span><span class="Ignore">*</span>
      \b	  插入一个 <span class="Special">&lt;BS&gt;</span>					     <span class="Ignore">*</span><span class="String">s/\b</span><span class="Ignore">*</span>
      \t	  插入一个 <span class="Special">&lt;Tab&gt;</span>				     <span class="Ignore">*</span><span class="String">s/\t</span><span class="Ignore">*</span>
      \\	  插入单个反斜杠				     <span class="Ignore">*</span><span class="String">s/\\</span><span class="Ignore">*</span>
      \x	  其中 x 是上面没提到的任何一个字符:
		  保留作将来的扩展

这里的特殊含义也用于 <span class="Ignore">|</span><span class="Identifier">substitute()</span><span class="Ignore">|</span> 函数的第三个参数 <span class="Special">{sub}</span>，除了若干例外:
  - % 总是插入百分号，与 <span class="Type">'cpoptions'</span> 无关。
  - 总是假定有魔术性，与 <span class="Type">'magic'</span> 无关。
  - ~ 总是插入波浪符。
  - <span class="Special">&lt;CR&gt;</span> 和 \r 插入回车 (<span class="Special">CTRL-M</span>)。
  - \<span class="Special">&lt;CR&gt;</span> 没有特殊意义，只是 \x 之一。

示例:<span class="Ignore"> &gt;</span>
<span class="Comment">  :s/a\|b/xxx\0xxx/g		 修改 &quot;a b&quot;	 为 &quot;xxxaxxx xxxbxxx&quot;</span>
<span class="Comment">  :s/\([abc]\)\([efg]\)/\2\1/g	 修改 &quot;af fa bg&quot; 为 &quot;fa fa gb&quot;</span>
<span class="Comment">  :s/abcde/abc^Mde/		 修改 &quot;abcde&quot;    为 &quot;abc&quot;、&quot;de&quot; (两行)</span>
<span class="Comment">  :s/$/\^M/			 修改 &quot;abcde&quot;    为 &quot;abcde^M&quot;</span>
<span class="Comment">  :s/\w\+/\u\0/g		 修改 &quot;bla bla&quot;  为 &quot;Bla Bla&quot;</span>
<span class="Comment">  :s/\w\+/\L\u\0/g		 修改 &quot;BLA bla&quot;  为 &quot;Bla Bla&quot;</span>

注意: &quot;\L\u&quot; 可用于使单词的首个字母变大写。此行为和 Vi 以及旧版 Vim 不兼容，那
里 &quot;\u&quot; 会抵消 ”\L&quot;。&quot;\U\l&quot; 亦然。

注意: 在以前的版本里，<span class="Special">CTRL-V</span> 以特殊的方式处理。因为和 Vi 不兼容，该功能已经被
去掉了，现在用反斜杠来替代。

<span class="PreProc">命令		文本	结果</span><span class="Ignore"> ~</span>
:s/aa/a^Ma/	aa	a<span class="Special">&lt;line-break&gt;</span>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<span class="Special">&lt;line-break&gt;</span>a

(你需要输入 <span class="Special">CTRL-V</span> <span class="Special">&lt;CR&gt;</span> 来得到这里的 ^M)

&quot;\1&quot;，&quot;\2&quot; 等里的数字是基于模式里 &quot;\(&quot; 出现的顺序 (从左到右)。如果一个括号组匹
配多次，最后一次的匹配被使用在 &quot;\1&quot;，&quot;2&quot; 等里。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">  :s/\(\(a[a-d] \)*\)/\2/      修改 &quot;aa ab x&quot; 为 &quot;ab x&quot;</span>
&quot;\2&quot; 对应 &quot;\(a[a-d] \)&quot;。第一次匹配 &quot;aa &quot;，第二次匹配 &quot;ab &quot;。

如果括号和 '|' 组合使用，如 \([ab]\)\|\([cd]\)，两者有一个会不匹配，所以 \1 或
者 \2 会为空。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">  :s/\([ab]\)\|\([cd]\)/\1x/g   修改 &quot;a b c d&quot; 为 &quot;ax bx x x&quot;</span>

<span class="Ignore">&lt;</span>
		<span class="Ignore">*</span><span class="String">:sc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sce</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:scg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sci</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:scI</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:scl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:scp</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgc</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">:sge</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgi</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgI</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgn</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgp</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sgr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sI</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:si</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">:sic</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sie</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIe</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sin</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIn</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIp</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">:sip</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sIr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sir</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:src</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:srg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sri</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:srI</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:srl</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">:srn</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:srp</span><span class="Ignore">*</span>
<span class="PreProc">2-字母和 3-字母的 :substitute 命令</span><span class="Ignore"> ~</span>

     :substitute 命令列表
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl  ---
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie  --- :si  :siI :sin :sip  --- :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src  --- :srg :sri :srI :srn :srp :srl :sr

例外:
     :scr  是  <span class="Ignore">`</span><span class="Comment">:scriptnames</span><span class="Ignore">`</span>
     :se   是  <span class="Ignore">`</span><span class="Comment">:set</span><span class="Ignore">`</span>
     :sig  是  <span class="Ignore">`</span><span class="Comment">:sign</span><span class="Ignore">`</span>
     :sil  是  <span class="Ignore">`</span><span class="Comment">:silent</span><span class="Ignore">`</span>
     :sn   是  <span class="Ignore">`</span><span class="Comment">:snext</span><span class="Ignore">`</span>
     :sp   是  <span class="Ignore">`</span><span class="Comment">:split</span><span class="Ignore">`</span>
     :sl   是  <span class="Ignore">`</span><span class="Comment">:sleep</span><span class="Ignore">`</span>
     :sre  是  <span class="Ignore">`</span><span class="Comment">:srewind</span><span class="Ignore">`</span>


以表达式方式替代				<span class="Ignore">*</span><span class="String">sub-replace-expression</span><span class="Ignore">*</span>
						<span class="Ignore">*</span><span class="String">sub-replace-\=</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">s/\=</span><span class="Ignore">*</span>
当替代字符串以 &quot;\=&quot; 开始时，其余部分被解释为一个表达式。

除了 &quot;<span class="Special">&lt;CR&gt;</span>&quot; 以外，<span class="Ignore">|</span><span class="Identifier">sub-replace-special</span><span class="Ignore">|</span> 提到的字符的特殊含义这里不适用。<span class="Special">&lt;NL&gt;</span>
字符被用作换行符，双引号字符串 &quot;\n&quot; 也可以。在 <span class="Special">&lt;NL&gt;</span> 之前加上反斜杠得到一个真正
的 <span class="Special">&lt;NL&gt;</span> 字符 (在文件里成为 NUL)。

&quot;\=&quot; 记法也可用于 <span class="Ignore">|</span><span class="Identifier">substitute()</span><span class="Ignore">|</span> 函数的第三个参数 <span class="Special">{sub}</span> 之内，这时，
<span class="Ignore">|</span><span class="Identifier">sub-replace-special</span><span class="Ignore">|</span> 指出的特殊含义完全不适用。具体说，<span class="Special">&lt;CR&gt;</span> 和 <span class="Special">&lt;NL&gt;</span> 不用作换
行，而分别是回车和新行。

如果结果是 <span class="Ignore">|</span><span class="Identifier">List</span><span class="Ignore">|</span>，连接其中的项目并以换行符分隔。这样，每个项目单独成为一行，
当然本身就包含换行符的除外。

完整的匹配可以用 &quot;submatch(0)&quot; 得到。首个括号里的匹配可以用 &quot;submatch(1)&quot;，余
者类似。

小心: 分隔符不能出现在表达式里！可以考虑使用 &quot;@&quot; 或者 &quot;:&quot; 那样的字符。执行结果
里出现分隔符不成问题。

例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:s@\n@\=&quot;\r&quot; . expand(&quot;$HOME&quot;) . &quot;\r&quot;@</span>
把换行符替代为包含 $HOME 值的一个新行。<span class="Ignore"> &gt;</span>

<span class="Comment">	s/E/\=&quot;\&lt;Char-0x20ac&gt;&quot;/g</span>
把所有的 'E' 字符替代为欧元符号。详见 <span class="Ignore">|</span><span class="Identifier">&lt;Char-&gt;</span><span class="Ignore">|</span>。


4.3 搜索与替代						<span class="Ignore">*</span><span class="String">search-replace</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:pro</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:promptfind</span><span class="Ignore">*</span>
:promptf[ind] <span class="Special">[string]</span>
			弹出搜索对话框。如果给出 <span class="Special">[string]</span>，它被用作初始的搜索
			字符串。
			{仅适用于 Win32、Motif 和 GTK GUI 环境}

						<span class="Ignore">*</span><span class="String">:promptr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:promptrepl</span><span class="Ignore">*</span>
:promptr[epl] <span class="Special">[string]</span>
			弹出搜索/替代对话框。如果给出 <span class="Special">[string]</span>，它被用作初始的
			搜索字符串。
			{仅适用于 Win32、Motif 和 GTK GUI 环境}

4.4 改变制表						<span class="Ignore">*</span><span class="String">change-tabs</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">:ret</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:retab</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:retab!</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>ret[ab][!] <span class="Special">[new_tabstop]</span>
			把所有包含 <span class="Special">&lt;Tab&gt;</span> 的空白序列替代成由新的制表位
			<span class="Special">[new_tabstop]</span> 确定的空白序列。如果你不指定新的制表位，
			或者它为 0，Vim 使用原来的制表位 <span class="Type">'tabstop'</span>。
			已有的 Tab 的宽度总是用 <span class="Type">'tabstop'</span> 的当前值来计算。
			如果有 !，Vim 也在合适的时候，把只包含正常空格的字符串
			换成 Tab。
			如果置位了 <span class="Type">'expandtab'</span>，Vim 把所有的 Tab 换成相当的空
			格。
			该命令把 <span class="Type">'tabstop'</span> 设为新值。如果按照缺省的情况，在全
			文件上进行处理，视觉上应该不会有任何改变。
			小心: 该命令修改 C 程序中的字符串里的任何 <span class="Special">&lt;Tab&gt;</span> 字符。
			要避免这一点，用 &quot;\t&quot; (无论如何，应该养成这个好的习
			惯)。
			<span class="Ignore">`</span><span class="Comment">:retab!</span><span class="Ignore">`</span> 也把空格序列换成 <span class="Special">&lt;Tab&gt;</span>，这可能会使 printf()
			引起混淆。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">retab-example</span><span class="Ignore">*</span>
下面的例子使用自动命令和 &quot;:retab&quot; 来编辑使用制表位为 8 的文件，但在编辑时制表
位设置为 4。警告: 字符串里的空格会被改变。另见 <span class="Type">'softtabstop'</span> 选项。<span class="Ignore"> &gt;</span>

<span class="Comment">  :auto BufReadPost	*.xx	retab! 4</span>
<span class="Comment">  :auto BufWritePre	*.xx	retab! 8</span>
<span class="Comment">  :auto BufWritePost	*.xx	retab! 4</span>
<span class="Comment">  :auto BufNewFile	*.xx	set ts=4</span>

<span class="PreProc">==============================================================================</span>
5. 复制并移动文本					<span class="Ignore">*</span><span class="String">copy-move</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">quote</span><span class="Ignore">*</span>
&quot;<span class="Special">{a-zA-Z0-9.%#:-&quot;}</span>	指定下次的删除、抽出和放置命令使用的寄存器
			<span class="Special">{a-zA-Z0-9.%#:-&quot;}</span> (大写字符使得删除和抽出命令附加到该
			寄存器) (<span class="Special">{.%#:}</span> 只能用于放置命令)。

							<span class="Ignore">*</span><span class="String">:reg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:registers</span><span class="Ignore">*</span>
:reg[isters]		显示所有编号和命名寄存器的内容。但不列出用于 <span class="Ignore">|</span><span class="Identifier">:redir</span><span class="Ignore">|</span>
			目的地的寄存器。
			<span class="Special">{Vi 无此功能}</span>

:reg[isters] <span class="Special">{arg}</span>	显示 <span class="Special">{arg}</span> 里提到的编号和命名寄存器的内容。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:reg 1a</span>
<span class="Ignore">&lt;</span>			显示寄存器 '1' 和 'a'。<span class="Special">{arg}</span> 里可以用空格。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:di</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:display</span><span class="Ignore">*</span>
:di[splay] <span class="Special">[arg]</span>	和 :registers 相同。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">y</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">yank</span><span class="Ignore">*</span>
[&quot;x]y<span class="Special">{motion}</span>		抽出 <span class="Special">{motion}</span> 跨越的文本 [到寄存器 x]。如果没有字符被
			抽出 (例如，在第一列执行 &quot;y0&quot;) 并且 <span class="Type">'cpoptions'</span> 里包括
			'E' 标志位，这是一个错误。

							<span class="Ignore">*</span><span class="String">yy</span><span class="Ignore">*</span>
[&quot;x]yy			抽出 <span class="Special">[count]</span> 行 [到寄存器 x] <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作。

							<span class="Ignore">*</span><span class="String">Y</span><span class="Ignore">*</span>
[&quot;x]Y			抽出 <span class="Special">[count]</span> 行 [到寄存器 x] (等同于 yy，<span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行
			动作)。如果你想要 &quot;Y&quot; 执行从光标到行尾的操作 (更合乎逻
			辑，但是与 Vi 不兼容)，用 &quot;:map Y y$&quot;。

							<span class="Ignore">*</span><span class="String">v_y</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]y		抽出高亮文本 [到寄存器 x] (关于 <span class="Special">{Visual}</span> 见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_Y</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>[&quot;x]Y		抽出高亮行 [到寄存器 x] (关于 <span class="Special">{Visual}</span> 见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:y</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:yank</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E850</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>y[ank] [x]	抽出 <span class="Special">[range]</span> 所指定的行 [到寄存器 x]。仅当包含
			<span class="Ignore">|</span><span class="Identifier">+clipboard</span><span class="Ignore">|</span> 特性时才可以抽出到 &quot;* 或 &quot;+ 寄存器。

:<span class="Special">[range]</span>y[ank] [x] <span class="Special">{count}</span>
			从 <span class="Special">[range]</span> 的最后一行开始 (缺省: 当前行
			<span class="Ignore">|</span><span class="Identifier">cmdline-ranges</span><span class="Ignore">|</span>) 抽出 <span class="Special">{count}</span> 行 [到寄存器 x]。

							<span class="Ignore">*</span><span class="String">p</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">put</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E353</span><span class="Ignore">*</span>
[&quot;x]p			放置文本 [从寄存器 x] 在光标之后 <span class="Special">[count]</span> 次。<span class="Special">{Vi: 没有</span>
			<span class="Special">计数}</span>

							<span class="Ignore">*</span><span class="String">P</span><span class="Ignore">*</span>
[&quot;x]P			放置文本 [从寄存器 x] 在光标之前 <span class="Special">[count]</span> 次。<span class="Special">{Vi: 没有</span>
			<span class="Special">计数}</span>

							<span class="Ignore">*</span><span class="String">&lt;MiddleMouse&gt;</span><span class="Ignore">*</span>
[&quot;x]<span class="Special">&lt;MiddleMouse&gt;</span>	从一个寄存器放置文本在光标之前 <span class="Special">[count]</span> 次。除非另外指
			定，否则用 &quot;* 寄存器。
			光标停留在新文本的尾部。
			只有在 <span class="Type">'mouse'</span> 包含 'n' 或者 'a' 时鼠标才会工作。
			<span class="Special">{Vi 无此功能}</span>
			如果你有滚轮鼠标而且经常不小心粘贴了文本，你可以使用以
			下映射来关闭鼠标中键粘贴的功能:<span class="Ignore"> &gt;</span>
<span class="Comment">				:map &lt;MiddleMouse&gt; &lt;Nop&gt;</span>
<span class="Comment">				:imap &lt;MiddleMouse&gt; &lt;Nop&gt;</span>
<span class="Ignore">&lt;</span>			你也许还想要关闭多键击的功能。参见 <span class="Ignore">|</span><span class="Identifier">double-click</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">gp</span><span class="Ignore">*</span>
[&quot;x]gp			如同 &quot;p&quot;，但光标停留在新文本之后。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gP</span><span class="Ignore">*</span>
[&quot;x]gP			如同 &quot;P&quot;，但光标停留在新文本之后。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:pu</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:put</span><span class="Ignore">*</span>
:<span class="Special">[line]</span>pu[t] [x]	放置文本 [从寄存器 x] 在行号 <span class="Special">[line]</span> (缺省为当前行) 之
			后。它总是 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作，因而这个命令可以用来把抽
			出的块放置在新行上。
			如果未指定寄存器，则取决于 <span class="Type">'cb'</span> 选项: 如果 <span class="Type">'cb'</span> 包含
			&quot;unnamedplus&quot;，则从 + 寄存器 <span class="Ignore">|</span><span class="Identifier">quoteplus</span><span class="Ignore">|</span> 取出，否则如
			果 <span class="Type">'cb'</span> 包含 &quot;unnamed&quot;，则从 * 寄存器 <span class="Ignore">|</span><span class="Identifier">quotestar</span><span class="Ignore">|</span> 取
			出，否则，从无名寄存器 <span class="Ignore">|</span><span class="Identifier">quote_quote</span><span class="Ignore">|</span> 取出。
			寄存器也可以是 '='，跟随一个可选的表达式。表达式继续到
			该命令结束为止。你需要在 '|' 和 '&quot;' 字符前加上反斜杠不
			让它们终止你的命令行。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:put ='path' . \&quot;,/test\&quot;</span>
<span class="Ignore">&lt;</span>			如果 '=' 之后没有表达式，Vim 使用前一个表达式。用
			&quot;:dis =&quot; 你可以看到它。

:<span class="Special">[line]</span>pu[t]! [x]	放置文本 [从寄存器 x] 在行号 <span class="Special">[line]</span> (缺省为当前行) 之
			前。

[&quot;x]]p		    或					<span class="Ignore">*</span><span class="String">]p</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">]&lt;MiddleMouse&gt;</span><span class="Ignore">*</span>
[&quot;x]]<span class="Special">&lt;MiddleMouse&gt;</span>	类似 &quot;p&quot;，但调整当前行的缩进。只有在 <span class="Type">'mouse'</span> 包含 'n'
			或者 'a' 时鼠标才会工作。<span class="Special">{Vi 无此功能}</span>

[&quot;x][P		    或					<span class="Ignore">*</span><span class="String">[P</span><span class="Ignore">*</span>
[&quot;x]]P		    或					<span class="Ignore">*</span><span class="String">]P</span><span class="Ignore">*</span>
[&quot;x][p		    或					<span class="Ignore">*</span><span class="String">[p</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">[&lt;MiddleMouse&gt;</span><span class="Ignore">*</span>
[&quot;x][<span class="Special">&lt;MiddleMouse&gt;</span>	类似 &quot;P&quot;，但调整当前行的缩进。只有在 <span class="Type">'mouse'</span> 包含 'n'
			或者 'a' 时鼠标才会工作。<span class="Special">{Vi 无此功能}</span>

你可以用这些命令把文本从一个地方复制到另一个地方。首先，把文本用抽出、删除或者
修改命令取到一个寄存器里，然后用放置命令把寄存器的内容插入。你可以用这些命令把
文本从一个文件移动到另一个文件，因为 Vim 在切换缓冲区时保留所有的寄存器
(<span class="Special">CTRL-^</span> 命令可用来快捷地切换文件)。

				<span class="Ignore">*</span><span class="String">linewise-register</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">characterwise-register</span><span class="Ignore">*</span>
除了 :put 以外，你可以用 &quot;.&quot; 重复放置命令，你也可以撤销它们。如果保存到寄存器
文本的命令是 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作，Vim 把文本插入在光标所在的行之下 (&quot;p&quot;) 或之上
(&quot;P&quot;)。不然，Vim 把文本插入在光标的之后 (&quot;p&quot;) 或之前 (&quot;P&quot;)。&quot;:put&quot; 命令使得
Vim 总是把文本放在下一行。你可以用命令序列 &quot;xp&quot; 来交换两个字母。你可以用 &quot;ddp&quot;
命令序列来交换两行。你还可以用 &quot;deep&quot; 命令交换两个单词 (光标在第一个单词之前的
空白上)。你更可以在放置命令之后用 &quot;']&quot; 或者 &quot;`]&quot; 命令把光标移动到插入文本之
后，或者用 &quot;'[&quot; 或 &quot;`[&quot; 把光标移动到文本的开始处。

						<span class="Ignore">*</span><span class="String">put-Visual-mode</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_p</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">v_P</span><span class="Ignore">*</span>
在可视模式下使用如 <span class="Ignore">|</span><span class="Identifier">p</span><span class="Ignore">|</span> 或者 <span class="Ignore">|</span><span class="Identifier">P</span><span class="Ignore">|</span> 之类的放置命令时，Vim 试图把选择的文本替换成寄
存器的内容。是否工作如你所愿决定于选择的类型和寄存器里文本的类型。对于列块选择
而言，它也决定于列块的大小，和头尾是否在已存在的字符上。(实现细节: 实际上，它
先把寄存器的内容放到选择区之后，再删除选择区的内容。)
前次选择的文本被放在无名寄存器中。如果希望把相同的文本重复放入可视选择区多次，
请选用其它寄存器。例如，先抽出要复制的文本，再可视化选择要替换的文本，然后使用
&quot;0p。重复任意多次均可，而每次无名寄存器都会被改变。

应用面向列块的可视模式命令抽出单行到寄存器时，粘贴该寄存器到某一可视选择的区域
会把该行复制到选择的每一行上 (也即，把选择的列块区域替代为被复制行的列块)。

							<span class="Ignore">*</span><span class="String">blockwise-register</span><span class="Ignore">*</span>
如果你使用面向列块的可视模式命令把文本存到寄存器里，文本列块会被插入在当前和其
后的行的当前列之前 (&quot;P&quot;) 或之后 (&quot;p&quot;)。Vim 使得整个文本列块从同一列开始。这
样，插入的文本看上去和抽出或删除时看起来一样。为了使之可能，Vim 可能需要把一些
<span class="Special">&lt;Tab&gt;</span> 字符替换成空格。不过，如果列块的宽度不是 <span class="Special">&lt;Tab&gt;</span> 宽度的整数倍并且插入列块
之后文本里包含 <span class="Special">&lt;Tab&gt;</span> 的时候，那些文本可能就不会那么整齐。

注意 在一个面向字符的抽出命令之后，Vim 把光标停留在最接近缓冲区开头的第一个被
抽出的字符之上。这意味着 &quot;yl&quot; 不会移动光标，但是 &quot;yh&quot; 把光标向左移一格。
逻辑:		在 Vi 里 &quot;y&quot; 命令跟一个反向的动作有时不会把光标移动到第一个被
		抽出的字符之上，因为屏幕没有刷新。Vim 符合 Posix 的规范，总是
		把光标移动到第一个字符之上。
在一个面向行的抽出命令之后，光标放在第一行上，但是列保持不变，所以不必然在第一
个抽出的字符上。

共有十种类型的寄存器:					<span class="Ignore">*</span><span class="String">registers</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E354</span><span class="Ignore">*</span>
1. 无名寄存器 &quot;&quot;
2. 10 个编号寄存器 &quot;0 到 &quot;9
3. 行内删除寄存器 &quot;-
4. 26 个命名的寄存器 &quot;a 到 &quot;z 或者 &quot;A 到 &quot;Z
5. 三个只读寄存器 &quot;:、&quot;. 和 &quot;%
6. 轮换缓冲区寄存器 &quot;#
7. 表达式寄存器 &quot;=
8. 选择和拖放寄存器 &quot;*、&quot;+ 和 &quot;~
9. 黑洞寄存器寄存器 &quot;_
10. 最近搜索模式寄存器 &quot;/

1. 无名寄存器 &quot;&quot;				<span class="Ignore">*</span><span class="String">quote_quote</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quotequote</span><span class="Ignore">*</span>
用 &quot;d&quot;、&quot;c&quot;、&quot;s&quot;、&quot;x&quot; 等命令删除或者用 &quot;y&quot; 等抽出命令复制的文本都被 Vim 用来填
充该寄存器，不管是否用到别的专门寄存器 (例如 &quot;xdd)。这就好像无名寄存器是指向最
近使用的那个寄存器的指针一样。使用大写寄存器进行添加时，无名寄存器包含和命名寄
存器相同的文本。'_' 寄存器是一个特例。&quot;_dd 不把删除的文本存在任何寄存器里。
不指定寄存器的放置命令 (p 或 P) 使用无名寄存器的内容。你也可以用 '&quot;' 作为名字
来访问该寄存器。这意味着要输入两个连续的双引号。写入 &quot;&quot; 寄存器将实际写到寄存器
&quot;0 上。
<span class="Special">{Vi: 寄存器内容在更换文件时丢失，没有 '&quot;'}</span>

2. 编号寄存器 &quot;0 到 &quot;9			<span class="Ignore">*</span><span class="String">quote_number</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote0</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote1</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span class="String">quote2</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote3</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote4</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote9</span><span class="Ignore">*</span>
Vim 把抽出和删除命令的文本保存在这些寄存器里。
   编号寄存器 0 包含最近抽出的文本，除非该命令用 [&quot;x] 指定了别的寄存器。
   编号寄存器 1 包含了最近删除或者修改的文本，除非该命令用 [&quot;x] 指定了别的寄存
器或者该文本小于一行 (该情况下使用行内删除寄存器)。以下移动命令在应用删除操作
符时例外: <span class="Ignore">|</span><span class="Identifier">%</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">(</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">)</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">`</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">/</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">?</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">n</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">N</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">{</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">}</span><span class="Ignore">|</span>。它们总是使用寄
存器 &quot;1 (为了和 Vi 兼容)。如果文本小于一行，同时使用 &quot;- 寄存器。
注意 这些字符可能会被映射。例如，matchit 插件会映射 % 字符。
   每来一次新的删除和修改，Vim 把前一次的寄存器 1 的内容复制到寄存器 2，2 到
3，依此类推。而寄存器 9 的内容就丢失了。
<span class="Special">{Vi: 编号寄存器的内容在更换文件时丢失；寄存器 0 不存在}</span>

3. 行内删除寄存器 &quot;-					<span class="Ignore">*</span><span class="String">quote_-</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote-</span><span class="Ignore">*</span>
该寄存器保存删除不到一行内容的命令的文本，除非该命令用 [&quot;x] 指定了寄存器。
<span class="Special">{Vi 无此功能}</span>

4. 命名寄存器 &quot;a 到 &quot;z 或者 &quot;A 到 &quot;Z			<span class="Ignore">*</span><span class="String">quote_alpha</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quotea</span><span class="Ignore">*</span>
Vim 只有在你指定的时候才使用这些寄存器。指定为小写字母时替换原来的内容，指定为
大写字母时附加到原来的内容。如果 <span class="Type">'cpoptions'</span> 里有 '&gt;' 标志位，在附加文本前插入
一个换行符。


5. 只读寄存器 &quot;:、&quot;. 和 &quot;%
它们是 '%'、'#' (译者注: 原文如此)、':' 和 '.'。你只能在 &quot;p&quot;、&quot;P&quot;、&quot;:put&quot; 命令
和 <span class="Special">CTRL-R</span> 的时候使用它们。<span class="Special">{Vi 无此功能}</span>
						<span class="Ignore">*</span><span class="String">quote_.</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote.</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E29</span><span class="Ignore">*</span>
	&quot;.	包含最近插入的文本 (和插入模式命令 <span class="Special">CTRL-A</span> 和 <span class="Special">CTRL-@</span> 插入的一
		样)。注意: 它不适用于 <span class="Special">CTRL-R</span> 在命令行上的操作。它的工作方式稍
		有不同，例如，文本是被插入而不是放置的 (<span class="Type">'textwidth'</span> 和其它选项
		影响插入的内容)。
							<span class="Ignore">*</span><span class="String">quote_%</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote%</span><span class="Ignore">*</span>
	&quot;%	包含当前文件名。
						<span class="Ignore">*</span><span class="String">quote_:</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote:</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E30</span><span class="Ignore">*</span>
	&quot;:	包含最近执行过的命令行。例如: 用 &quot;@:&quot; 重复上次执行过的命令行命
		令。只有当一个命令行中至少一个字符是键入的，该寄存器才会保存命
		令行的内容。所以，如果命令行完全来自映射，该寄存器保持不变。
		{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+cmdline_hist</span><span class="Ignore">|</span> 特性才有效}
							<span class="Ignore">*</span><span class="String">quote_#</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote#</span><span class="Ignore">*</span>
6. 轮换文件寄存器 &quot;#
包含当前窗口轮换文件的名字。它影响 <span class="Special">CTRL-^</span> 的命令的工作方式。
该寄存器是可写的，主要用来帮助插件在改变其值后恢复原值。接受缓冲区号:<span class="Ignore"> &gt;</span>
<span class="Comment">    let altbuf = bufnr(@#)</span>
<span class="Comment">    ...</span>
<span class="Comment">    let @# = altbuf</span>
如果传递了不存在的缓冲区号，会报错 <span class="Ignore">|</span><span class="Identifier">E86</span><span class="Ignore">|</span>。
也可接受现有缓冲区名的匹配:<span class="Ignore"> &gt;</span>
<span class="Comment">    let @# = 'buffer_name'</span>
如果有多于一个缓冲区匹配该名，报错 <span class="Ignore">|</span><span class="Identifier">E93</span><span class="Ignore">|</span>，如果没有缓冲区匹配该名，也会报错
<span class="Ignore">|</span><span class="Identifier">E94</span><span class="Ignore">|</span>。

7. 表达式寄存器 &quot;=				<span class="Ignore">*</span><span class="String">quote_=</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote=</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">@=</span><span class="Ignore">*</span>
其实并没有这么一个寄存器可以储存文本，但是这是用来在使用寄存器的命令中使用表达
式的一个方式。表达式寄存器是可读写的。

&quot; 之后输入 '=' 或者输入 <span class="Special">CTRL-R</span> 时，光标移到命令行上，这时你可以输入任何的表达
式 (见 <span class="Ignore">|</span><span class="Identifier">expression</span><span class="Ignore">|</span>)。所有普通的命令行编辑命令都可以使用，还有一个表达式专门的
历史表。当你按回车结束命令行时，Vim 计算表达式的结果。如果你用 <span class="Special">&lt;Esc&gt;</span> 结束，Vim
终止表达式。如果你不输入表达式，Vim 使用最近的表达式 (和 &quot;/&quot; 命令的处理相似)。

表达式的计算结果必须是一个字符串。数值结果会自动转化为字符串。对 &quot;p&quot; 和 &quot;:put&quot;
命令而言，浮点数结果也会被转化为字符串。如果结果为列表，每个成员被转成字符串，
然后被单独放在一行上。字典、函数引用类型的结果则产生错误信息 (通过 string() 转
化)。

如果 &quot;= 寄存器被 &quot;p&quot; 命令使用，该字符串会在 <span class="Special">&lt;NL&gt;</span> 字符处断开。如果该字符串以
<span class="Special">&lt;NL&gt;</span> 结尾，则它被视为一个面向行的寄存器。<span class="Special">{Vi 无此功能}</span>

8. 选择和拖放寄存器 &quot;*、&quot;+ 和 &quot;~
用这些寄存器来保存和取得 GUI 界面选择的文本。参见 <span class="Ignore">|</span><span class="Identifier">quotestar</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">quoteplus</span><span class="Ignore">|</span>。
如果剪贴板不存在或者不工作，使用无名寄存器。Unix 上，仅当 <span class="Ignore">|</span><span class="Identifier">+xterm_clipboard</span><span class="Ignore">|</span>
特性存在时剪贴板才可用。<span class="Special">{Vi 无此功能}</span>

注意 &quot;* 和 &quot;+ 在 X11 系统上有分别。关于该差别的解释，参见 <span class="Ignore">|</span><span class="Identifier">x11-selection</span><span class="Ignore">|</span>。在
MS-Windows 上，&quot;* 和 &quot;+ 的使用实际上是等价的，可见 <span class="Ignore">|</span><span class="Identifier">gui-clipboard</span><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">quote_~</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote~</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">&lt;Drop&gt;</span><span class="Ignore">*</span>
只读的 &quot;~ 寄存器保存最近一次拖放操作放下的文本。如果有什么东西被放到 Vim 上，
&quot;~ 寄存器被填充，<span class="Special">&lt;Drop&gt;</span> 虚拟键被激活。如果你需要，你可以重定义该键的映射；缺省
的动作 (适用于所有模式) 是把 &quot;~ 寄存器的内容插入到当前光标位置。<span class="Special">{Vi 无此功能}</span>
{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+dnd</span><span class="Ignore">|</span> 特性才有效，当前只适用于 GTK GUI 版本}

注意: &quot;~ 寄存器仅用于在 Vim 上拖放普通文本。拖放 URI 列表在内部处理。

9. 黑洞寄存器 &quot;_				<span class="Ignore">*</span><span class="String">quote_</span><span class="Ignore">*</span>
当写到这个寄存器时，什么都不会发生。这可以用来删除文本，而不影响任何正常的寄存
器。从该寄存器读时，什么都不会返回。<span class="Special">{Vi 无此功能}</span>

10. 最近搜索模式寄存器	&quot;/			<span class="Ignore">*</span><span class="String">quote_/</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">quote/</span><span class="Ignore">*</span>
含有最近搜索的模式。它被 &quot;n&quot; 和 <span class="Type">'hlsearch'</span> 使用。可以用 <span class="Ignore">`</span><span class="Comment">:let</span><span class="Ignore">`</span> 来修改。你可以
改变它使得 <span class="Type">'hlsearch'</span> 不经过实际的搜索直接高亮某些匹配。你不能把抽出或者删除命
令的内容放到该寄存器上。搜索方向则可从 <span class="Ignore">|</span><span class="Identifier">v:searchforward</span><span class="Ignore">|</span> 得到。
注意 从函数返回时该值被复原 <span class="Ignore">|</span><span class="Identifier">function-search-undo</span><span class="Ignore">|</span>。
<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">@/</span><span class="Ignore">*</span>
你可以用 <span class="Ignore">`</span><span class="Comment">:let</span><span class="Ignore">`</span> 命令写到一个寄存器 <span class="Ignore">|</span><span class="Identifier">:let-@</span><span class="Ignore">|</span>。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:let @/ = &quot;the&quot;</span>

如果你用放置命令而不指定寄存器，Vim 使用上次填充的寄存器 (这也是无名寄存器的内
容)。如果你弄糊涂了，用 <span class="Ignore">`</span><span class="Comment">:dis</span><span class="Ignore">`</span> 命令看看 Vim 会放置什么内容 (该命令显示所有的有
名和无名的寄存器；无名寄存器被标为 '&quot;')。

下面三个命令总是针对整行工作。

:<span class="Special">[range]</span>co[py] <span class="Special">{address}</span>				<span class="Ignore">*</span><span class="String">:co</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:copy</span><span class="Ignore">*</span>
			把 <span class="Special">[range]</span> 指定的行复制到 <span class="Special">{address}</span> 给出的行之下。

							<span class="Ignore">*</span><span class="String">:t</span><span class="Ignore">*</span>
:t			和 :copy 等价。

:<span class="Special">[range]</span>m[ove] <span class="Special">{address}</span>			<span class="Ignore">*</span><span class="String">:m</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:mo</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:move</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E134</span><span class="Ignore">*</span>
			把 <span class="Special">[range]</span> 指定的行移动到 <span class="Special">{address}</span> 给出的行之下。

<span class="PreProc">==============================================================================</span>
6. 文本排版						<span class="Ignore">*</span><span class="String">formatting</span><span class="Ignore">*</span>

:<span class="Special">[range]</span>ce[nter] <span class="Special">[width]</span>				<span class="Ignore">*</span><span class="String">:ce</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:center</span><span class="Ignore">*</span>
			在 <span class="Special">[range]</span> 指定范围的行和 <span class="Special">[width]</span> 限定的列 (缺省为
			<span class="Type">'textwidth'</span>，如其为 0，则取 80) 范围内的文本居中对齐。
			<span class="Special">{Vi 无此功能}</span>

:<span class="Special">[range]</span>ri[ght] <span class="Special">[width]</span>					<span class="Ignore">*</span><span class="String">:ri</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:right</span><span class="Ignore">*</span>
			在 <span class="Special">[range]</span> 指定范围的行和 <span class="Special">[width]</span> 限定的列 (缺省为
			<span class="Type">'textwidth'</span>，如其为 0，则取 80) 范围内的文本靠右对齐。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:le</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:left</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>le[ft] <span class="Special">[indent]</span>
			在 <span class="Special">[range]</span> 指定范围的行的文本靠左对齐。其缩进的距离可
			由 <span class="Special">[indent]</span> 设置 (缺省为 0)。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gq</span><span class="Ignore">*</span>
gq<span class="Special">{motion}</span>		对 <span class="Special">{motion}</span> 动作跨越的行进行排版。
			排版使用如下三种方式之一:
			1. 如果 <span class="Type">'formatexpr'</span> 不为空，计算该表达式。每个缓冲区
			   的值可以不同。
			2. 如果 <span class="Type">'formatprg'</span> 不为空，使用外部程序。
			3. 否则，使用内部排版机制。

			第三种方式使用 <span class="Type">'textwidth'</span> 选项控制所有待排版行的行宽
			(见下)。
			如果 <span class="Type">'textwidth'</span> 选项为 0，则排版行宽设为屏幕的宽度
			(但最大宽度不超过 79)。
			<span class="Type">'formatoptions'</span> 选项控制排版的方式 <span class="Ignore">|</span><span class="Identifier">fo-table</span><span class="Ignore">|</span>。
			光标停留在排版行末行的第一个非空白处。
			注意: &quot;Q&quot; 命令以前执行此项功能。如果你还想继续用 &quot;Q&quot;
			来排版，执行如下映射命令:<span class="Ignore"> &gt;</span>
<span class="Comment">				:nnoremap Q gq</span>

gqgq							<span class="Ignore">*</span><span class="String">gqgq</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">gqq</span><span class="Ignore">*</span>
gqq			排版当前行。如带计数排版相应多行。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_gq</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>gq		排版高亮文本 (<span class="Special">{Visual}</span> 的部分参见 <span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gw</span><span class="Ignore">*</span>
gw<span class="Special">{motion}</span>		对 <span class="Special">{motion}</span> 动作跨越的行进行排版。和 <span class="Ignore">|</span><span class="Identifier">gq</span><span class="Ignore">|</span> 类似，但排版
			后光标恢复原位。而且不使用 <span class="Type">'formatprg'</span> 和 <span class="Type">'formatexpr'</span>
			选项。
			<span class="Special">{Vi 无此功能}</span>

gwgw							<span class="Ignore">*</span><span class="String">gwgw</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">gww</span><span class="Ignore">*</span>
gww			对当前行排版，其它和 &quot;gw&quot; 类同。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">v_gw</span><span class="Ignore">*</span>
<span class="Special">{Visual}</span>gw		排版高亮文本，其它和 &quot;gw&quot; 类同。(<span class="Special">{Visual}</span> 可见
			<span class="Ignore">|</span><span class="Identifier">Visual-mode</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

例如: 要排版当前段落，可用: 					<span class="Ignore">*</span><span class="String">gqap</span><span class="Ignore">*</span> <span class="Ignore"> &gt;</span>
<span class="Comment">	gqap</span>

&quot;gq&quot; 命令后，光标随着指定的移动命令移动。这使得用 &quot;.&quot; 进行连续排版成为可能。例
如，&quot;gqj&quot; (对当前行和下一行排版) 和 &quot;gq}&quot; (排版到段落尾) 便可如此。注意: 如果
设置了 <span class="Type">'formatprg'</span>，&quot;gq&quot; 把光标留在排版后的首行 (如同过滤命令那般)。

如果你想对当前段落排版后留在原来的位置，可用:<span class="Ignore"> &gt;</span>
<span class="Comment">	gwap</span>
如果你想使段落自动排版，可以在 <span class="Type">'formatoptions'</span> 里加入 'a' 标志位。参见
<span class="Ignore">|</span><span class="Identifier">auto-format</span><span class="Ignore">|</span>。

如果 <span class="Type">'autoindent'</span> 选项打开，Vim 用首行的缩进距离排版其后的所有行。

排版不会改变空行 (但会改变只有空白字符的行！)。

如果有连接行的操作，应用 <span class="Type">'joinspaces'</span> 选项。

你可以设置 <span class="Type">'formatexpr'</span> 选项为某表达式或设置 <span class="Type">'formatprg'</span> 选项为外部程序名，Vim
会用之进行文本排版。<span class="Type">'textwidth'</span> 等选项对外部程序的排版不起作用。

							<span class="Ignore">*</span><span class="String">right-justify</span><span class="Ignore">*</span>
Vim 没有靠右控制对齐 (right justify) 文本的命令。你可以用 &quot;par&quot; 这样的外部命令
来实现 (例如， &quot;!}par&quot; 对到段落尾的文本排版)，或者设置 <span class="Type">'formatprg'</span> 为 &quot;par&quot;。

							<span class="Ignore">*</span><span class="String">format-comments</span><span class="Ignore">*</span>
用户手册的 <span class="Ignore">|</span><span class="Identifier">30.6</span><span class="Ignore">|</span> 一节给出注释排版的总览。

Vim 可以自动对注释的插入和排版进行特殊处理。Vim 把以特定字符串开头 (忽略空白)
的行识别为注释。以下是三种不同类型的注释:

- 在每行的开头都出现的注释字符串。例如，外壳脚本使用的注释行都以 &quot;#&quot; 开头。
- 只在首行出现的注释字符串。使用连字符 &quot;-&quot; 的本列表就是这样的一个例子，
- 由三部分组成的注释，包括起始字符串，结尾字符串，和两者之间可选的行的起始字符
  串。三种字符串可分别指定。如下 C 风格的注释就是如此:
	/*
	 * this is a C comment
	 */

<span class="Type">'comments'</span> 选项是一个由逗号分隔的列表。每个部分定义一种类型的注释字符串。每个
部分的组成方式是:
	<span class="Special">{flags}</span>:<span class="Special">{string}</span>

<span class="Special">{string}</span> 是必须出现的字符串 (不作转义)。

<span class="Special">{flags}</span>:
  n	可嵌套的注释: 允许多个部分间的嵌套。例如，<span class="Type">'comments'</span> 为 &quot;n:),n:&gt;&quot;。则
	以 &quot;&gt; ) &gt;&quot; 开始的行视为注释。

  b	在 <span class="Special">{string}</span> 之后必须有空白字符 (<span class="Special">&lt;Space&gt;</span>、<span class="Special">&lt;Tab&gt;</span> 或 <span class="Special">&lt;EOL&gt;</span>)。

  f	该注释字符串只在首行出现。下一行不重复注释，但保留相同的缩进 (例如，带
  	符号的列表 (bullet-list))。

  s	三段式注释的起始字符串

  m	三段式注释的中间字符串

  e	三段式注释的结尾字符串

  l	左对齐。和 's' 或 'e' 一起使用。起始或结尾字符串的最左字符和中间字符串
	的最左字符对齐。
	这是缺省值，可以省略。详情见下。

  r	右对齐。同上，不过不是最左字符而是最右字符。详情见下。

  O	&quot;O&quot; 命令不把它当作注释。

  x	允许三段式注释用以下方式结束: 在中间字符串自动提供的情况下，在新行第一
	个动作是输入结尾字符串的最后一个字符。详情见下。

  <span class="Special">{digits}</span>
	在和 's' 或 'e' 一起使用时: 对自动插入的中间或结尾字符串增加 <span class="Special">{digit}</span>
	单位的位移。该位移以左对齐的位置为基准。详情见下。

  -<span class="Special">{digits}</span>
	和 <span class="Special">{digits}</span> 类似，但减少缩进。这只对开始或结尾部分至少有相当数量的缩进
	时才有效。

如果一个字符串没有 'f'、's'、'm' 或 'e' 任何一个标志位，Vim 假设注释字符串在每
行都重复出现。标志位部分可以为空。

在 <span class="Special">{string}</span> 之前或之后的任何空白都是 <span class="Special">{string}</span> 的一部分，所以不要随便留出开头或
结尾的空白，除非空白的确是注释字符串的一部分。

如果某个注释字符串是另一个字符串的一部分，先指定完整的，再指定部分的。例如，要
包含 &quot;-&quot; 和 &quot;-&gt;&quot;，用<span class="Ignore"> &gt;</span>
<span class="Comment">	:set comments=f:-&gt;,f:-</span>

三段式注释必须以开始、中间和结尾三部分给出，而且不能间杂其它的部分。一个三段式
C 注释的例子是<span class="Ignore"> &gt;</span>
<span class="Comment">	sr:/*,mb:*,ex:*/</span>
为了避免形如 &quot;*ptr&quot; 的内容被识别为注释，这里的中间字符串包含了 'b' 标志位。对
三段式注释而言，Vim 从开始和中间字符串之后查找结尾字符串。如果找到，注释就不会
再从下一行继续。三段式注释必须要有一个中间字符串，不然 Vim 无法识别中间的那些
行。

注意 上述三段式注释定义里的 &quot;x&quot; 标志位。当你在一个 C-注释里按回车时，Vim 会自
动在新行后插入中间字符串: &quot; * &quot;。要结束注释，你只需要在新行里首先键入 &quot;/&quot;。这
样就把中间字符串替换成结尾字符串并应用指定的对齐方式，成为了 &quot; */&quot;。从而省却了
先按退格键的麻烦。

如果同时匹配中间部分和结尾部分但结尾部分更长，使用结尾部分。这样 C 风格注释就
不需要中间部分后加空格了。

这里是一个关于用于对齐的标志位的例子，使得注释看起来很突出 (也很像一个 1 字)。
考虑注释字符串:<span class="Ignore"> &gt;</span>
<span class="Comment">	:set comments=sr:/***,m:**,ex-2:******/</span>
<span class="Ignore">&lt;</span>
                                   <span class="PreProc">/***</span><span class="Ignore"> ~</span>
<span class="Statement">                                     </span><span class="PreProc">**&lt;--右对齐，来自 &quot;r&quot; 标志位</span><span class="Ignore"> ~</span>
<span class="Statement">                                     </span><span class="PreProc">**</span><span class="Ignore"> ~</span>
  <span class="PreProc">2 个单位的位移，来自 &quot;2&quot; 标志位---&gt;**</span><span class="Ignore"> ~</span>
<span class="Statement">                                   </span><span class="PreProc">******/</span><span class="Ignore"> ~</span>
该例中，第一行注释是键入的，然后按回车四次，最后按 &quot;/&quot; 以结束注释。

这里是三部分注释的一些细节。有三个时间点应用对齐和位移标志位: 输入起始字符串后
开启新行、在结尾字符串前开启新行、三部分注释的自动结束。而结尾部分的对齐标志位
要反过来看；这样，相同的对齐标志位在分别用于 &quot;s&quot; 和 &quot;e&quot; 时才会使起始和结尾部分
有相同的缩进。每个注释部分只应用一种对齐方式，但位移优先于 &quot;r&quot; 和 &quot;l&quot; 标志位。

打开 <span class="Type">'cindent'</span> 在很多情况下会覆盖对齐标志位。使用其它方法，如 <span class="Ignore">|</span><span class="Identifier">gq</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">=</span><span class="Ignore">|</span> 来重
新缩进也不会参考对齐标志位。这些其它的排版选择可以定义类似的行为。一个担心是
<span class="Type">'cindent'</span> 虽然有众多附加的选项来对注释进行基于上下文的缩进，但不能再现三部分注
释的缩进对齐。但 <span class="Type">'indentexpr'</span> 应该有能力很好地处理三部分注释。

其它示例:<span class="Ignore"> &gt;</span>
<span class="Comment">   &quot;b:*&quot;	包含 &quot;*&quot; 开头的行，但 &quot;*&quot; 后面不是空白的除外。这样避免指针取值</span>
<span class="Comment">		操作 &quot;*str&quot; 被识别为注释。</span>
<span class="Comment">   &quot;n:&gt;&quot;	包含形如 &quot;&gt;&quot;、&quot;&gt;&gt;&quot;、&quot;&gt;&gt;&gt;&quot; 等开头的行。</span>
<span class="Comment">   &quot;fb:-&quot;	包含 &quot;- &quot; 开头的列表，可用来自动排版。</span>

该选项的缺省值是 &quot;b:#&quot;。这意味着 &quot;#include&quot; 开头的行不会被认为是注释，但
&quot;# define&quot; 是。这是个不得不然的妥协。

{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+comments</span><span class="Ignore">|</span> 特性才有效}

							<span class="Ignore">*</span><span class="String">fo-table</span><span class="Ignore">*</span>
你可以使用 <span class="Type">'formatoptions'</span> 选项来控制 Vim 如何对文本进行排版。<span class="Type">'formatoptions'</span>
是一个字符串，它可以包含下列字符。缺省设置是 &quot;tcq&quot;。为了提高可读性，你可以用逗
号分隔选项字符。

<span class="PreProc">字符	 在 'formatoptions' 里代表的含义  </span><span class="Ignore"> ~</span>

t	使用 <span class="Type">'textwidth'</span> 自动回绕文本
c	使用 <span class="Type">'textwidth'</span> 自动回绕注释，自动插入当前注释前导符。
r	在插入模式按回车时，自动插入当前注释前导符。
o	在普通模式按 'o' 或者 'O' 时，自动插入当前注释前导符。
q	允许 &quot;gq&quot; 排版时排版注释。
	注意 排版不会影响空行或者只有注释前导符的行。这样的行开启一个新段落，
	注释前导符的改变也是如此。
w	拖尾的空格指示下一行继续同一个段落。而以非空白字符结束的行结束一个段
	落。
a	自动排版段落。每当文本被插入或者删除时，段落都会自动进行排版。参见
	<span class="Ignore">|</span><span class="Identifier">auto-format</span><span class="Ignore">|</span>。
	如果 'c' 标志位存在，该设置只对识别的注释有效。
n	在对文本排版时，识别编号的列表。实际上，这里使用了 <span class="Type">'formatlistpat'</span> 选
	项，所以可以使用任何类型的列表。出现在数字之后的文本缩进距离被应用到后
	面的行。数字之后可以有可选的 '.'、 ':'、')'、']' 或者 '}'。
	注意 <span class="Type">'autoindent'</span> 也必须置位。不要和 &quot;2&quot; 一起使用，效果不好。
	示例:<span class="Ignore"> &gt;</span>
<span class="Comment">		1. 第一项</span>
<span class="Comment">		   回绕文字</span>
<span class="Comment">		2. 第二项</span>
2	在对文本排版时，将段落第二行而非第一行的缩进距离应用到其后的行上。这适
	用于第一行有特殊缩进需要的段落。注意 <span class="Type">'autoindent'</span> 也必须置位。
	示例:<span class="Ignore"> &gt;</span>
<span class="Comment">			first line of a paragraph</span>
<span class="Comment">		second line of the same paragraph</span>
<span class="Comment">		third line.</span>
<span class="Ignore">&lt;</span>	也适用于注释内部，并忽略注释前导符。
v	Vi-兼容的插入模式自动回绕: 只有在当前输入命令键入的空白上才会分行。
	(注意: 这并不能 100% Vi 兼容。Vi 在这方面有些 &quot;意想不到的特性&quot;，换而言
	之，漏洞。它使用屏幕列而非实际的列。)
b	和 'v' 类似，但只有在键入空白时还没抵达或者刚到回绕边界的时候才会自动
	回绕。如果一行在开始插入之前已经超过 <span class="Type">'textwidth'</span> 指定的长度，或者在到
	达 <span class="Type">'textwidth'</span> 之时没有输入过空白，Vim 不会自动回绕。
l	插入模式不分行: 当一行已经超过 <span class="Type">'textwidth'</span> 时，插入命令不会自动排版。
m	可以在任何值高于 255 的多字节字符上分行。这对亚洲文本尤其有用，因为每
	个字符都是单独的单位。
M	在连接行时，不要在多字节字符之前或之后插入空格。优先于 'B' 标志位。
B	在连接行时，不要在两个多字节字符之间插入空格。有 'M' 标志位时无效。
1	不要在单字母单词后分行。如有可能，在它之前分行。
j	在合适的场合，连接行时删除注释前导符。例如，连接:
		<span class="PreProc">int i;   // the index</span><span class="Ignore"> ~</span>
		         <span class="PreProc">// in the list</span><span class="Ignore"> ~</span>
	结果是:
		<span class="PreProc">int i;   // the index in the list</span><span class="Ignore"> ~</span>


't' 和 'c' 不同组合方式决定 Vim 何时进行自动回绕:
<span class="PreProc">值	行为</span><span class="Ignore">	~</span>
&quot;&quot;	没有自动排版 (你可以用 &quot;gq&quot; 进行手工排版)
&quot;t&quot;	自动排版文本，不包括注释
&quot;c&quot;	自动排版注释，不包括文本 (对 C 程序适用)
&quot;tc&quot;	自动排版文本和注释

注意 如果 <span class="Type">'textwidth'</span> 为 0，Vim 不会做任何自动排版 (但是会根据 <span class="Type">'comments'</span> 选项
自动插入注释前导符)。但 'a' 标志位存在时有例外。<span class="Ignore">|</span><span class="Identifier">auto-format</span><span class="Ignore">|</span>

注意 如果 <span class="Type">'paste'</span> 打开，Vim 也不会做任何排版。

注意 即使 Vim 不做自动回绕，仍然可以把 <span class="Type">'textwidth'</span> 设为非零。<span class="Type">'textwidth'</span> 对
&quot;gq&quot; 的排版依然有用。

如果 <span class="Type">'comments'</span> 选项包含 &quot;/*&quot;、&quot;*&quot; 和/或 &quot;*/&quot;，Vim 有一套处理这些注释更加聪明
的内嵌方法。在 &quot;/*&quot; 或 &quot;*/&quot; 之前或之后开始一个新行 (在 <span class="Type">'formatoptions'</span> 里有
'r' 或者 'o' 的情况下)，会自动给出正确的开始部分。排版或者自动回绕也会有相同的
处理。在以 &quot;/*&quot; 或者 &quot;*&quot; 开始并包含 &quot;*/&quot; 的行之后开启新行，就不会插入注释前导
符，而且新行的缩进由注释起始行决定。
例如:<span class="Ignore"> &gt;</span>
<span class="Comment">    /* ~</span>
<span class="Comment">     * 你的任何注释。</span>
<span class="Comment">     */ ~</span>
<span class="Comment">    该行的缩进和以上注释的起始行相同。</span>

上述这些应该已经十分够用了，尤其在与新的 :autocmd 命令协同使用时，可以为不同文
件类型提供不同的设置。

一些例子:
  适用于 C 代码 (只对注释排版):<span class="Ignore"> &gt;</span>
<span class="Comment">	:set fo=croq</span>
<span class="Ignore">&lt;</span> 适用于邮件/新闻 (排版所有文本，&quot;o&quot; 命令不开始注释):<span class="Ignore"> &gt;</span>
<span class="Comment">	:set fo=tcrq</span>
<span class="Ignore">&lt;</span>

自动排版					<span class="Ignore">*</span><span class="String">auto-format</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">autoformat</span><span class="Ignore">*</span>

如果 <span class="Type">'formatoptions'</span> 里包含 'a' 标志位，在插入或者删除文本时会自动进行排版。这
对编辑文本段落很好用。以下对如何使用这一功能提供一些提示:

- 你需要正确定义何谓段落。最简单的方式是以空行分隔的为段落。如果没有分隔的空
  行，考虑用 'w' 标志位并在段落中除了最后一行以外，每行结尾加上一个空格。

- 你可以根据文件类型 <span class="Ignore">|</span><span class="Identifier">filetype</span><span class="Ignore">|</span>， 或者用 <span class="Ignore">|</span><span class="Identifier">modeline</span><span class="Ignore">|</span> 指定特定文件的方式，设置不
  同的 <span class="Type">'formatoptions'</span>。

- 将 <span class="Type">'formatoptions'</span> 设为 &quot;aw2tq&quot; 使得文本以如下方式缩进:

	    bla bla foobar bla
	bla foobar bla foobar bla
	    bla bla foobar bla
	bla foobar bla bla foobar

- 如果只想自动排版注释，加上 'c' 标志位。可用于源代码。

- 设置 <span class="Type">'textwidth'</span> 为你希望的宽度。如果为零，使用 79 或屏幕宽度中较小的那个。

还有一些警告:

- 如果段落没有正确分隔，任何改变都会使得所有相连的文本自动排版。考虑<span class="Ignore"> &gt;</span>

<span class="Comment">	:set fo-=a</span>

- 如果用 'w' 标志位 (行尾的空格意味着段落的继续) 并且用 <span class="Ignore">|</span><span class="Identifier">dd</span><span class="Ignore">|</span> 删除了段落的末
  行，这段落自动和下一个段落合并为一个段落。

- 改变的文本被保存以备可能的撤销之用。排版也是改变的一种。所以每次排版都会为撤
  销保存文本。这会有相当的内存开销。

- 排版一个很长的段落和/或复杂的缩进也许会相当慢。

<span class="PreProc">==============================================================================</span>
7. 文本排序						<span class="Ignore">*</span><span class="String">sorting</span><span class="Ignore">*</span>

Vim 有排序函数和排序命令。排序函数可见: <span class="Ignore">|</span><span class="Identifier">sort()</span><span class="Ignore">|</span>，<span class="Ignore">|</span><span class="Identifier">uniq()</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:sor</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sort</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>sor[t][!] [b][f][i][n][o][r][u][x] [/<span class="Special">{pattern}</span>/]
			给 <span class="Special">[range]</span> 里的行排序。如果没有给出行范围，给所有行排
			序。

			带 [!] 则反向排序。

			带 [i] 则忽略大小写。

			选项 [n][f][x][o][b] 互斥。

			带 [n] 则排序基于每行的第一个十进制数 (在 <span class="Special">{pattern}</span> 匹
			配之后或之内)。
			数值包含前导的 '-'。

			带 [f] 则排序基于每行内的浮点数。浮点值相当于在文本
			(<span class="Special">{pattern}</span> 匹配的之后或之内) 上调用 str2float() 函数的
			结果。仅当 Vim 编译时加入浮点数支持时该标志位才有效。

			带 [x] 则排序基于每行的第一个十六进制数 (在 <span class="Special">{pattern}</span>
			匹配之后或之内)。忽略引导的 &quot;0x&quot; 或 &quot;0X&quot;。
			数值包含前导的 '-'。

			带 [o] 则排序基于每行的第一个八进制数 (在 <span class="Special">{pattern}</span> 匹
			配之后或之内)。

			带 [b] 则排序基于每行的第一个二进制数 (在 <span class="Special">{pattern}</span> 匹
			配之后或之内)。

			带 [u] (u 代表 unique 唯一) 则只保留完全相同的行的第一
			行 (如果带 [i]，忽略大小写的区别)。
			没有这个标志位，完全相同的行的序列会按照它们原来的顺序
			被保留下来。
			注意 引导和拖尾的空白差异会导致不相同的行。

			如果指定 /<span class="Special">{pattern}</span>/ 并且没有 [r] 标志位，跳过匹配
			<span class="Special">{pattern}</span> 的文本，使得排序在匹配之后的内容上进行。
			除了斜杠以外，任何非字母的字符都可以。
			例如，要按第二个逗号分隔的字段排序:<span class="Ignore"> &gt;</span>
<span class="Comment">				:sort /[^,]*,/</span>
<span class="Ignore">&lt;</span>			按虚拟第 10 列的文本排序 (从而忽略制表和空格的区别):<span class="Ignore"> &gt;</span>
<span class="Comment">				:sort /.*\%10v/</span>
<span class="Ignore">&lt;</span>			按每行的第一个数值排序，不管它前面有什么:<span class="Ignore"> &gt;</span>
<span class="Comment">				:sort /.\{-}\ze\d/</span>
<span class="Ignore">&lt;</span>			(说明: &quot;.\<span class="Special">{-}</span>&quot; 匹配任何文本，&quot;\ze&quot; 设置匹配结束位置，
			\d 匹配单个数位。)
			带 [r] 则排序在匹配 <span class="Special">{pattern}</span> 的文本上进行，而不是如上
			所述的用它之后的文本。
			例如，要按每行的前三个字母排序且只看这三个字母:<span class="Ignore"> &gt;</span>
<span class="Comment">				:sort /\a\a\a/ r</span>

<span class="Ignore">&lt;</span>			如果使用 <span class="Special">{pattern}</span>，不匹配 <span class="Special">{pattern}</span> 的行按照它们原来
			的顺序被保留，但和匹配 <span class="Special">{pattern}</span> 的行分开。如果反向排
			序，它们会以反向顺序出现，并在排序好的行之后。否则它们
			会以原有顺序出现，在排序好的行之前。

			如果 <span class="Special">{pattern}</span> 为空 (例如指定 //)，则使用最近使用的搜
			索模式。这样你可以先试好模式，然后在执行。

注意 <span class="Ignore">`</span><span class="Comment">:sort</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:global</span><span class="Ignore">`</span> 一起使用并不能对匹配的行进行排序，这样做没有意义。

排序的细节取决于使用的库函数。不能保证排序依赖于当前的 locale。你要自己试试才
知道。Vim 保证 &quot;稳定&quot; 排序。

排序可以被中断，但在整个过程里如果中断得太晚，最后可能会出现重复的行。这取决于
使用的系统库函数。

 vim&#0058;tw=78:ts=8:ft=help:norl:
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
