<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>vim中文手册 - map</title>
    <meta name="description" content="vim8.0 中文帮助文档">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="vim.css" type="text/css">
</head>
<body>
    <div class="page-content">
        <article class="wrap">
            <pre class="pre">
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span id="map.txt" class="String anchor">map.txt</span><span class="Ignore">*</span>	For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年8月

		  VIM 参考手册    by Bram Moolenaar
		  		  译者:  con&lt;con@netease.com&gt;
				  <span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>

键映射、缩写和用户定义的命令。

本主题在用户手册 <span class="Ignore">|</span><a href="usr_05.html#05.3"><span class="Identifier">05.3</span></a><span class="Ignore">|</span>，<span class="Ignore">|</span><a href="usr_24.html#24.7"><span class="Identifier">24.7</span></a><span class="Ignore">|</span> 和 <span class="Ignore">|</span><a href="usr_40.html#40.1"><span class="Identifier">40.1</span></a><span class="Ignore">|</span> 中有过介绍。

1. 键映射			<span class="Ignore">|</span><a href="map.html#key-mapping"><span class="Identifier">key-mapping</span></a><span class="Ignore">|</span>
   1.1 映 射 命 令			<span class="Ignore">|</span><span class="Identifier">:map-commands</span><span class="Ignore">|</span>
   1.2 特殊参数				<span class="Ignore">|</span><span class="Identifier">:map-arguments</span><span class="Ignore">|</span>
   1.3 映射与运行模式			<span class="Ignore">|</span><span class="Identifier">:map-modes</span><span class="Ignore">|</span>
   1.4 列出映射				<span class="Ignore">|</span><a href="map.html#map-listing"><span class="Identifier">map-listing</span></a><span class="Ignore">|</span>
   1.5 映射特殊键			<span class="Ignore">|</span><span class="Identifier">:map-special-keys</span><span class="Ignore">|</span>
   1.6 特殊字符				<span class="Ignore">|</span><span class="Identifier">:map-special-chars</span><span class="Ignore">|</span>
   1.7 映射哪些键			<span class="Ignore">|</span><a href="map.html#map-which-keys"><span class="Identifier">map-which-keys</span></a><span class="Ignore">|</span>
   1.8 示例				<span class="Ignore">|</span><a href="map.html#map-examples"><span class="Identifier">map-examples</span></a><span class="Ignore">|</span>
   1.9 使用映射				<span class="Ignore">|</span><a href="map.html#map-typing"><span class="Identifier">map-typing</span></a><span class="Ignore">|</span>
   1.10 映射 ALT 键			<span class="Ignore">|</span><span class="Identifier">:map-alt-keys</span><span class="Ignore">|</span>
   1.11 映射操作符			<span class="Ignore">|</span><span class="Identifier">:map-operator</span><span class="Ignore">|</span>
2. 缩写				<span class="Ignore">|</span><a href="map.html#abbreviations"><span class="Identifier">abbreviations</span></a><span class="Ignore">|</span>
3. 局部映射和函数		<span class="Ignore">|</span><a href="map.html#script-local"><span class="Identifier">script-local</span></a><span class="Ignore">|</span>
4. 用户定义的命令		<span class="Ignore">|</span><a href="map.html#user-commands"><span class="Identifier">user-commands</span></a><span class="Ignore">|</span>

<span class="PreProc">==============================================================================</span>
1. 键映射				<span class="Ignore">*</span><span id="key-mapping" class="String anchor">key-mapping</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapping" class="String anchor">mapping</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="macro" class="String anchor">macro</span><span class="Ignore">*</span>

键映射用于改变输入键的含义。最常见的用途是把功能键定义为一系列的命令。比如:<span class="Ignore"> &gt;</span>

<span class="Comment">	:map &lt;F2&gt; a&lt;C-R&gt;=strftime(&quot;%c&quot;)&lt;CR&gt;&lt;Esc&gt;</span>

这个映射会在光标之后追加当前的日期和时间 (用 &lt;&gt; 记法 <span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span>)。

1.1 映 射 命 令						<span class="Ignore">*</span><span class="String">:map-commands</span><span class="Ignore">*</span>

有很多命令用于定义新的映射，删除映射和列出当前的映射。可以从 <span class="Ignore">|</span><a href="map.html#map-overview"><span class="Identifier">map-overview</span></a><span class="Ignore">|</span> 参
考 &quot;映射&quot; 命令的不同形式及其与模式的关系。

<span class="Special">{lhs}</span>	表示左手边	<span class="Ignore">*</span><span class="String">{lhs}</span><span class="Ignore">*</span>
<span class="Special">{rhs}</span>	表示右手边	<span class="Ignore">*</span><span class="String">{rhs}</span><span class="Ignore">*</span>

:map	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-nvo"><span class="Identifier">mapmode-nvo</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:map</span><span class="Ignore">*</span>
:nm[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-n"><span class="Identifier">mapmode-n</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:nm</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:nmap</span><span class="Ignore">*</span>
:vm[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-v"><span class="Identifier">mapmode-v</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:vm</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:vmap</span><span class="Ignore">*</span>
:xm[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-x"><span class="Identifier">mapmode-x</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:xm</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:xmap</span><span class="Ignore">*</span>
:smap	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-s"><span class="Identifier">mapmode-s</span></a><span class="Ignore">|</span>		    <span class="Ignore">*</span><span class="String">:smap</span><span class="Ignore">*</span>
:om[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-o"><span class="Identifier">mapmode-o</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:om</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:omap</span><span class="Ignore">*</span>
:map!	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-ic"><span class="Identifier">mapmode-ic</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:map!</span><span class="Ignore">*</span>
:im[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-i"><span class="Identifier">mapmode-i</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:im</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:imap</span><span class="Ignore">*</span>
:lm[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-l"><span class="Identifier">mapmode-l</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:lm</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lmap</span><span class="Ignore">*</span>
:cm[ap]	<span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-c"><span class="Identifier">mapmode-c</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:cm</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cmap</span><span class="Ignore">*</span>
			在映射命令作用的模式中把键系列 <span class="Special">{lhs}</span> 映射为 <span class="Special">{rhs}</span>。并
			且映射后的 <span class="Special">{rhs}</span> 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

						<span class="Ignore">*</span><span class="String">:nore</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:norem</span><span class="Ignore">*</span>
:no[remap]  <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-nvo"><span class="Identifier">mapmode-nvo</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:no</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:noremap</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:nor</span><span class="Ignore">*</span>
:nn[oremap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-n"><span class="Identifier">mapmode-n</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:nn</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:nnoremap</span><span class="Ignore">*</span>
:vn[oremap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-v"><span class="Identifier">mapmode-v</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:vn</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:vnoremap</span><span class="Ignore">*</span>
:xn[oremap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-x"><span class="Identifier">mapmode-x</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:xn</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:xnoremap</span><span class="Ignore">*</span>
:snor[emap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-s"><span class="Identifier">mapmode-s</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:snor</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:snoremap</span><span class="Ignore">*</span>
:ono[remap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-o"><span class="Identifier">mapmode-o</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:ono</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:onoremap</span><span class="Ignore">*</span>
:no[remap]! <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-ic"><span class="Identifier">mapmode-ic</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:no!</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:noremap!</span><span class="Ignore">*</span>
:ino[remap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-i"><span class="Identifier">mapmode-i</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:ino</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:inoremap</span><span class="Ignore">*</span>
:ln[oremap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-l"><span class="Identifier">mapmode-l</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:ln</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:lnoremap</span><span class="Ignore">*</span>
:cno[remap] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>		<span class="Ignore">|</span><a href="map.html#mapmode-c"><span class="Identifier">mapmode-c</span></a><span class="Ignore">|</span>	<span class="Ignore">*</span><span class="String">:cno</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cnoremap</span><span class="Ignore">*</span>
			在映射命令作用的模式中把键序列 <span class="Special">{lhs}</span> 映射为 <span class="Special">{rhs}</span> 。禁
			止对映射后的 <span class="Special">{rhs}</span> 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。<span class="Special">{Vi 无此功能}</span>

:unm[ap]  <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-nvo"><span class="Identifier">mapmode-nvo</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:unm</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:unmap</span><span class="Ignore">*</span>
:nun[map] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-n"><span class="Identifier">mapmode-n</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:nun</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:nunmap</span><span class="Ignore">*</span>
:vu[nmap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-v"><span class="Identifier">mapmode-v</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:vu</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:vunmap</span><span class="Ignore">*</span>
:xu[nmap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-x"><span class="Identifier">mapmode-x</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:xu</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:xunmap</span><span class="Ignore">*</span>
:sunm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-s"><span class="Identifier">mapmode-s</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:sunm</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:sunmap</span><span class="Ignore">*</span>
:ou[nmap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-o"><span class="Identifier">mapmode-o</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:ou</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:ounmap</span><span class="Ignore">*</span>
:unm[ap]! <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-ic"><span class="Identifier">mapmode-ic</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:unm!</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:unmap!</span><span class="Ignore">*</span>
:iu[nmap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-i"><span class="Identifier">mapmode-i</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:iu</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:iunmap</span><span class="Ignore">*</span>
:lu[nmap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-l"><span class="Identifier">mapmode-l</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:lu</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:lunmap</span><span class="Ignore">*</span>
:cu[nmap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-c"><span class="Identifier">mapmode-c</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:cu</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:cunmap</span><span class="Ignore">*</span>
			在映射命令作用的模式中删除 <span class="Special">{lhs}</span> 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: <span class="Special">{lhs}</span> 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

:mapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-nvo"><span class="Identifier">mapmode-nvo</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:mapc</span><span class="Ignore">*</span>   <span class="Ignore">*</span><span class="String">:mapclear</span><span class="Ignore">*</span>
:nmapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-n"><span class="Identifier">mapmode-n</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:nmapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:nmapclear</span><span class="Ignore">*</span>
:vmapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-v"><span class="Identifier">mapmode-v</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:vmapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:vmapclear</span><span class="Ignore">*</span>
:xmapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-x"><span class="Identifier">mapmode-x</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:xmapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:xmapclear</span><span class="Ignore">*</span>
:smapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-s"><span class="Identifier">mapmode-s</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:smapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:smapclear</span><span class="Ignore">*</span>
:omapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-o"><span class="Identifier">mapmode-o</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:omapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:omapclear</span><span class="Ignore">*</span>
:mapc[lear]!			<span class="Ignore">|</span><a href="map.html#mapmode-ic"><span class="Identifier">mapmode-ic</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:mapc!</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:mapclear!</span><span class="Ignore">*</span>
:imapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-i"><span class="Identifier">mapmode-i</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:imapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:imapclear</span><span class="Ignore">*</span>
:lmapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-l"><span class="Identifier">mapmode-l</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:lmapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:lmapclear</span><span class="Ignore">*</span>
:cmapc[lear]			<span class="Ignore">|</span><a href="map.html#mapmode-c"><span class="Identifier">mapmode-c</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:cmapc</span><span class="Ignore">*</span>  <span class="Ignore">*</span><span class="String">:cmapclear</span><span class="Ignore">*</span>
			在映射命令作用的模式中删除_所有_的映射。<span class="Special">{Vi 无此功能}</span>
			<span class="Special">&lt;buffer&gt;</span> 参数可用来删除所的有缓冲区局部映射
			<span class="Ignore">|</span><span class="Identifier">:map-&lt;buffer&gt;</span><span class="Ignore">|</span>
			警告: 同时也会删除缺省的映射。

:map				<span class="Ignore">|</span><a href="map.html#mapmode-nvo"><span class="Identifier">mapmode-nvo</span></a><span class="Ignore">|</span>
:nm[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-n"><span class="Identifier">mapmode-n</span></a><span class="Ignore">|</span>
:vm[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-v"><span class="Identifier">mapmode-v</span></a><span class="Ignore">|</span>
:xm[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-x"><span class="Identifier">mapmode-x</span></a><span class="Ignore">|</span>
:sm[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-s"><span class="Identifier">mapmode-s</span></a><span class="Ignore">|</span>
:om[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-o"><span class="Identifier">mapmode-o</span></a><span class="Ignore">|</span>
:map!				<span class="Ignore">|</span><a href="map.html#mapmode-ic"><span class="Identifier">mapmode-ic</span></a><span class="Ignore">|</span>
:im[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-i"><span class="Identifier">mapmode-i</span></a><span class="Ignore">|</span>
:lm[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-l"><span class="Identifier">mapmode-l</span></a><span class="Ignore">|</span>
:cm[ap]				<span class="Ignore">|</span><a href="map.html#mapmode-c"><span class="Identifier">mapmode-c</span></a><span class="Ignore">|</span>
			在映射命令作用的模式中列出所有的键映射。注意 &quot;:map&quot; 和
			&quot;:map!&quot; 是最常用的，因为它们包括其它模式。

:map    <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-nvo"><span class="Identifier">mapmode-nvo</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:map_l</span><span class="Ignore">*</span>
:nm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-n"><span class="Identifier">mapmode-n</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:nmap_l</span><span class="Ignore">*</span>
:vm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-v"><span class="Identifier">mapmode-v</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:vmap_l</span><span class="Ignore">*</span>
:xm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-x"><span class="Identifier">mapmode-x</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:xmap_l</span><span class="Ignore">*</span>
:sm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-s"><span class="Identifier">mapmode-s</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:smap_l</span><span class="Ignore">*</span>
:om[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-o"><span class="Identifier">mapmode-o</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:omap_l</span><span class="Ignore">*</span>
:map!   <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-ic"><span class="Identifier">mapmode-ic</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:map_l!</span><span class="Ignore">*</span>
:im[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-i"><span class="Identifier">mapmode-i</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:imap_l</span><span class="Ignore">*</span>
:lm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-l"><span class="Identifier">mapmode-l</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:lmap_l</span><span class="Ignore">*</span>
:cm[ap] <span class="Special">{lhs}</span>			<span class="Ignore">|</span><a href="map.html#mapmode-c"><span class="Identifier">mapmode-c</span></a><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">:cmap_l</span><span class="Ignore">*</span>
			在映射命令作用的模式中列出以 <span class="Special">{lhs}</span> 开头的键映射的键系
			列。 <span class="Special">{Vi 无此功能}</span>

这些命令用于把一个键或键系列映射成一个字符串。可以用来在功能键里放置一系列命
令，把一个键转换成另一个，等等。如何保存和恢复当前映射可以参考 <span class="Ignore">|</span><span class="Identifier">:mkexrc</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span id="map-ambiguous" class="String anchor">map-ambiguous</span><span class="Ignore">*</span>
当两个映射以相同的字符顺序开始，它们是有二义性的。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:imap aa foo</span>
<span class="Comment">	:imap aaa bar</span>
当 Vim 读入 &quot;aa&quot; 后，它需要取得另外一个字符才能决定应该映射 &quot;aa&quot; 还是 &quot;aaa&quot;。
这意味着输入 &quot;aa&quot; 后映射还不会展开，Vim 还在等待另一个字符。如果你接着输入一个
空格，那么将插入 &quot;foo&quot; 加上空格。如果你输入一个 &quot;a&quot;，那么将插入 &quot;bar&quot;。
<span class="Special">{Vi 不允许有二义性的映射}</span>

1.2 特 殊 参 数						<span class="Ignore">*</span><span class="String">:map-arguments</span><span class="Ignore">*</span>

&quot;<span class="Special">&lt;buffer&gt;</span>&quot;，&quot;<span class="Special">&lt;nowait&gt;</span>&quot;，&quot;<span class="Special">&lt;silent&gt;</span>&quot;，&quot;<span class="Special">&lt;special&gt;</span>&quot;、&quot;<span class="Special">&lt;script&gt;</span>&quot;、&quot;<span class="Special">&lt;expr&gt;</span>&quot; 和
&quot;<span class="Special">&lt;unique&gt;</span>&quot; 可以按任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前
边。

				<span class="Ignore">*</span><span class="String">:map-local</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:map-&lt;buffer&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E224" class="String anchor">E224</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E225" class="String anchor">E225</span><span class="Ignore">*</span>
如果这些命令的第一个参数是 &quot;<span class="Special">&lt;buffer&gt;</span>&quot;，映射将只局限于当前的缓冲区内。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;buffer&gt;  ,w  /[.,;]&lt;CR&gt;</span>
然后你可以在另一个缓冲区内把 &quot;,w&quot; 作另外的映射:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;buffer&gt;  ,w  /[#&amp;!]&lt;CR&gt;</span>
局部缓冲区映射在全局映射之前被应用。下面介绍的 <span class="Special">&lt;nowait&gt;</span> 可以使一个较短的局部
映射在较长的全局映射存在时不起作用 (译者注: 此处或有误)。
&quot;<span class="Special">&lt;buffer&gt;</span>&quot; 参数也可以用于清除映射:<span class="Ignore"> &gt;</span>
<span class="Comment">	:unmap &lt;buffer&gt; ,w</span>
<span class="Comment">	:mapclear &lt;buffer&gt;</span>
当一个缓冲区被删除时局部映射也会被清除，但是在它被卸载时不会。就象局部选项值的
情况一样。
另见 <span class="Ignore">|</span><a href="map.html#map-precedence"><span class="Identifier">map-precedence</span></a><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">:map-&lt;nowait&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:map-nowait</span><span class="Ignore">*</span>
定义局部于缓冲区的映射 &quot;,&quot; 时，可能有另一个全局映射也以 &quot;,&quot; 开始。这时你需要
键入另一个字符，Vim 才能知道是用 ”,&quot; 映射还是更长的那个。要避免这个问题，加入
<span class="Special">&lt;nowait&gt;</span> 参数。这样映射一旦匹配就会被使用，Vim 不会等待更多字符的输入。但如果
那些字符已经输入了，还是会使用的。

						<span class="Ignore">*</span><span class="String">:map-&lt;silent&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:map-silent</span><span class="Ignore">*</span>
要在定义一个映射时不在命令行上回显该映射，可以使用 &quot;<span class="Special">&lt;silent&gt;</span>&quot; 作为第一个参数，
例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;silent&gt; ,h /Header&lt;CR&gt;</span>
在使用这个映射时搜索字串将不回显。不过被执行命令的信息仍然会。要把它也关掉，可
以在执行的命令里加入一个 &quot;:silent&quot;:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;silent&gt; ,h :exe &quot;:silent normal /Header\r&quot;&lt;CR&gt;</span>
仍然会给出提示，比如使用 inputdialog() 的时候。
在缩写上使用 &quot;<span class="Special">&lt;silent&gt;</span>&quot; 是可以的，但它的作用是使命令行不进行重绘。

						<span class="Ignore">*</span><span class="String">:map-&lt;special&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:map-special</span><span class="Ignore">*</span>
定义映射时，特殊键可用 &lt;&gt; 记法，即使 <span class="Type">'cpoptions'</span> 包含了 &quot;&lt;&quot; 标志位也没问题。这
可用于不希望看到设置 <span class="Type">'cpoptions'</span> 时出现的副作用的场合。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;special&gt; &lt;F12&gt; /Header&lt;CR&gt;</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span class="String">:map-&lt;script&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:map-script</span><span class="Ignore">*</span>
如果给用于定义新映射或缩写的命令的第一个参数是 &quot;<span class="Special">&lt;script&gt;</span>&quot;，该映射只使用通过以
&quot;<span class="Special">&lt;SID&gt;</span>&quot; 开头来定义的的脚本局部映射来重映射 <span class="Special">{rhs}</span> 中的字符。这可以用于避免来自
外部的脚本的干扰 (举例来说，在 mswin.vim 中 <span class="Special">CTRL-V</span> 被重新映射的时候就是如此)，
但是又需要使用该脚本中定义的其它映射的情形。
备注: &quot;:map <span class="Special">&lt;script&gt;</span>&quot; 和 &quot;:noremap <span class="Special">&lt;script&gt;</span>&quot; 做同样的事情。这里 &quot;<span class="Special">&lt;script&gt;</span>&quot; 超
越命令名。不过，更推荐使用 &quot;:noremap <span class="Special">&lt;script&gt;</span>&quot;，因为它更清晰地表示了重映射已被
(大多数时候) 禁止。

						<span class="Ignore">*</span><span class="String">:map-&lt;unique&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E226" class="String anchor">E226</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E227" class="String anchor">E227</span><span class="Ignore">*</span>
如果给用于定义新映射或缩写的命令的第一个参数是 &quot;<span class="Special">&lt;unique&gt;</span>&quot; 并且它该映射或缩写已
经存在，则该命令会失败。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;unique&gt; ,w  /[#&amp;!]&lt;CR&gt;</span>
定义一个局部映射时，同时也会检查是否已存在了一个相同的全局映射。
这个例子将失败:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map ,w  /[#&amp;!]&lt;CR&gt;</span>
<span class="Comment">	:map &lt;buffer&gt; &lt;unique&gt; ,w  /[.,;]&lt;CR&gt;</span>
如果你想给键进行映射，但同时又想执行原来映射的内容，参见 <span class="Ignore">|</span><a href="#"><span class="Identifier">maparg()</span></a><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">:map-&lt;expr&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:map-expression</span><span class="Ignore">*</span>
如果给用于定义新映射或缩写的命令的第一个参数是 &quot;<span class="Special">&lt;expr&gt;</span>&quot;，那么参数会作为表达式
来进行计算，结果作为实际使用的 <span class="Special">{rhs}</span>。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:inoremap &lt;expr&gt; . InsertDot()</span>
会插入 InsertDot() 函数的返回值。这可以用来检查光标之前的文本并在一定条件下启
动全能 (omni) 补全。

对于缩写，<span class="Ignore">|</span><a href="#"><span class="Identifier">v:char</span></a><span class="Ignore">|</span> 设为激活缩写的那个输入字符。你可以用它来决定如何扩展
<span class="Special">{lhs}</span>。不能修改或插入 v:char。

要非常小心副作用！计算表达式的同时正在获取字符，因此很有可能你使得该命令不再可
用。为此原因禁止以下行为:
- 改变缓冲区文本 <span class="Ignore">|</span><a href="eval.html#textlock"><span class="Identifier">textlock</span></a><span class="Ignore">|</span>
- 编辑其它缓冲区
- <span class="Ignore">|</span><span class="Identifier">:normal</span><span class="Ignore">|</span> 命令
- 可以移动光标，但事后光标会被恢复
如果你希望通过映射来完成这些操作，让返回的字符做这些事情。

你可以使用 getchar()，丢弃可能有的预输入。例如，如果有以下的映射:<span class="Ignore"> &gt;</span>
<span class="Comment">  inoremap &lt;expr&gt; &lt;C-L&gt; nr2char(getchar())</span>
<span class="Comment">  inoremap &lt;expr&gt; &lt;C-L&gt;x &quot;foo&quot;</span>
此时你如果输入 <span class="Special">CTRL-L</span>，什么都不会发生。Vim 需要下一个字符来决定采用哪个映射。
如果键入 'x'，采用第二个映射，插入 &quot;foo&quot;。如果键入其他字符，采用第一个映射，
getchar() 得到键入的字符并返回之。

这里是插入递增的列表编号的例子:<span class="Ignore"> &gt;</span>
<span class="Comment">	let counter = 0</span>
<span class="Comment">	inoremap &lt;expr&gt; &lt;C-L&gt; ListItem()</span>
<span class="Comment">	inoremap &lt;expr&gt; &lt;C-R&gt; ListReset()</span>

<span class="Comment">	func ListItem()</span>
<span class="Comment">	  let g:counter += 1</span>
<span class="Comment">	  return g:counter . '. '</span>
<span class="Comment">	endfunc</span>

<span class="Comment">	func ListReset()</span>
<span class="Comment">	  let g:counter = 0</span>
<span class="Comment">	  return ''</span>
<span class="Comment">	endfunc</span>

<span class="Special">CTRL-L</span> 插入下一个数值，<span class="Special">CTRL-R</span> 复位计数且返回空字符串，这样就不会插入任何内容。

注意 要使特殊键工作并转义文本中的 CSI 字节需要一些特殊处理。<span class="Ignore">|</span><span class="Identifier">:map</span><span class="Ignore">|</span> 命令已经做
好了，所以你应该避免做重复的操作。这样不行:<span class="Ignore"> &gt;</span>
<span class="Comment">	:imap &lt;expr&gt; &lt;F3&gt; &quot;&lt;Char-0x611B&gt;&quot;</span>
因为 &lt;Char- 序列作为 <span class="Ignore">|</span><span class="Identifier">:imap</span><span class="Ignore">|</span> 的参数被转义，而 <span class="Special">&lt;expr&gt;</span> 又做一次。这样就可以:<span class="Ignore"> &gt;</span>
<span class="Comment">	:imap &lt;expr&gt; &lt;F3&gt; &quot;\u611B&quot;</span>
在其它文本之前使用单个字节出现的 0x80 是不行的。它会被看作一个特殊键。

1.3 映 射 与 运 行 模 式				<span class="Ignore">*</span><span class="String">:map-modes</span><span class="Ignore">*</span>
			<span class="Ignore">*</span><span id="mapmode-nvo" class="String anchor">mapmode-nvo</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-n" class="String anchor">mapmode-n</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-v" class="String anchor">mapmode-v</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-o" class="String anchor">mapmode-o</span><span class="Ignore">*</span>

有六种映射存在
- 用于普通模式: 输入命令时。
- 用于可视模式: 可视区域高亮并输入命令时。
- 用于选择模式: 类似于可视模式，但键入的字符对选择区进行替换。
- 用于操作符等待模式: 操作符等待中 (&quot;d&quot;，&quot;y&quot;，&quot;c&quot; 等等之后)。
  见下: <span class="Ignore">|</span><a href="map.html#omap-info"><span class="Identifier">omap-info</span></a><span class="Ignore">|</span>。
- 用于插入模式: 也用于替换模式。
- 用于命令行模式: 输入 &quot;:&quot; 或 &quot;/&quot; 命令时。

特殊情况: 当在普通模式里为一个命令输入一个计数时，对 0 的映射会被禁用。这样在
输入一个带有 0 的计数时不会受到对 0 键映射的干扰。

						<span class="Ignore">*</span><span id="map-overview" class="String anchor">map-overview</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-modes" class="String anchor">map-modes</span><span class="Ignore">*</span>
关于每个映射命令对应的工作模式的概况。详情见下。
     <span class="PreProc">命 令			 模 式</span><span class="Ignore"> ~</span>
:map   :noremap  :unmap     普通、可视、选择、操作符等待
:nmap  :nnoremap :nunmap    普通
:vmap  :vnoremap :vunmap    可视与选择
:smap  :snoremap :sunmap    选择
:xmap  :xnoremap :xunmap    可视
:omap  :onoremap :ounmap    操作符等待
:map!  :noremap! :unmap!    插入与命令行
:imap  :inoremap :iunmap    插入
:lmap  :lnoremap :lunmap    插入、命令行、Lang-Arg
:cmap  :cnoremap :cunmap    命令行

    <span class="PreProc">命 令				      模 式</span><span class="Ignore"> ~</span>
					<span class="PreProc">普通	可视+选择	操作符等待</span><span class="Ignore"> ~</span>
:map   :noremap   :unmap   :mapclear	是	是		是
:nmap  :nnoremap  :nunmap  :nmapclear	是	-		-
:vmap  :vnoremap  :vunmap  :vmapclear	-	是		-
:omap  :onoremap  :ounmap  :omapclear	-	-		是

修道院之外也有 :nunmap (译者注: nun，修女)。
						<span class="Ignore">*</span><span id="mapmode-x" class="String anchor">mapmode-x</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-s" class="String anchor">mapmode-s</span><span class="Ignore">*</span>
有的命令能同时用于可视和选择模式，有的只能用于其中一个。注意 很常见的情况是提
到 &quot;可视&quot; 的时候实际同时适用可视和选择两种模式。<span class="Ignore">|</span><a href="visual.html#Select-mode-mapping"><span class="Identifier">Select-mode-mapping</span></a><span class="Ignore">|</span>
备注: 在选择模式映射可显示字符容易引起用户的混淆。最好直接用 :xmap 和 :smap 来
映射可显示字符。或者在定义映射后使用 :sunmap。

    <span class="PreProc">命 令				      模 式</span><span class="Ignore"> ~</span>
					<span class="PreProc">可视	选择</span><span class="Ignore"> ~</span>
:vmap  :vnoremap  :vunmap  :vmapclear	是	是
:xmap  :xnoremap  :xunmap  :xmapclear	是	-
:smap  :snoremap  :sunmap  :smapclear	-	是

			<span class="Ignore">*</span><span id="mapmode-ic" class="String anchor">mapmode-ic</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-i" class="String anchor">mapmode-i</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-c" class="String anchor">mapmode-c</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapmode-l" class="String anchor">mapmode-l</span><span class="Ignore">*</span>
有的命令同时支持插入模式和命令行模式，有的不是:

    <span class="PreProc">命 令				      模 式</span><span class="Ignore"> ~</span>
					<span class="PreProc">插入	命令行	Lang-Arg</span><span class="Ignore"> ~</span>
:map!  :noremap!  :unmap!  :mapclear!	是	是	-
:imap  :inoremap  :iunmap  :imapclear	是	-	-
:cmap  :cnoremap  :cunmap  :cmapclear	-	是	-
:lmap  :lnoremap  :lunmap  :lmapclear	是*	是*	是*

原来的 Vi 没有针对普通/可视/操作符等待模式和针对插入/命令行模式的独立映射。因
此 &quot;:map&quot; 和 &quot;:map!&quot; 命令为多个模式定义和回显映射。在 Vim 中你可以使用
&quot;:nmap&quot;、&quot;:vmap&quot;、:omap&quot;、&quot;:cmap&quot; 和 &quot;:imap&quot; 命令来对每个不同的模式分别定义映
射。

							<span class="Ignore">*</span><span id="omap-info" class="String anchor">omap-info</span><span class="Ignore">*</span>
操作符等待映射可以用来定义和任何操作符一起使用的移动命令。简单例子:
&quot;:omap { w&quot; 会使 &quot;y{&quot; 等同于 &quot;yw&quot;，&quot;d{&quot; 也等同于 &quot;dw&quot;。

要忽略光标原来所在的位置并选择另外的文本，你可以使 omap 进入可视模式来选择要操
作的文本。例如，要在位于当前行的函数名上操作:<span class="Ignore"> &gt;</span>
<span class="Comment">	onoremap &lt;silent&gt; F :&lt;C-U&gt;normal! 0f(hviw&lt;CR&gt;</span>
<span class="Special">CTRL-U</span> (<span class="Special">&lt;C-U&gt;</span>) 用于删除命令行上 Vim 可能插入的范围。普通模式命令寻找第一个 '('
字符并选择之前的第一个单词。通常那就是函数名了。

要为普通和可视模式但不包括操作符等待模式输入一个映射，首先在所有的三个模式中定
义该映射，然后在操作符等待模式中取消该映射:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map    xx something-difficult</span>
<span class="Comment">	:ounmap xx</span>
对于一个同时用于可视和操作符等待模式、或同时用于普通和操作符等待模式的映射也可
照此办理。

						<span class="Ignore">*</span><span id="language-mapping" class="String anchor">language-mapping</span><span class="Ignore">*</span>
&quot;:lmap&quot; 定义一个应用于以下情况的映射:
- 插入模式
- 命令行模式
- 输入一个搜索模式时
- 接受一个文本字符作为参数的命令，比如 &quot;r&quot; 和 &quot;f&quot;
- 对于 input() 行
更一般地: 任何输入的字符是缓冲区文本的一部分而非一个 Vim 命令字符的时候。
&quot;Lang-Arg&quot; 不是真正的另外一个模式，它仅用来表示这些情况的存在。
   载入一个相关语言映射集合的最简单的方法是通过使用 <span class="Type">'keymap'</span> 选项。
参考 <span class="Ignore">|</span><a href="usr_45.html#45.5"><span class="Identifier">45.5</span></a><span class="Ignore">|</span>。
   在插入模式和命令行模式中可用 <span class="Special">CTRL-^</span> 命令来关闭映射 <span class="Ignore">|</span><a href="#"><span class="Identifier">i_CTRL-^</span></a><span class="Ignore">|</span> <span class="Ignore">|</span><a href="#"><span class="Identifier">c_CTRL-^</span></a><span class="Ignore">|</span>。
这些命令改变 <span class="Type">'iminsert'</span> 选项的值。普通命令行 (非模式搜索) 开始输入时，映射被关
闭直到输入 <span class="Special">CTRL-^</span> 为止。而插入模式和模式搜索却会分别记住上次使用的状态。需要输
入一个字符作为参数的命令，如 &quot;f&quot; 或 &quot;t&quot; 之类，也使用插入模式的状态。
   语言映射永远不能应用于已经映射的字符上。它们仅用于键入的字符上。这意味着输
入映射时，语言映射已经完成。

1.4 列 出 映 射						<span class="Ignore">*</span><span id="map-listing" class="String anchor">map-listing</span><span class="Ignore">*</span>

当列出映射时，前面两栏的字符表示 (可有多个):

      <span class="PreProc">字 符	模 式</span><span class="Ignore">	~</span>
     <span class="Special">&lt;Space&gt;</span>	普通、可视、选择和操作符等待
	n	普通
	v	可视和选择
	s	选择
	x	可视
	o	操作符等待
	!	插入和命令行
	i	插入
	l	插入、命令行和 Lang-Arg 模式的 &quot;:lmap&quot; 映射
	c	命令行

<span class="Special">{rhs}</span> 之前可能显示一个特殊字符:
	*	表示它不可重映射
	&amp;	表示仅脚本的局部映射可以被重映射
	@	表示缓冲区的局部映射

从 <span class="Special">{lhs}</span> 以后的第一个非空字符到行的末尾 (或 '|') 都被认为是 <span class="Special">{rhs}</span> 的一部分。这
允许 <span class="Special">{rhs}</span> 以一个空格结尾。

注意: 在可视模式里使用映射时，你可以使用 &quot;'&lt;&quot; 位置标记，它表示当前缓冲区中最后
被选中的可视区域的开始 <span class="Ignore">|</span><span class="Identifier">'&lt;</span><span class="Ignore">|</span>。

<span class="Ignore">|</span><span class="Identifier">:filter</span><span class="Ignore">|</span> 命令可用于选择列出哪种映射。模式匹配 <span class="Special">{lhs}</span> 和 <span class="Special">{rhs}</span> 原始文本。

							<span class="Ignore">*</span><span class="String">:map-verbose</span><span class="Ignore">*</span>
如果 <span class="Type">'verbose'</span> 非零，列出键映射的同时可以显示它在哪里定义。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">	:verbose map &lt;C-W&gt;*</span>
<span class="Comment">	n  &lt;C-W&gt;*      * &lt;C-W&gt;&lt;C-S&gt;*</span>
<span class="Comment">		Last set from /home/abcd/.vimrc</span>

<span class="Ignore">|</span><span class="Identifier">:verbose-cmd</span><span class="Ignore">|</span> 说明详情。

1.5 映 射 特 殊 键					<span class="Ignore">*</span><span class="String">:map-special-keys</span><span class="Ignore">*</span>

有三种方法来映射一个特殊键:
1. Vi 兼容的方法: 对键码进行映射。通常这是一个以 <span class="Special">&lt;Esc&gt;</span> 开头的序列。要输入一个
   这样的映射先输入 &quot;:map &quot; 然后再敲入功能键之前得先输入一个 <span class="Special">CTRL-V</span>。注意如果
   键码在 termcap (t_ 开头的选项) 里，它会被自动转换到内码并变成映射的第二种方
   法 (除非 <span class="Type">'cpoptions'</span> 里包括了 'k' 标志位)。
2. 第二种方法是使用功能键的内码。要输入这样的映射输入 <span class="Special">CTRL-K</span> 并敲要映射的功能
   键，或者使用 &quot;#1&quot;、&quot;#2&quot;、.. &quot;#9&quot;、&quot;#0&quot;、&quot;<span class="Special">&lt;Up&gt;</span>&quot;、&quot;<span class="Special">&lt;S-Down&gt;</span>&quot;、&quot;<span class="Special">&lt;S-F7&gt;</span>&quot; 等等的
   形式 (参考键表 <span class="Ignore">|</span><a href="intro.html#key-notation"><span class="Identifier">key-notation</span></a><span class="Ignore">|</span>，所有从 <span class="Special">&lt;Up&gt;</span> 开始的键都可以使用)。头十个功能
   键能以两种方式被定义: 仅用数字，比如 &quot;#2&quot;；或者使用 &quot;<span class="Special">&lt;F&gt;</span>&quot;，如 &quot;<span class="Special">&lt;F2&gt;</span>&quot;。两种
   都代表功能键 F2。&quot;#0&quot; 表示功能键 F10，由选项 't_f10' 定义，它在某些键盘上可
   能是 F0。&lt;&gt; 的形式在 <span class="Type">'cpoptions'</span> 包含 '&lt;' 标志位时不能使用。
3. 使用 termcap 条目，以 <span class="Special">&lt;t_xx&gt;</span> 的形式出现，这里 &quot;xx&quot; 是 termcap 条目的名字。
   可以使用任何字符串条目。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">     :map &lt;t_F3&gt; G</span>
<span class="Ignore">&lt;</span>  把功能键 13 映射成 &quot;G&quot;。<span class="Type">'cpoptions'</span> 包括 '&lt;' 标志位时不能使用这种方式。

第二种和第三种方法的优点是不加修改就可以在不同的终端上使用 (功能键会被转换成相
同的内码或实际的键码，不论使用何种终端都是如此。termcap 必须正确才能正常工作，
并且必须使用相同的映射)。

细 节: Vim 首先检查是否从键盘输入的序列是否已被映射。否的话将试图使用终端键码
(参考 <span class="Ignore">|</span><a href="term.html#terminal-options"><span class="Identifier">terminal-options</span></a><span class="Ignore">|</span>)。如果找到终端编码，它会被替换成内码。然后再次检查一
个映射是否已完成 (因此你也能把一个内码映射成其它东西)。在脚本文件中写入什么东
西取决于何者被识别。如果终端键码被识别为映射，写入键码本身；如果它被识别为一个
终端编码，则在脚本中写入内码。

1.6 特 殊 字 符						<span class="Ignore">*</span><span class="String">:map-special-chars</span><span class="Ignore">*</span>
						<span class="Ignore">*</span><span id="map_backslash" class="String anchor">map_backslash</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-backslash" class="String anchor">map-backslash</span><span class="Ignore">*</span>
注意这里仅提及 <span class="Special">CTRL-V</span> 可以作为用于映射和缩写的特殊字符。当 <span class="Type">'cpoptions'</span> 不包含
'B' 时，反斜杠也可起到 <span class="Special">CTRL-V</span> 一样的作用，这时可以完全地使用 &lt;&gt; 记法 <span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span>。但
你不能期望 &quot;<span class="Special">&lt;C-V&gt;</span>&quot; 像 <span class="Special">CTRL-V</span> 那样转换后来者的特殊含义。

要映射一个反斜杠，或者在 <span class="Special">{rhs}</span> 中使用一个字面意义的反斜杠，可以使用特殊字符序
列 &quot;<span class="Special">&lt;Bslash&gt;</span>&quot; 。这可以避免在使用嵌套映射时使用双反斜杠的需要。

						<span class="Ignore">*</span><span id="map_CTRL-C" class="String anchor">map_CTRL-C</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-CTRL-C" class="String anchor">map-CTRL-C</span><span class="Ignore">*</span>
<span class="Special">{lhs}</span> 里可以使用 <span class="Special">CTRL-C</span>，但只有在 Vim 等待输入键时才可以，Vim 忙着做别的事情的
时候不行。如果 Vim 在忙，<span class="Special">CTRL-C</span> 总是中断/打断该命令。
使用 MS-Windows 上的 GUI 版本时 <span class="Special">CTRL-C</span> 能被映射以允许复制到剪贴板的命令。使用
<span class="Special">CTRL-Break</span> 来中断 Vim。

					<span class="Ignore">*</span><span id="map_space_in_lhs" class="String anchor">map_space_in_lhs</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-space_in_lhs" class="String anchor">map-space_in_lhs</span><span class="Ignore">*</span>
要在 <span class="Special">{lhs}</span> 中包含一个空格，在前面输入一个 <span class="Special">CTRL-V</span> (每个空格之前实际要输入两个
<span class="Special">CTRL-V</span>)。
					<span class="Ignore">*</span><span id="map_space_in_rhs" class="String anchor">map_space_in_rhs</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-space_in_rhs" class="String anchor">map-space_in_rhs</span><span class="Ignore">*</span>
如果你需要 <span class="Special">{rhs}</span> 以空格开头，使用 &quot;<span class="Special">&lt;Space&gt;</span>&quot;。要与 Vi 完全兼容 (但不可读)，不要
使用 <span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span> 记法，在 <span class="Special">{rhs}</span> 前面先输入一个单独的 <span class="Special">CTRL-V</span> (你必须输入 <span class="Special">CTRL-V</span> 两
次)。
						<span class="Ignore">*</span><span id="map_empty_rhs" class="String anchor">map_empty_rhs</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-empty-rhs" class="String anchor">map-empty-rhs</span><span class="Ignore">*</span>
你可以通过在一个单独的 <span class="Special">CTRL-V</span> (你必须输入 <span class="Special">CTRL-V</span> 两次) 后面什么也不输入来建立
一个空的 <span class="Special">{rhs}</span>。不幸的是在 vimrc 文件中你不能使用这种方式。

							<span class="Ignore">*</span><span class="String">&lt;Nop&gt;</span><span class="Ignore">*</span>
得到什么都不做的映射的更容易的方法是在 <span class="Special">{rhs}</span> 中使用 &quot;<span class="Special">&lt;Nop&gt;</span>&quot;。仅当 <span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span> 记法允
许时这种方法才生效。例如确保功能键 F8 什么事情都不做:
	:map  <span class="Special">&lt;F8&gt;</span>  <span class="Special">&lt;Nop&gt;</span>
	:map! <span class="Special">&lt;F8&gt;</span>  <span class="Special">&lt;Nop&gt;</span>

							<span class="Ignore">*</span><span id="map-multibyte" class="String anchor">map-multibyte</span><span class="Ignore">*</span>
可以对多字节字符映射，但只能是整个字符。不能仅映射第一个字节。这是为了避免下面
场景中的问题:
	:set encoding=latin1
	:imap <span class="Special">&lt;M-C&gt;</span> foo
	:set encoding=utf-8
<span class="Special">&lt;M-C&gt;</span> 的映射是在 latin1 编码中被定义的，结果是一个 0xc3 字节。如果你在 UTF-8
解码中输入 á (0xe1 <span class="Special">&lt;M-a&gt;</span>) 它是双字节 0xc3 0xa1。这个时候你不希望 0xc3 字节被映
射，否则的话将不能输入 á 字符了。

					<span class="Ignore">*</span><span class="String">&lt;Leader&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="mapleader" class="String anchor">mapleader</span><span class="Ignore">*</span>
要定义一个使用 &quot;mapleader&quot; 变量的映射，可以使用特殊字串 &quot;<span class="Special">&lt;Leader&gt;</span>&quot;。它会被
&quot;mapleader&quot; 的字串值所替换。如果 &quot;mapleader&quot; 未设置或为空，则用反斜杠代替，例
如:
	:map <span class="Special">&lt;Leader&gt;</span>A  oanother line<span class="Special">&lt;Esc&gt;</span>
和下面一样:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map \A  oanother line&lt;Esc&gt;</span>
但是当:<span class="Ignore"> &gt;</span>
<span class="Comment">	:let mapleader = &quot;,&quot;</span>
时，又相当于:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map ,A  oanother line&lt;Esc&gt;</span>

注意 &quot;mapleader&quot; 的值仅当定义映射时被使用。后来改变的 &quot;mapleader&quot; 不会影响已定
义的映射。

					<span class="Ignore">*</span><span class="String">&lt;LocalLeader&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="maplocalleader" class="String anchor">maplocalleader</span><span class="Ignore">*</span>
<span class="Special">&lt;LocalLeader&gt;</span> 和 <span class="Special">&lt;Leader&gt;</span> 类似，除了它使用 &quot;maplocalleader&quot; 而非 &quot;mapleader&quot;
以外。<span class="Special">&lt;LocalLeader&gt;</span> 用于局部于缓冲区的映射，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">      :map &lt;buffer&gt; &lt;LocalLeader&gt;A  oanother line&lt;Esc&gt;</span>
<span class="Ignore">&lt;</span>
在一个全局插件里应该使用 <span class="Special">&lt;Leader&gt;</span> 而在一个文件类型插件里应该用 <span class="Special">&lt;LocalLeader&gt;</span>。
&quot;mapleader&quot; 和 &quot;maplocalleader&quot; 可以是相同的。尽管如此，如果你把它们设为不同，
全局插件和文件类型插件的映射冲突的机会是不是会小一点呢？例如，你可以保持把
&quot;mapleader&quot; 设置为缺省的反斜杠，而设置 &quot;maplocalleader&quot; 为下划线。

							<span class="Ignore">*</span><span class="String">map-&lt;SID&gt;</span><span class="Ignore">*</span>
在一个脚本中有一个特殊关键字叫 &quot;<span class="Special">&lt;SID&gt;</span>&quot; 能被用来定义一个局部于脚本中的映射。
具体细节请参考 <span class="Ignore">|</span><span class="Identifier">&lt;SID&gt;</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">&lt;Plug&gt;</span><span class="Ignore">*</span>
叫做 &quot;<span class="Special">&lt;Plug&gt;</span>&quot; 的特殊关键字可以用于一个内部映射，它不与任何键的序列匹配。这在插
件中有用 <span class="Ignore">|</span><a href="#"><span class="Identifier">using-&lt;Plug&gt;</span></a><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">&lt;Char&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">&lt;Char-&gt;</span><span class="Ignore">*</span>
要根据一个字符的十进制，八进制或十六进制数字形式进行映射，可以使用 <span class="Special">&lt;Char&gt;</span> 来构
造:
	<span class="Special">&lt;Char-123&gt;</span>	字符 123
	<span class="Special">&lt;Char-033&gt;</span>	字符 27
	<span class="Special">&lt;Char-0x7f&gt;</span>	字符 127
	<span class="Special">&lt;S-Char-114&gt;</span>    字符 114 ('r') 加上 Shift ('R')
它可以用来在一个 <span class="Type">'keymap'</span> 文件里指定一个 (多字节) 字符。大小写的区别此处不计。

							<span class="Ignore">*</span><span id="map-comments" class="String anchor">map-comments</span><span class="Ignore">*</span>
在这些命令的后面不可能放置注释，因为 '&quot;' 字符被认为是 <span class="Special">{lhs}</span> 或 <span class="Special">{rhs}</span> 的一部
分。不过，你可以用 |&quot;，它开启了带注释的新空白命令。

							<span class="Ignore">*</span><span id="map_bar" class="String anchor">map_bar</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-bar" class="String anchor">map-bar</span><span class="Ignore">*</span>
因为字符 '|' 用来分隔映射命令和后面的命令，所以包括 '|' 的 <span class="Special">{rhs}</span> 要做一些特殊
的处理，有三种方法:
   <span class="PreProc">使用	     可用于			   示例</span><span class="Ignore">	~</span>
   <span class="Special">&lt;Bar&gt;</span>     '&lt;' 不在 <span class="Type">'cpoptions'</span> 里	   :map _l :!ls <span class="Special">&lt;Bar&gt;</span> more^M
   \|	     'b' 不在 <span class="Type">'cpoptions'</span> 里	   :map _l :!ls \| more^M
   ^V|	     总可以，Vim 和 Vi 都行	   :map _l :!ls ^V| more^M

(这里 ^V 表示 <span class="Special">CTRL-V</span>；要输入一个 <span class="Special">CTRL-V</span> 你必须按键两次；在这里不能使用 &lt;&gt; 记法
&quot;<span class="Special">&lt;C-V&gt;</span>&quot;)。

当你使用 <span class="Type">'cpoptions'</span> 的缺省设置时三种方式都可以正常工作。

当 'b' 出现在 <span class="Type">'cpoptions'</span> 中时，&quot;\|&quot; 会被认为是一个映射的结束，后面的是另一个
命令。这是为了和 Vi 兼容，但是和其它命令比较时有点不合常理。

						<span class="Ignore">*</span><span id="map_return" class="String anchor">map_return</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="map-return" class="String anchor">map-return</span><span class="Ignore">*</span>
当你的映射包含 Ex 命令时，你需要在其后放置行终结符才能让它执行。在这里推荐使用
<span class="Special">&lt;CR&gt;</span>  (参考 <span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span>)。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :map  _ls  :!ls -l %:S&lt;CR&gt;:echo &quot;the end&quot;&lt;CR&gt;</span>

在插入或命令行模式中输入时要避免字符被映射，可以先输入一个 <span class="Special">CTRL-V</span>。在插入模式
中如果 <span class="Type">'paste'</span> 选项被打开的话，映射也会被禁止。

							<span class="Ignore">*</span><span id="map-error" class="String anchor">map-error</span><span class="Ignore">*</span>
注意 当遇到错误时 (会导致一个错误信息或蜂鸣) 剩下的映射将不会被执行。这是为了
保持和 Vi 兼容。

注意 @zZtTfF[]rm'`&quot;v 和 <span class="Special">CTRL-X</span> 命令的第二个字符 (参数) 不被映射。这样做是为了
能够使用所有的命名寄存器和位置标记，即使同名的命令被映射时也是如此。

1.7 映 射 哪 些 键					<span class="Ignore">*</span><span id="map-which-keys" class="String anchor">map-which-keys</span><span class="Ignore">*</span>

如果你要做一些映射，你得选择在 <span class="Special">{lhs}</span> 中要用哪些键。你应该避免使用 Vim 命令所使
用的那些键。否则你将不能再使用这些命令了。下面是一些建议:
- 功能键 <span class="Special">&lt;F2&gt;</span>、<span class="Special">&lt;F3&gt;</span> 等；Shift 加功能键 <span class="Special">&lt;S-F1&gt;</span>、<span class="Special">&lt;S-F2&gt;</span> 等等。注意 <span class="Special">&lt;F1&gt;</span> 已经用作
  帮助命令。
- 带 Meta 的键 (和 ALT 键一起按下)。取决于你的键盘，也可以用带重音的字符。
  <span class="Ignore">|</span><span class="Identifier">:map-alt-keys</span><span class="Ignore">|</span>
- 使用 '_' 或 ',' 字符然后加上任何其它的字符。&quot;_&quot; 和 &quot;,&quot; 命令在 Vim 中是存在
  的 (参考 <span class="Ignore">|</span><span class="Identifier">_</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">,</span><span class="Ignore">|</span>)，但你也许永远不会用到它们。
- 使用和其它命令的同义的热键。例如: <span class="Special">CTRL-P</span> 和 <span class="Special">CTRL-N</span>。使用一个附加的字符可以定
  义更多的映射。
- <span class="Special">&lt;Leader&gt;</span> 定义的键加上一到多个其它键。尤其对脚本有用。<span class="Ignore">|</span><a href="map.html#mapleader"><span class="Identifier">mapleader</span></a><span class="Ignore">|</span>

参考文件 &quot;index&quot; 可以知道哪些键没有被使用，从而使映射不会覆盖任何内建的功能。
也可使用 &quot;:help <span class="Special">{key}</span>^D&quot; 来找出是否一个键已经用于某些命令。 (<span class="Special">{key}</span> 用于指定你
要寻找的键，^D 是 <span class="Special">CTRL-D</span>)。

1.8 示 例						<span class="Ignore">*</span><span id="map-examples" class="String anchor">map-examples</span><span class="Ignore">*</span>

以下是一些例子 (照字面输入它们，对于 &quot;<span class="Special">&lt;CR&gt;</span>&quot; 你输入四个字符；为此 '&lt;' 标志位不
应出现在 <span class="Type">'cpoptions'</span> 中)。<span class="Ignore"> &gt;</span>

<span class="Comment">   :map &lt;F3&gt;  o#include</span>
<span class="Comment">   :map &lt;M-g&gt; /foo&lt;CR&gt;cwbar&lt;Esc&gt;</span>
<span class="Comment">   :map _x    d/END/e&lt;CR&gt;</span>
<span class="Comment">   :map! qq   quadrillion questions</span>

计数相乘

如果你在激活映射前输入计数，实际效果就像是该计数在 <span class="Special">{lhs}</span> (译者注: 疑为 <span class="Special">{rhs}</span>)
之前输入一样。例如，对下面的映射:<span class="Ignore"> &gt;</span>
<span class="Comment">   :map &lt;F4&gt;  3w</span>
输入 2<span class="Special">&lt;F4&gt;</span> 会得到 &quot;23w&quot;。不是移动 2 * 3 个单词，而是 23 个单词。
如果你希望得到计数相乘的效果，可使用表达式寄存器:<span class="Ignore"> &gt;</span>
<span class="Comment">   :map &lt;F4&gt;  @='3w'&lt;CR&gt;</span>
引号之间的部分是待执行的表达式。 <span class="Ignore">|</span><span class="Identifier">@=</span><span class="Ignore">|</span>

1.9 使 用 映 射						<span class="Ignore">*</span><span id="map-typing" class="String anchor">map-typing</span><span class="Ignore">*</span>

当你输入一个被映射序列的头部时 Vim 开始比较你的输入。如果匹配尚不完全，它会等
待更多的字符输入直到可以确定是否匹配。例如: 如果你映射了 map! &quot;qq&quot;，然后你输入
的第一个 'q' 将不会显示在屏幕上，直到你输入另一个 'q' 或其它字符。如果打开了
<span class="Type">'timeout'</span> 选项 (这是缺省选项) Vim 仅会等待一秒钟 (或任何 <span class="Type">'timeoutlen'</span> 指定的时
间)。之后，它假定 'q' 已经不会再被输入。如果你的输入很慢，或者你的系统很慢，复
位 <span class="Type">'timeout'</span> 选项。这时，你可能还需要是否置位 <span class="Type">'ttimeout'</span> 选项。

<span class="Statement">                            				</span><span class="Ignore">*</span><span id="map-precedence" class="String anchor">map-precedence</span><span class="Ignore">*</span>
缓冲区局部映射 (<span class="Ignore">|</span><span class="Identifier">:map-&lt;buffer&gt;</span><span class="Ignore">|</span> 所定义的) 优先于全局映射。如果缓冲区局部映射和
全局映射完全相同，Vim 使用缓冲区局部映射。另外如果映射以 <span class="Special">&lt;nowait&gt;</span> 定义的话，
Vim 立即使用完整出现的映射，即便有一个更长的映射使用相同的前缀。例如，给定以下
的映射:<span class="Ignore"> &gt;</span>
<span class="Comment">    :map &lt;buffer&gt; &lt;nowait&gt; \a   :echo &quot;Local \a&quot;&lt;CR&gt;</span>
<span class="Comment">    :map                   \abc :echo &quot;Global \abc&quot;&lt;CR&gt;</span>
键入 \a 后会立即使用那个缓冲区局部映射。Vim 不再等待更多的字符来判断用户是否想
输入 \abc。

							<span class="Ignore">*</span><span id="map-keys-fails" class="String anchor">map-keys-fails</span><span class="Ignore">*</span>
有若干情况键码可能不被识别:
- Vim 仅能读取部分的键码。通常仅仅是第一个字符。在某些 Unix 版本的 xterm 上有
  这种情况。
- 键码在已经映射的字符之后。举例来说，&quot;<span class="Special">&lt;F1&gt;&lt;F1&gt;</span>&quot; 或 &quot;g<span class="Special">&lt;F1&gt;</span>&quot;。

其结果是在这种情况下键码不会被识别，所以映射失败。有两种方法可以避免此问题:

- 从 <span class="Type">'cpoptions'</span> 中删除 'K' 标志位。这会使 Vim 等待功能键的其余部分。
- 使用 <span class="Special">&lt;F1&gt;</span> 到 <span class="Special">&lt;F4&gt;</span> 时，实际产生的键码可能是 <span class="Special">&lt;xF1&gt;</span> 到 <span class="Special">&lt;xF4&gt;</span>。存在 <span class="Special">&lt;xF1&gt;</span> 到
  <span class="Special">&lt;F1&gt;</span>，<span class="Special">&lt;xF2&gt;</span> 到 <span class="Special">&lt;F2&gt;</span> 的映射等，但是在映射的后一半的那些依然不会被识别。确认从
  <span class="Special">&lt;F1&gt;</span> 到 <span class="Special">&lt;F4&gt;</span> 的键码是正确的:<span class="Ignore"> &gt;</span>
<span class="Comment">	:set &lt;F1&gt;=&lt;type CTRL-V&gt;&lt;type F1&gt;</span>
<span class="Ignore">&lt;</span> 以四个字符输入 <span class="Special">&lt;F1&gt;</span>。&quot;=&quot; 号后面的部分必需以实际的字符输入，而不是字面的文
  本。
另一种解决方法是在映射中为第二个特殊键使用实际的键码:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;F1&gt;&lt;Esc&gt;OP :echo &quot;yes&quot;&lt;CR&gt;</span>
不要输入一个真正的 <span class="Special">&lt;Esc&gt;</span>，总之 Vim 将识别键码并把它替换为 <span class="Special">&lt;F1&gt;</span>。

另一个问题可能是保持 ALT 或 Meta 的时候，终端在前面附加 ESC 而不是给第 8 位置
位。见 <span class="Ignore">|</span><span class="Identifier">:map-alt-keys</span><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span id="recursive_mapping" class="String anchor">recursive_mapping</span><span class="Ignore">*</span>
如果 <span class="Special">{rhs}</span> 中包括了 <span class="Special">{lhs}</span>，那么你定义了一个递归映射。当 <span class="Special">{lhs}</span> 被输入，它会被替
换成 <span class="Special">{rhs}</span>。当遇到 <span class="Special">{rhs}</span> 中包含的 <span class="Special">{lhs}</span> 又会被替换成 <span class="Special">{rhs}</span>，依此类推。
这可用来使一个命令重复无数次。这种情况唯一的问题是出错是停止它的唯一方法。解决
迷宫的宏会用到这个，去那里找找例子吧。有一个例外: 如果 <span class="Special">{rhs}</span> 以 <span class="Special">{lhs}</span> 开始，第
一个字符不会被再次映射 (这与 Vi 兼容)。
例如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :map ab abcd</span>
将执行 &quot;a&quot; 命令并且在文本中插入 &quot;bcd&quot;。<span class="Special">{rhs}</span> 中的 &quot;ab&quot; 不会被再次映射。

如果你要交换两个键的含义，应该使用 :noremap 命令。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :noremap k j</span>
<span class="Comment">   :noremap j k</span>
这会交换光标上移和光标下移命令。

如果使用普通 :map 命令，并且 <span class="Type">'remap'</span> 选项被打开，映射一直进行直到文本不再是某
个 <span class="Special">{lhs}</span> 的一部分。例如，如果你用:<span class="Ignore"> &gt;</span>
<span class="Comment">   :map x y</span>
<span class="Comment">   :map y x</span>
Vim 将把 x 替换成 y，并把 y 替换成 x，等等。这种情况会发生 <span class="Type">'maxmapdepth'</span> 次
(缺省为 1000)，然后 Vim 会给出错误信息 &quot;recursive mapping&quot; (递归映射)。

							<span class="Ignore">*</span><span class="String">:map-undo</span><span class="Ignore">*</span>
如果你在一个被映射的序列中包含了一个 undo 命令，将会把文本带回宏执行前的状态。
这和原始的 Vi 是兼容的，只要被映射的序列仅包含一个 undo 命令 (原始的 Vi 中被映
射的序列有两个 undo 命令是无意义的，你会得到第一个 undo 之前的文本)。

1.10 映 射 ALT 键					<span class="Ignore">*</span><span class="String">:map-alt-keys</span><span class="Ignore">*</span>

GUI 上，Vim 自己处理 Alt 键，所以用 ALT 键的映射应该总没有问题。但在终端上，
Vim 得到字节的序列，它必须自己判断是不是按了 ALT 键。

Vim 缺省假设按下 ALT 键等于置位输入字符的第 8 位。多数正常的终端如此工作，包括
xterm、aterm 和 rxvt。假如你的 <span class="Special">&lt;A-k&gt;</span> 映射不能工作，可能的原因是你的终端用在字
符前加上 ESC 前缀的方法。但是你本来也可能在字符前输入 ESC，这时 Vim 就不知道到
底发生了什么 (只能检查字符间的延迟，但这并不可靠)。

在此文写作时，有些主流的终端，如 gnome-terminal 和 konsole，使用 ESC 前缀。没
有办法让它们用置位第 8 位来代替。Xterm 缺省应该没有问题。Aterm 和 rxvt 启动时
如果使用 &quot;--meta8&quot; 参数也可以如此。你也可以修改资源来达到目的:
&quot;metaSendsEscape&quot;、&quot;eightBitInput&quot; 和 &quot;eightBitOutput&quot;。

Linux 控制台上，可以用 &quot;setmetamode&quot; 命令切换此行为。记住不使用 ESC 前缀可能和
其它程序发生冲突。确保你的 bash 把 &quot;convert-meta&quot; 选项设为 &quot;on&quot;，确保 Meta 键
盘绑定仍然工作 (这是缺省的 readline 行为，除非你的系统配置专门作了改变)。为
此，你需要加入这行:<span class="Ignore"> &gt;</span>

<span class="Comment">	set convert-meta on</span>

到你的 ~/.inputrc 文件。如果你新建此文件，可能想把:<span class="Ignore"> &gt;</span>

<span class="Comment">	$include /etc/inputrc</span>

放在第一行，如果此文件在你的系统中存在的话。这样可以保持全局的选项设置。不过，
这可能会使 umlaut 这样的特殊字符的输入有问题。这时，输入字符前用 <span class="Special">CTRL-V</span> 前导。

要知道有报告说 convert-meta 使得 UTF-8 locale 的使用有问题。在 xterm 这样的终
端里，可以在 &quot;Main Options&quot; 菜单里随时切换 &quot;metaSendsEscape&quot; 资源，或者终端上
按 Ctrl-LeftClick 也可以；如果你需要给 Vim 之外的其它应用程序发送 ESC，这是最
后应急的方法。

1.11 映 射 操 作 符					<span class="Ignore">*</span><span class="String">:map-operator</span><span class="Ignore">*</span>

操作符应用于 <span class="Special">{motion}</span> 命令之前。要定义你自己的操作符，你需要先创建映射来设置
<span class="Type">'operatorfunc'</span> 选项，然后调用 <span class="Ignore">|</span><a href="#"><span class="Identifier">g@</span></a><span class="Ignore">|</span> 操作符。这样用户输入 <span class="Special">{motion}</span> 命令后，会调
用指定的函数。

							<span class="Ignore">*</span><span class="String">g@</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E774" class="String anchor">E774</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E775" class="String anchor">E775</span><span class="Ignore">*</span>
g@<span class="Special">{motion}</span>		调用 <span class="Type">'operatorfunc'</span> 选项设置的函数。
			'[ 位置标记定位在 <span class="Special">{motino}</span> 跨越的文本的开始处，而 ']
			位置标记在此文本的结束处。
			函数调用时，带一个字符串参数:
			      参数               如果
			    &quot;line&quot;	<span class="Special">{motion}</span> 本是 <span class="Ignore">|</span><a href="motion.html#linewise"><span class="Identifier">linewise</span></a><span class="Ignore">|</span>
			    &quot;char&quot;	<span class="Special">{motion}</span> 本是 <span class="Ignore">|</span><a href="motion.html#characterwise"><span class="Identifier">characterwise</span></a><span class="Ignore">|</span>
			    &quot;block&quot;	<span class="Special">{motion}</span> 本是 <span class="Ignore">|</span><a href="visual.html#blockwise-visual"><span class="Identifier">blockwise-visual</span></a><span class="Ignore">|</span>
			不过，&quot;block&quot; 很少出现，因为它只能来自可视模式，那里
			&quot;g@&quot; 不是很有用。
			{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+eval</span><span class="Ignore">|</span> 特性才有效}

这里是一例，<span class="Special">&lt;F4&gt;</span> 来计算空格数目:<span class="Ignore"> &gt;</span>

<span class="Comment">	nmap &lt;silent&gt; &lt;F4&gt; :set opfunc=CountSpaces&lt;CR&gt;g@</span>
<span class="Comment">	vmap &lt;silent&gt; &lt;F4&gt; :&lt;C-U&gt;call CountSpaces(visualmode(), 1)&lt;CR&gt;</span>

<span class="Comment">	function! CountSpaces(type, ...)</span>
<span class="Comment">	  let sel_save = &amp;selection</span>
<span class="Comment">	  let &amp;selection = &quot;inclusive&quot;</span>
<span class="Comment">	  let reg_save = @@</span>

<span class="Comment">	  if a:0  &quot; 在可视模式里调用，使用 gv 命令。</span>
<span class="Comment">	    silent exe &quot;normal! gvy&quot;</span>
<span class="Comment">	  elseif a:type == 'line'</span>
<span class="Comment">	    silent exe &quot;normal! '[V']y&quot;</span>
<span class="Comment">	  else</span>
<span class="Comment">	    silent exe &quot;normal! `[v`]y&quot;</span>
<span class="Comment">	  endif</span>

<span class="Comment">	  echomsg strlen(substitute(@@, '[^ ]', '', 'g'))</span>

<span class="Comment">	  let &amp;selection = sel_save</span>
<span class="Comment">	  let @@ = reg_save</span>
<span class="Comment">	endfunction</span>
<span class="Ignore">&lt;</span>
注意 <span class="Type">'selection'</span> 选项暂时设为 &quot;inclusive&quot;，以便可视模式下用 '[ 到 '] 位置标记
可以抽出正确的文本。

也要 注意 这里为可视模式提供了专用的映射。它先删除 &quot;:&quot; 在可视模式里插入的
&quot;'&lt;,'&gt;&quot; 范围，然后调用函数，调用时使用了 visualmode() 和一个额外的参数。

<span class="PreProc">==============================================================================</span>
2. 缩写			<span class="Ignore">*</span><span id="abbreviations" class="String anchor">abbreviations</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="Abbreviations" class="String anchor">Abbreviations</span><span class="Ignore">*</span>

缩写在插入，替换和命令行模式中使用。如果你输入一个是缩写的单词，它会被替换成所
表示的东西。这可以在经常输入的长单词时节省键击。并且能用它来自动更正经常犯的拼
写错误。例如:

	:iab ms Microsoft
	:iab tihs this

有三种类型的缩写:

full-id	  &quot;full-id&quot; 类型完全由关键字字符组成 (字母和 <span class="Type">'iskeyword'</span> 选项的字符)。
	  这是最普通的缩写。

	  例如: &quot;foo&quot;，&quot;g3&quot;，&quot;-1&quot;

end-id	  &quot;end-id&quot; 类型以一个关键字字符结尾，但所有其它字符都不是关键字字符。

	  例如: &quot;#i&quot;，&quot;..f&quot;，&quot;$/7&quot;

non-id	  &quot;non-id&quot; 类型以一个非关键字字符结尾，其它字符可以是任意类型，除了空
	  格和制表。<span class="Special">{Vi 不支持这种类型}</span>

	  例如: &quot;def#&quot;，&quot;4/7$&quot;

不能被缩写的字串例子: &quot;a.b&quot;，&quot;#def&quot;，&quot;a b&quot;，&quot;_$r&quot;

仅当你输入一个非关键字字符时缩写才会被识别，这也包括用 <span class="Special">&lt;Esc&gt;</span> 退出插入模式或用
<span class="Special">&lt;CR&gt;</span> 结束一个命令的情形。结束缩写的非关键字字符被插入到缩写的扩展后面。一个例
外是字符 <span class="Special">&lt;C-]&gt;</span>，它用来扩展一个缩写，但不插入任何附加字符。

例如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :ab hh	hello</span>
<span class="Ignore">&lt;</span>	    &quot;hh<span class="Special">&lt;Space&gt;</span>&quot; 被扩展为 &quot;hello<span class="Special">&lt;Space&gt;</span>&quot;
	    &quot;hh<span class="Special">&lt;C-]&gt;</span>&quot; 被扩展为 &quot;hello&quot;

光标前的字符必需和缩写匹配。每种类型还有附加规则:

full-id	  匹配的前面是一个非关键字字符，或者是在行或插入的开始。例外: 当缩写仅
	  有一个字符时，如果它前面有一个非关键字字符则不会被识别，除非那是空格
	  和制表。

end-id	  匹配的前面是一个关键字字符，或者空格或制表，或者行或插入的开始。

non-id	  匹配的前面是一个空格、制表或者行或插入的开始。

例如: (<span class="Special">{CURSOR}</span> 是你输入一个非关键字字符的地方)<span class="Ignore"> &gt;</span>
<span class="Comment">   :ab foo   four old otters</span>
<span class="Ignore">&lt;</span>		&quot; foo<span class="Special">{CURSOR}</span>&quot;	  被扩展为 &quot; four old otters&quot;
		&quot; foobar<span class="Special">{CURSOR}</span>&quot; 不被扩展
		&quot;barfoo<span class="Special">{CURSOR}</span>&quot;  不被扩展
<span class="Ignore">&gt;</span>
<span class="Comment">   :ab #i #include</span>
<span class="Ignore">&lt;</span>		&quot;#i<span class="Special">{CURSOR}</span>&quot;	  被扩展为 &quot;#include&quot;
		&quot;&gt;#i<span class="Special">{CURSOR}</span>&quot;	  不被扩展
<span class="Ignore">&gt;</span>
<span class="Comment">   :ab ;; &lt;endofline&gt;</span>
<span class="Ignore">&lt;</span>		&quot;test;;&quot;	  不被扩展
		&quot;test ;;&quot;	  被扩展为 &quot;test <span class="Special">&lt;endofline&gt;</span>&quot;

要在插入模式中避免缩写: 在会启动缩写的的字符之前面输入 <span class="Special">CTRL-V</span>，例如 <span class="Special">CTRL-V</span>
<span class="Special">&lt;Space&gt;</span>。或者先输入缩写的部分，以 <span class="Special">&lt;Esc&gt;</span> 退出插入模式，再用 'a' 重新进入插入模
式并输入剩下的部分。

要在命令行模式中避免缩写: 在缩写的某处输入 <span class="Special">CTRL-V</span> 两次来避免它被替换。不然，一
个普通字符前面的 <span class="Special">CTRL-V</span> 通常会被忽略。

缩写进行之后移动光标是可能的:<span class="Ignore"> &gt;</span>
<span class="Comment">   :iab if if ()&lt;Left&gt;</span>
如果 <span class="Type">'cpoptions'</span> 里面包含 '&lt;' 标志位时，这不能正常工作。<span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span>

你甚至可以做更复杂的事情。例如，要消灭一个缩写后面输入的空格:<span class="Ignore"> &gt;</span>
<span class="Comment">   func Eatchar(pat)</span>
<span class="Comment">      let c = nr2char(getchar(0))</span>
<span class="Comment">      return (c =~ a:pat) ? '' : c</span>
<span class="Comment">   endfunc</span>
<span class="Comment">   iabbr &lt;silent&gt; if if ()&lt;Left&gt;&lt;C-R&gt;=Eatchar('\s')&lt;CR&gt;</span>

没有缺省的缩写。

缩写永远不会递归。你可以设置 &quot;:ab f f-o-o&quot; 而不会有任何问题。但是缩写能被映
射。{一些版本的 Vi 支持递归缩写，这毫无道理}

<span class="Type">'paste'</span> 选项打开时，缩写被禁止。

				<span class="Ignore">*</span><span class="String">:abbreviate-local</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:abbreviate-&lt;buffer&gt;</span><span class="Ignore">*</span>
和映射一样，缩写可以被局部于一个缓冲区之内。这经常用于 <span class="Ignore">|</span><a href="usr_43.html#filetype-plugin"><span class="Identifier">filetype-plugin</span></a><span class="Ignore">|</span> 文
件。一个 C 插件文件的例子:<span class="Ignore"> &gt;</span>
<span class="Comment">	:abb &lt;buffer&gt; FF  for (i = 0; i &lt; ; ++i)</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span class="String">:ab</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:abbreviate</span><span class="Ignore">*</span>
:ab[breviate]		列出所有的缩写。第一栏中的字符表示该缩写作用的模式:
			'i' 指插入模式，'c' 指命令行模式，'!' 指两种模式都有。
			这和映射的相同，参看 <span class="Ignore">|</span><a href="map.html#map-listing"><span class="Identifier">map-listing</span></a><span class="Ignore">|</span> 。

						<span class="Ignore">*</span><span class="String">:abbreviate-verbose</span><span class="Ignore">*</span>
如果 <span class="Type">'verbose'</span> 非零，缩写列出的同时显示它最近定义的位置。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">	:verbose abbreviate</span>
<span class="Comment">	!  teh		 the</span>
<span class="Comment">		Last set from /home/abcd/vim/abbr.vim</span>

<span class="Ignore">|</span><span class="Identifier">:verbose-cmd</span><span class="Ignore">|</span> 说明详情。

:ab[breviate] <span class="Special">{lhs}</span>	列出以 <span class="Special">{lhs}</span> 开头的缩写

:ab[breviate] [<span class="Special">&lt;expr&gt;</span>] [<span class="Special">&lt;buffer&gt;</span>] <span class="Special">{lhs}</span> <span class="Special">{rhs}</span>
			增加一个从 <span class="Special">{lhs}</span> 到 <span class="Special">{rhs}</span> 的缩写。如果 <span class="Special">{lhs}</span> 已经存在
			则它会被替换成新的 <span class="Special">{rhs}</span>。<span class="Special">{rhs}</span> 可包含空格。
			<span class="Ignore">|</span><span class="Identifier">:map-&lt;expr&gt;</span><span class="Ignore">|</span> 说明可选的 <span class="Special">&lt;expr&gt;</span> 参数。
			<span class="Ignore">|</span><span class="Identifier">:map-&lt;buffer&gt;</span><span class="Ignore">|</span> 说明可选的 <span class="Special">&lt;buffer&gt;</span> 参数。

						<span class="Ignore">*</span><span class="String">:una</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:unabbreviate</span><span class="Ignore">*</span>
:una[bbreviate] <span class="Special">{lhs}</span>	从列表中删除 <span class="Special">{lhs}</span> 的缩写。如果找不到，删除 <span class="Special">{rhs}</span> 匹配
			这里的 <span class="Special">{lhs}</span> 参数的缩写。这是为了方便你删除扩展后的缩
			写。要避免扩展，插入 <span class="Special">CTRL-V</span> (记住输入两次)。

						<span class="Ignore">*</span><span class="String">:norea</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:noreabbrev</span><span class="Ignore">*</span>
:norea[bbrev] [<span class="Special">&lt;expr&gt;</span>] [<span class="Special">&lt;buffer&gt;</span>] <span class="Special">[lhs]</span> <span class="Special">[rhs]</span>
			与 &quot;:ab&quot; 一样，但 <span class="Special">{rhs}</span> 不进行重映射。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:ca</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cabbrev</span><span class="Ignore">*</span>
:ca[bbrev] [<span class="Special">&lt;expr&gt;</span>] [<span class="Special">&lt;buffer&gt;</span>] <span class="Special">[lhs]</span> <span class="Special">[rhs]</span>
			与 &quot;:ab&quot; 一样，但仅在命令行模式中使用。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:cuna</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cunabbrev</span><span class="Ignore">*</span>
:cuna[bbrev] <span class="Special">{lhs}</span>	与 &quot;:una&quot; 一样，但仅在命令行模式中使用。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:cnorea</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cnoreabbrev</span><span class="Ignore">*</span>
:cnorea[bbrev] [<span class="Special">&lt;expr&gt;</span>] [<span class="Special">&lt;buffer&gt;</span>] <span class="Special">[lhs]</span> <span class="Special">[rhs]</span>
			与 &quot;:ab&quot; 一样，但仅在命令行模式中使用并且 <span class="Special">{rhs}</span> 不进行
			重映射。<span class="Special">{Vi 中无此功能}</span>

						<span class="Ignore">*</span><span class="String">:ia</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:iabbrev</span><span class="Ignore">*</span>
:ia[bbrev] [<span class="Special">&lt;expr&gt;</span>] [<span class="Special">&lt;buffer&gt;</span>] <span class="Special">[lhs]</span> <span class="Special">[rhs]</span>
			与 &quot;:ab&quot; 一样，但仅在插入模式中使用。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:iuna</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:iunabbrev</span><span class="Ignore">*</span>
:iuna[bbrev] <span class="Special">{lhs}</span>	与 &quot;:una&quot; 一样，但仅在插入模式中使用。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">:inorea</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:inoreabbrev</span><span class="Ignore">*</span>
:inorea[bbrev] [<span class="Special">&lt;expr&gt;</span>] [<span class="Special">&lt;buffer&gt;</span>] <span class="Special">[lhs]</span> <span class="Special">[rhs]</span>
			与 &quot;:ab&quot; 一样，但仅在插入模式中使用并且 <span class="Special">{rhs}</span> 不进行重
			映射。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:abc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:abclear</span><span class="Ignore">*</span>
:abc[lear] [<span class="Special">&lt;buffer&gt;</span>]	删除所有的缩写。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:iabc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:iabclear</span><span class="Ignore">*</span>
:iabc[lear] [<span class="Special">&lt;buffer&gt;</span>]	为插入模式删除所有的缩写。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:cabc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cabclear</span><span class="Ignore">*</span>
:cabc[lear] [<span class="Special">&lt;buffer&gt;</span>]	为命令行模式删除所有的缩写。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span id="using_CTRL-V" class="String anchor">using_CTRL-V</span><span class="Ignore">*</span>
在一个缩写的 <span class="Special">{rhs}</span> 中使用特殊字符是可能的。<span class="Special">CTRL-V</span> 可以用来避免多数不可显示字符
的特殊含义。需要输入多少个 <span class="Special">CTRL-V</span> 取决于你如何输入缩写。此处讨论同样适用于映
射。这里使用一个例子说明。

假设你需要把 &quot;esc&quot; 缩写为输入一个 <span class="Special">&lt;Esc&gt;</span> 字符。当你在 Vim 中输入 &quot;:ab&quot; 命令，你
必需这样输入: (这里 ^V 是一个 <span class="Special">CTRL-V</span> 并且 ^[ is <span class="Special">&lt;Esc&gt;</span>)

你输入:   ab esc ^V^V^V^V^V^[

	所有的键盘输入都经过 ^V 引用解释，所以第一个，第三个，和第五个 ^V 字符
	只是为了把第二个、第四个  ^V 和 ^[ 输入到命令行里。

你看到:    ab esc ^V^V^[

	命令行里在 ^[ 之前包含两个实际的 ^V。如果你采用这种方法，这是该行在你
	的 .exrc 文件应该出现的样子。第一个 ^V 作为引用第二个 ^V 的字符: 这是
	因为 :ab 命令使用 ^V 作为它自己的引用字符，以便你能在缩写中包含被引用
	的空白字符或 | 字符。:ab 命令对 ^[ 字符并不做特殊的事情，所以它不需要
	被引用。(尽管引用也没有害处；因而输入 7 个 [8 个不行！] ^V 也会工
	作。)

被保存为:  esc     ^V^[

	解析后，该缩写的简短形式 (&quot;esc&quot;) 和扩展形式 (两字符 &quot;^V^[&quot;) 被保存在缩
	写表中。如果输入不带参数的 :ab 命令，这是该缩写被显示的形式。

	然后当用户输入单词 &quot;esc&quot; 而扩展该缩写时，扩展形式服从和一般键盘输入同
	样形式的 ^V 解释。所以 ^V 保护 ^[ 字符不被解释为 &quot;退出插入模式&quot; 的字
	符，而把 ^[ 插入到文本里。

扩展为: ^[

[Steve Kirkendall 提供示例]

<span class="PreProc">==============================================================================</span>
3. 局部映射和函数				<span class="Ignore">*</span><span id="script-local" class="String anchor">script-local</span><span class="Ignore">*</span>

当使用多个 Vim 脚本文件时，一个脚本和另一个脚本使用同样名字的映射和函数是危险
的。为了避免这种情况，它们可以局部在脚本。

						<span class="Ignore">*</span><span class="String">&lt;SID&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">&lt;SNR&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E81" class="String anchor">E81</span><span class="Ignore">*</span>
字串 &quot;<span class="Special">&lt;SID&gt;</span>&quot; 能用于映射或菜单。这要求 <span class="Type">'cpoptions'</span> 中没有 '&lt;' 标志位。
   当执行映射命令时，Vim 将把 &quot;<span class="Special">&lt;SID&gt;</span>&quot; 替换成特殊键码 <span class="Special">&lt;SNR&gt;</span>，后跟一个每个脚本唯
一的数字编号，和一个下划线。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;SID&gt;Add</span>
会定义一个映射 &quot;<span class="Special">&lt;SNR&gt;</span>23_Add&quot;。

当在一个脚本中定义一个函数的时候，可以在名字的前面用一个 &quot;s:&quot; 来使它局部于脚本
中。但当一个映射 (译者注: 似应为函数) 从脚本外面被执行时，它不知道该函数在哪个
脚本中被定义。为了避免这种情况，使用 &quot;<span class="Special">&lt;SID&gt;</span>&quot; 来代替 &quot;s:&quot;。映射也做同样的变换。
这使得在映射里可以定义一个函数调用。

当一个局部函数被执行时，它在定义脚本的上下文中运行。这意味着，它定义的新函数和
映射也可以使用  &quot;s:&quot; 或 &quot;<span class="Special">&lt;SID&gt;</span>&quot;，并且使用和函数本身定义时相同的唯一数字编号。
此外，也能用 &quot;s:var&quot; 脚本局部变量。

当执行一个自动命令或一个用户命令时，它将在定义脚本的上下文中运行。这使得该命令
可以调用一个局部函数或者使用一个局部映射。

除此以外，在脚本上下文之外使用 &quot;<span class="Special">&lt;SID&gt;</span>&quot; 是错误的。

如果你需要在一个复杂的脚本中取得脚本的数字编号，使用此函数:<span class="Ignore"> &gt;</span>
<span class="Comment">	function s:SID()</span>
<span class="Comment">	  return matchstr(expand('&lt;sfile&gt;'), '&lt;SNR&gt;\zs\d\+\ze_SID$')</span>
<span class="Comment">	endfun</span>

列出函数和映射时会显示 &quot;<span class="Special">&lt;SNR&gt;</span>&quot;。可以用来它们在哪里被定义。

命令 <span class="Ignore">|</span><span class="Identifier">:scriptnames</span><span class="Ignore">|</span> 可以用来查看哪些脚本已经被读入以及它们的 <span class="Special">&lt;SNR&gt;</span> 数字编号。

这些都是 <span class="Special">{Vi 无此功能}</span> 并且 {仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+eval</span><span class="Ignore">|</span> 特性才有效}。

<span class="PreProc">==============================================================================</span>
4. 用户定义的命令				<span class="Ignore">*</span><span id="user-commands" class="String anchor">user-commands</span><span class="Ignore">*</span>

可以定义你自己的 Ex 命令。用户自定义命令可以和内建命令一样运行 (它可以有范围或
参数，参数可以是自动补全的文件名或缓冲区名，等等)，除了当该命令执行时，它会被
转换成一个普通的 Ex 命令然后再被执行以外。

对于初学者来说: 参考用户手册中的 <span class="Ignore">|</span><a href="usr_40.html#40.2"><span class="Identifier">40.2</span></a><span class="Ignore">|</span> 。

					<span class="Ignore">*</span><span id="E183" class="String anchor">E183</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E841" class="String anchor">E841</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="user-cmd-ambiguous" class="String anchor">user-cmd-ambiguous</span><span class="Ignore">*</span>
所有用户定义的命令都必须以大写字母开头，来避免与内建命令的冲突。以下内建命令是
例外:
	:Next
	:X
它们不能用于用户自定义命令。&quot;:Print&quot; 也是已定义的命令，但已废弃，可以被覆盖。

用户命令的其它字符可以是大写字母，小写字母或数字。当使用数字时，小心会和其它以
数字作为参数的命令混淆。例如，命令 &quot;:Cc2&quot; 可能是不带参数的用户命令 &quot;:Cc2&quot;，也
可能是参数为 &quot;2&quot; 的命令 &quot;Cc&quot;。建议在命令名和参数之间放置一个空格来避免这些问
题。

当使用一个用户定义的命令时，该命令可以缩写。但是，如果缩写不唯一，会发生错误。
此外，内建命令总是优先执行。

例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:command Rename ..。</span>
<span class="Comment">	:command Renumber ..。</span>
<span class="Comment">	:Rena				&quot; 意味着 &quot;Rename&quot;</span>
<span class="Comment">	:Renu				&quot; 意味着 &quot;Renumber&quot;</span>
<span class="Comment">	:Ren				&quot; 错误 - 有二义性</span>
<span class="Comment">	:command Paste ..。</span>
<span class="Comment">	:P				&quot; 内建的 :Print</span>

建议在脚本中使用用户自定义命令的全名。

:com[mand]						<span class="Ignore">*</span><span class="String">:com</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:command</span><span class="Ignore">*</span>
			列出所有用户自定义命令。在列出命令时，
			前两栏的字符表示
			    !	命令有 -bang 属性
			    &quot;	命令有 -register 属性
			    b	命令局部于当前缓冲区
			(下面给出属性的详细描述)
			此列表可用 <span class="Ignore">|</span><span class="Identifier">:filter</span><span class="Ignore">|</span> 命令过滤，例如，要列出所有名字带
			&quot;Pyth&quot; 的命令:<span class="Ignore"> &gt;</span>
<span class="Comment">				filter Pyth command</span>

:com[mand] <span class="Special">{cmd}</span>	列出以 <span class="Special">{cmd}</span> 开头的用户命令

							<span class="Ignore">*</span><span class="String">:command-verbose</span><span class="Ignore">*</span>
如果 <span class="Type">'verbose'</span> 非零，命令列出的同时显示它最近定义的位置。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">    :verbose command TOhtml</span>
<span class="Ignore">&lt;</span>	<span class="PreProc">Name	    Args Range Complete  Definition</span><span class="Ignore"> ~</span>
	<span class="PreProc">TOhtml	    0	 %		 :call Convert2HTML(&lt;line1&gt;, &lt;line2&gt;)</span><span class="Ignore"> ~</span>
	    <span class="PreProc">Last set from /usr/share/vim/vim-7.0/plugin/tohtml.vim</span><span class="Ignore"> ~</span>

<span class="Ignore">|</span><span class="Identifier">:verbose-cmd</span><span class="Ignore">|</span> 介绍详情。

							<span class="Ignore">*</span><span id="E174" class="String anchor">E174</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E182" class="String anchor">E182</span><span class="Ignore">*</span>
:com[mand][!] [<span class="Special">{attr}</span>...] <span class="Special">{cmd}</span> <span class="Special">{rep}</span>
			定义一个用户命令。命令的名字是 <span class="Special">{cmd}</span>，而替换的文本是
			<span class="Special">{rep}</span>。该命令的属性 (参考下面) 是 <span class="Special">{attr}</span>。如果该命令已
			存在，报错，除非已经指定了一个 !，这种情况下命令被重定
			义。

:delc[ommand] <span class="Special">{cmd}</span>				<span class="Ignore">*</span><span class="String">:delc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:delcommand</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E184" class="String anchor">E184</span><span class="Ignore">*</span>
			删除用户定义命令 <span class="Special">{cmd}</span>。

:comc[lear]						<span class="Ignore">*</span><span class="String">:comc</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:comclear</span><span class="Ignore">*</span>
			删除所有用户定义命令。

命令属性

Vim 和任何其它 Ex 命令一样对待用户自定义命令。它能有参数，也可以指定范围。参数
可以进行文件名，缓冲区等补全。具体的工作方式取决于命令的属性，属性在命令被定义
时被指定。

属性可分四大类: 参数处理、补全行为、范围处理和特殊情况。下面分类描述之。

参数处理					<span class="Ignore">*</span><span id="E175" class="String anchor">E175</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E176" class="String anchor">E176</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:command-nargs</span><span class="Ignore">*</span>

缺省时，用户自定义命令不接受参数 (如果使用了任何参数会报错)。但通过使用 -nargs
属性可以允许命令接受参数。有效的值为:

	-nargs=0    不允许有参数 (缺省情况)
	-nargs=1    要求一个参数，包括空格
	-nargs=*    允许任何数目的参数 (0，1 或更多)，以空格分隔
	-nargs=?    允许 0 或 1 个参数
	-nargs=+    必需给出参数，但是数目任意

此上下文中，(未转义的) 空格或制表用来分隔参数，除非指定只有一个参数，此时空格
认为是参数的一部分。

注意 参数被作为文本使用，不是表达式。特别是，&quot;s:var&quot; 会使用定义命令的脚本的局
部变量，不是执行时的！例如:
    script1.vim:<span class="Ignore"> &gt;</span>
<span class="Comment">	:let s:error = &quot;None&quot;</span>
<span class="Comment">	:command -nargs=1 Error echoerr &lt;args&gt;</span>
<span class="Ignore">&lt;</span>   script2.vim:<span class="Ignore"> &gt;</span>
<span class="Comment">	:source script1.vim</span>
<span class="Comment">	:let s:error = &quot;Wrong!&quot;</span>
<span class="Comment">	:Error s:error</span>
执行 script2.vim 会回显 &quot;None&quot;，不是你想要的！解决方法可以通过调用函数实现。

自动补全行为					<span class="Ignore">*</span><span class="String">:command-completion</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E179" class="String anchor">E179</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span id="E180" class="String anchor">E180</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E181" class="String anchor">E181</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:command-complete</span><span class="Ignore">*</span>
缺省时，用户定义命令的参数不进行自动补全。但是，通过指定以下的一个或多个属性
后，参数可以进行自动补全:

	-complete=augroup	自动命令组
	-complete=buffer	缓冲区名
	-complete=behave	:behave 子选项
	-complete=color		颜色方案
	-complete=command	Ex 命令 (及其参数)
	-complete=compiler	编译器
	-complete=cscope	<span class="Ignore">|</span><span class="Identifier">:cscope</span><span class="Ignore">|</span> 子选项
	-complete=dir		目录名
	-complete=environment	环境变量名
	-complete=event		自动命令事件
	-complete=expression	Vim 表达式
	-complete=file		文件和目录名
	-complete=file_in_path	<span class="Ignore">|</span><span class="Identifier">'path'</span><span class="Ignore">|</span> 中的文件和目录名
	-complete=filetype	文件类型名 <span class="Ignore">|</span><span class="Identifier">'filetype'</span><span class="Ignore">|</span>
	-complete=function	函数名
	-complete=help		帮助主题
	-complete=highlight	高亮组
	-complete=history	<span class="Ignore">|</span><span class="Identifier">:history</span><span class="Ignore">|</span> 子选项
	-complete=locale	locale 名 (和 locale -a 给出的相同)
	-complete=mapping	映射名
	-complete=menu		菜单
	-complete=messages	<span class="Ignore">|</span><span class="Identifier">:messages</span><span class="Ignore">|</span> 子选项
	-complete=option	选项
	-complete=packadd	可选包 <span class="Ignore">|</span><a href="repeat.html#pack-add"><span class="Identifier">pack-add</span></a><span class="Ignore">|</span> 名
	-complete=shellcmd	外壳命令
	-complete=sign		<span class="Ignore">|</span><span class="Identifier">:sign</span><span class="Ignore">|</span> 子选项
	-complete=syntax	语法文件名 <span class="Ignore">|</span><span class="Identifier">'syntax'</span><span class="Ignore">|</span>
	-complete=syntime	<span class="Ignore">|</span><span class="Identifier">:syntime</span><span class="Ignore">|</span> 子选项
	-complete=tag		标签
	-complete=tag_listfiles	标签，但敲入 <span class="Special">CTRL-D</span> 时显示文件名
	-complete=user		用户名
	-complete=var		用户变量
	-complete=custom,<span class="Special">{func}</span> 用户定制的自动补全，通过 <span class="Special">{func}</span> 来定义
	-complete=customlist,<span class="Special">{func}</span> 用户定制的自动补全，通过 <span class="Special">{func}</span> 来定义

备注: 部分补全方法可能会扩展环境变量。

用户定制的自动补全		 	<span class="Ignore">*</span><span class="String">:command-completion-custom</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span class="String">:command-completion-customlist</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span id="E467" class="String anchor">E467</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E468" class="String anchor">E468</span><span class="Ignore">*</span>
通过 &quot;custom,<span class="Special">{func}</span>&quot; 或 &quot;customlist,<span class="Special">{func}</span>&quot; 自动补全参数可以定义定制的自动补全
方案。其中 <span class="Special">{func}</span> 是有如下声明的函数:

	:function <span class="Special">{func}</span>(ArgLead，CmdLine，CursorPos)

该函数不需要使用所有的这些参数，它应该提供自动补全候选作为返回值，

对于 &quot;custom&quot; 参数，函数应该返回字符串，每行一个候选，用换行符分隔。

对于 &quot;customlist&quot; 参数，函数应该返回 Vim 列表形式的补全候选。忽略列表里的非字
符串项目。

该函数的参数是:
	ArgLead		当前自动补全的前导参数
	CmdLine		完整的命令行
	CursorPos	里面的光标位置 (字节位置)
该函数可能要根据这些来判别上下文。对 &quot;custom&quot; 参数，它无须用 ArgLead (里面的隐
式规则) 来过滤候选。在函数返回时 Vim 将用它的正则表达式引擎来进行过滤，这种方
式在大多数情况下效率更高。对于 &quot;customlist&quot; 参数，Vim 不会过滤返回的补全候选，
用户提供的函数应该自己过滤候选。

以下的例子为列出 Finger 命令的用户名<span class="Ignore"> &gt;</span>
<span class="Comment">    :com -complete=custom,ListUsers -nargs=1 Finger !finger &lt;args&gt;</span>
<span class="Comment">    :fun ListUsers(A,L,P)</span>
<span class="Comment">    :    return system(&quot;cut -d: -f1 /etc/passwd&quot;)</span>
<span class="Comment">    :endfun</span>

下例从 <span class="Type">'path'</span> 选项指定的目录补全文件名:<span class="Ignore"> &gt;</span>
<span class="Comment">    :com -nargs=1 -bang -complete=customlist,EditFileComplete</span>
<span class="Comment">			\ EditFile edit&lt;bang&gt; &lt;args&gt;</span>
<span class="Comment">    :fun EditFileComplete(A,L,P)</span>
<span class="Comment">    :    return split(globpath(&amp;path, a:A), &quot;\n&quot;)</span>
<span class="Comment">    :endfun</span>
<span class="Ignore">&lt;</span>
此例不适用于带空格的文件名！

范围处理				<span class="Ignore">*</span><span id="E177" class="String anchor">E177</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E178" class="String anchor">E178</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:command-range</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">:command-count</span><span class="Ignore">*</span>
缺省时，用户定义的命令不接受一个行号范围。不过，可以使命令接受一个范围 (-range
属性)，或者接受一个任意的数量值，该数量可以出现在指定行号的位置 (-range=<span class="Special">N</span>，类
似于 <span class="Ignore">|</span><span class="Identifier">:split</span><span class="Ignore">|</span> 命令的风格)，也可以来自一个 &quot;count&quot; 参数 (-count=<span class="Special">N</span>，类似于
<span class="Ignore">|</span><span class="Identifier">:Next</span><span class="Ignore">|</span> 命令的风格)。此时计数可以用 <span class="Ignore">|</span><span class="Identifier">&lt;count&gt;</span><span class="Ignore">|</span> 从参数里得到。

可能的属性有:

	-range	    允许使用范围，缺省为当前行
	-range=%    允许使用范围，缺省是整个文件 (1,$)
	-range=<span class="Special">N</span>    出现在行号位置的一个数量 (缺省是 <span class="Special">N</span>) (类似于 <span class="Ignore">|</span><span class="Identifier">:split</span><span class="Ignore">|</span>)；允
		    许行号为零。
	-count=<span class="Special">N</span>    出现在行号位置或者作为首个参数的一个数量 (缺省是 <span class="Special">N</span>) (类似
		    于 <span class="Ignore">|</span><span class="Identifier">:Next</span><span class="Ignore">|</span>)。
		    指定 -count (不设缺省值) 等价于 -count=0。

注意 -range=<span class="Special">N</span> 和 -count=<span class="Special">N</span> 是互斥的，只应该指定其中的一个。

					<span class="Ignore">*</span><span class="String">:command-addr</span><span class="Ignore">*</span>
范围中的特殊字符如 .、$ 或 % 缺省对应当前行、末行和整个缓冲区，但可使之对应参
数列表、(已载入的) 缓冲区、窗口或标签页。

可能值有:
	-addr=lines		行的范围 (这是缺省)
	-addr=arguments		参数的范围
	-addr=buffers		缓冲区的范围 (也包括未载入的缓冲区)
	-addr=loaded_buffers	载入缓冲区的范围
	-addr=windows		窗口的范围
	-addr=tabs		标签页的范围

特殊情况				<span class="Ignore">*</span><span class="String">:command-bang</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:command-bar</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span class="String">:command-register</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:command-buffer</span><span class="Ignore">*</span>
有如下特殊情况:

	-bang	    这些命令可以使用一个 ! 修饰符 (和 :q 或 :w 类似)
	-bar	    这些命令可以跟随一个 &quot;|&quot; 和其它命令。那么命令参数中就
		    不允许有 &quot;|&quot; 。用一个 &quot; 可以开始一个注释。
	-register   给这些命令的第一个参数可以是一个可选的寄存器名
		    (和 :del，:put，:yank 类似)。
	-buffer	    这些命令仅在当前缓冲区里有效。

-count 和 -register 属性的情况，如果提供了可选的参数，它会被从参数列表中删除，
并且和替换文本分别处理。
注意 这些参数可以简写，但这是已淘汰的功能，新脚本里请用全名。

替换文本

用户自定义命令的替换文本扫描使用 &lt;...&gt; 记法的特殊转义序列。命令行输入的值中，
转义序列被替换，其它文本不变。最终字符串被作为 Ex 命令来执行。要避免替换，使用
<span class="Special">&lt;lt&gt;</span> 代替初始的 &lt;。这样，要按本义包含 &quot;<span class="Special">&lt;bang&gt;</span>&quot;，请使用 &quot;<span class="Special">&lt;lt&gt;</span>bang&gt;&quot;。

有效的转义序列有

						<span class="Ignore">*</span><span class="String">&lt;line1&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;line1&gt;</span>	命令处理范围的开始行。
						<span class="Ignore">*</span><span class="String">&lt;line2&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;line2&gt;</span>	命令处理范围的末尾行。
						<span class="Ignore">*</span><span class="String">&lt;count&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;count&gt;</span>	提供的数量 (在 '-range' 和 '-count' 属性中描述)。
						<span class="Ignore">*</span><span class="String">&lt;bang&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;bang&gt;</span>	(参考 '-bang' 属性) 如果命令执行时带了 ! 修饰符，扩展为 !，否
		则什么也不扩展。
						<span class="Ignore">*</span><span class="String">&lt;mods&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;mods&gt;</span>  如果指定，命令修饰符。否则不扩展。支持以下修饰符
		<span class="Ignore">|</span><span class="Identifier">:aboveleft</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:belowright</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">:botright</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:browse</span><span class="Ignore">|</span>、
		<span class="Ignore">|</span><span class="Identifier">:confirm</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:hide</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">:keepalt</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">:keepjumps</span><span class="Ignore">|</span>、
		<span class="Ignore">|</span><span class="Identifier">:keepmarks</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:keeppatterns</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:leftabove</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">:lockmarks</span><span class="Ignore">|</span>、
		<span class="Ignore">|</span><span class="Identifier">:noswapfile</span><span class="Ignore">|</span> <span class="Ignore">|</span><span class="Identifier">:rightbelow</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:silent</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:tab</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">:topleft</span><span class="Ignore">|</span>、
		<span class="Ignore">|</span><span class="Identifier">:verbose</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:vertical</span><span class="Ignore">|</span>。
		注意  现在还不支持: <span class="Ignore">|</span><span class="Identifier">:noautocmd</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:sandbox</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:unsilent</span><span class="Ignore">|</span>。
		示例:<span class="Ignore"> &gt;</span>
<span class="Comment">		    command! -nargs=+ -complete=file MyEdit</span>
<span class="Comment">				\ for f in expand(&lt;q-args&gt;, 0, 1) |</span>
<span class="Comment">				\ exe '&lt;mods&gt; split ' . f |</span>
<span class="Comment">				\ endfor</span>

<span class="Comment">		    function! SpecialEdit(files, mods)</span>
<span class="Comment">			for f in expand(a:files, 0, 1)</span>
<span class="Comment">			    exe a:mods . ' split ' . f</span>
<span class="Comment">			endfor</span>
<span class="Comment">		    endfunction</span>
<span class="Comment">		    command! -nargs=+ -complete=file Sedit</span>
<span class="Comment">				\ call SpecialEdit(&lt;q-args&gt;, &lt;q-mods&gt;)</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span class="String">&lt;reg&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">&lt;register&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;reg&gt;</span>	(参考 '-register' 属性) 如果命令行上指定，可选的寄存器名。否则
		什么也不扩展。<span class="Special">&lt;register&gt;</span> 是它的一个同义词。
						<span class="Ignore">*</span><span class="String">&lt;args&gt;</span><span class="Ignore">*</span>
	<span class="Special">&lt;args&gt;</span>	命令的参数，和实际提供的完全相同 (但正如上面提到过的，数量或寄
		存器会消耗若干参数，它们不再是 <span class="Special">&lt;args&gt;</span> 的一部分)。
	<span class="Special">&lt;lt&gt;</span>	一个单独的 '&lt;' (小于号) 字符。扩展转义序列时，如果需要以上转义
		序列按字面意义出现的版本时有用。- 例如，要获得 <span class="Special">&lt;bang&gt;</span>，使用
		<span class="Special">&lt;lt&gt;</span>bang&gt;。

							<span class="Ignore">*</span><span class="String">&lt;q-args&gt;</span><span class="Ignore">*</span>
如果一个转义序列的最前两个字符是 &quot;q-&quot; (例如，<span class="Special">&lt;q-args&gt;</span>) 那么该值用引号括起，使
之在表达式里使用时成为合法的值。这种方式把参数当做单个值。如果没有参数，
<span class="Special">&lt;q-args&gt;</span> 是空字符串。
							<span class="Ignore">*</span><span class="String">&lt;f-args&gt;</span><span class="Ignore">*</span>
要允许命令把参数传送给用户定义的函数，有一种特殊的形式 <span class="Special">&lt;f-args&gt;</span> (&quot;function
args&quot;，函数参数)。它在空格和制表处分割命令行参数，每个参数分别用引号括起，然后
把 <span class="Special">&lt;f-args&gt;</span> 序列替换为括起参数用逗号分隔的列表。参考下面的 Mycmd 示例。没有参
数时，<span class="Special">&lt;f-args&gt;</span> 被删除。
   要在 <span class="Special">&lt;f-args&gt;</span> 的参数中嵌入空白字符，在前面加上反斜杠。<span class="Special">&lt;f-args&gt;</span> 把每对反斜杠
(\\) 用单个反斜杠替代。反斜杠后如跟非空白或反斜杠字符，保持不变。总览如下:

	<span class="PreProc">命令		   &lt;f-args&gt;</span><span class="Ignore"> ~</span>
	XX ab		   <span class="Type">'ab'</span>
	XX a\b		   'a\b'
	XX a\ b		   'a b'
	XX a\  b	   'a ', 'b'
	XX a\\b		   'a\b'
	XX a\\ b	   'a\', 'b'
	XX a\\\b	   'a\\b'
	XX a\\\ b	   'a\ b'
	XX a\\\\b	   'a\\b'
	XX a\\\\ b	   'a\\', 'b'

示例<span class="Ignore"> &gt;</span>

<span class="Comment">   &quot; 删除从这里到末尾的所有东西</span>
<span class="Comment">   :com Ddel +,$d</span>

<span class="Comment">   &quot; 把当前缓冲区改名</span>
<span class="Comment">   :com -nargs=1 -bang -complete=file Ren f &lt;args&gt;|w&lt;bang&gt;</span>

<span class="Comment">   &quot; 用一个文件的内容来替换某个范围内的内容</span>
<span class="Comment">   &quot; (请用一行输入本命令)</span>
<span class="Comment">   :com -range -nargs=1 -complete=file</span>
<span class="Comment">	 Replace &lt;line1&gt;-pu_|&lt;line1&gt;,&lt;line2&gt;d|r &lt;args&gt;|&lt;line1&gt;d</span>

<span class="Comment">   &quot; 计算范围内的行数</span>
<span class="Comment">   :com! -range -nargs=0 Lines  echo &lt;line2&gt; - &lt;line1&gt; + 1 &quot;lines&quot;</span>

<span class="Comment">   &quot; 调用一个用户函数 (&lt;f-args&gt; 的示例)</span>
<span class="Comment">   :com -nargs=* Mycmd call Myfunc(&lt;f-args&gt;)</span>

当执行:<span class="Ignore"> &gt;</span>
<span class="Comment">	:Mycmd arg1 arg2</span>
时，它将调用:<span class="Ignore"> &gt;</span>
<span class="Comment">	:call Myfunc(&quot;arg1&quot;,&quot;arg2&quot;)</span>

<span class="Comment">   :&quot; 一个更实用的例子</span>
<span class="Comment">   :function Allargs(command)</span>
<span class="Comment">   :	let i = 0</span>
<span class="Comment">   :	while i &lt; argc()</span>
<span class="Comment">   :	   if filereadable(argv(i))</span>
<span class="Comment">   :	    execute &quot;e &quot; . argv(i)</span>
<span class="Comment">   :	     execute a:command</span>
<span class="Comment">   :      endif</span>
<span class="Comment">   :      let i = i + 1</span>
<span class="Comment">   :   endwhile</span>
<span class="Comment">   :endfunction</span>
<span class="Comment">   :command -nargs=+ -complete=command Allargs call Allargs(&lt;q-args&gt;)</span>

命令 Allargs 接受任意 Vim 命令作为参数并在参数列表里的所有文件上执行。使用示例
(注意使用 &quot;e&quot; 标志位来忽略错误，以及用 &quot;update&quot; 命令来刷新修改过的缓冲区):
	:Allargs %s/foo/bar/ge|update
它将调用:<span class="Ignore"> &gt;</span>
<span class="Comment">	:call Allargs(&quot;%s/foo/bar/ge|update&quot;)</span>
<span class="Ignore">&lt;</span>
在脚本里定义用户命令时，它可以调用局部于脚本中的函数和使用局部于脚本的映射。用
户调用用户命令时，该命令将运行在定义它的脚本的上下文里，如果一个命令中使用了
<span class="Ignore">|</span><span class="Identifier">&lt;SID&gt;</span><span class="Ignore">|</span>，这一点很重要。

</pre>
<!-- vim: set foldmethod=manual : -->

            </pre>
        </article>
    </div>
    <footer class="site-footer">
        <div class="wrap">
            <div class="footer-content">
              <i>Generated by vimtohtml.rb on </i>
              <a href="http://www.zuiniude.com/vim-zh/usr_toc.html">www.zuiniude.com</a>
            </div>
        </div>
    </footer>
</body>
</html>
