<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/github.com/yuweijun/yuweijun.github.io/vim-zh/pattern.cnx.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="molokai">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #d0d0d0; background-color: #121212; }
body { font-family: monospace; color: #d0d0d0; background-color: #121212; }
* { font-size: 1em; }
.String { color: #afaf87; }
.Type { color: #5fd7ff; }
.Statement { color: #d7005f; font-weight: bold; }
.PreProc { color: #87ff00; }
.Identifier { color: #ff8700; }
.Comment { color: #5f5f5f; }
.Special { color: #5fd7ff; }
.Ignore { color: #808080; background-color: #080808; padding-bottom: 1px; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span class="String">pattern.txt</span><span class="Ignore">*</span>   For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年8月


		  VIM 参考手册    by Bram Moolenaar
		    译者: lang2 <span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>


模式及查找命令					<span class="Ignore">*</span><span class="String">pattern-searches</span><span class="Ignore">*</span>

最基本的东西可以在用户手册的 <span class="Ignore">|</span><span class="Identifier">03.9</span><span class="Ignore">|</span> 节中找到。在 <span class="Ignore">|</span><span class="Identifier">usr_27.txt</span><span class="Ignore">|</span> 也有一些解释。

1. 查找命令			<span class="Ignore">|</span><span class="Identifier">search-commands</span><span class="Ignore">|</span>
2. 匹配模式的定义		<span class="Ignore">|</span><span class="Identifier">search-pattern</span><span class="Ignore">|</span>
3. 魔术				<span class="Ignore">|</span><span class="Identifier">/magic</span><span class="Ignore">|</span>
4. 模式项总览			<span class="Ignore">|</span><span class="Identifier">pattern-overview</span><span class="Ignore">|</span>
5. 倍数项			<span class="Ignore">|</span><span class="Identifier">pattern-multi-items</span><span class="Ignore">|</span>
6. 普通匹配原			<span class="Ignore">|</span><span class="Identifier">pattern-atoms</span><span class="Ignore">|</span>
7. 忽略大小写			<span class="Ignore">|</span><span class="Identifier">/ignorecase</span><span class="Ignore">|</span>
8. 合成用字符			<span class="Ignore">|</span><span class="Identifier">patterns-composing</span><span class="Ignore">|</span>
9. 与 Perl 匹配模式的比较	<span class="Ignore">|</span><span class="Identifier">perl-patterns</span><span class="Ignore">|</span>
10. 高亮显示匹配		<span class="Ignore">|</span><span class="Identifier">match-highlight</span><span class="Ignore">|</span>

<span class="PreProc">==============================================================================</span>
1. 查找命令					<span class="Ignore">*</span><span class="String">search-commands</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">/</span><span class="Ignore">*</span>
/<span class="Special">{pattern}</span>[/]<span class="Special">&lt;CR&gt;</span>	正向查找第 <span class="Special">[count]</span> 次出现 <span class="Special">{pattern}</span> 的地方
			(<span class="Ignore">|</span><span class="Identifier">exclusive</span><span class="Ignore">|</span> 开动作)。

/<span class="Special">{pattern}</span>/<span class="Special">{offset}&lt;CR&gt;</span>	正向查找第 <span class="Special">[count]</span> 次出现 <span class="Special">{pattern}</span> 的地方并向上或下移
			动 <span class="Ignore">|</span><span class="Identifier">{offset}</span><span class="Ignore">|</span> 行。<span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作。

							<span class="Ignore">*</span><span class="String">/&lt;CR&gt;</span><span class="Ignore">*</span>
/<span class="Special">&lt;CR&gt;</span>			正向查找第 <span class="Special">[count]</span> 次出现处，使用上次的模式
			<span class="Ignore">|</span><span class="Identifier">last-pattern</span><span class="Ignore">|</span> 以及上次的 <span class="Ignore">|</span><span class="Identifier">{offset}</span><span class="Ignore">|</span>。

//<span class="Special">{offset}&lt;CR&gt;</span>		正向查找第 <span class="Special">[count]</span> 次出现处，使用上次的模式
			<span class="Ignore">|</span><span class="Identifier">last-pattern</span><span class="Ignore">|</span> 以及新偏移 <span class="Ignore">|</span><span class="Identifier">{offset}</span><span class="Ignore">|</span>。若 <span class="Special">{offset}</span> 为
			空，不使用任何偏移。

							<span class="Ignore">*</span><span class="String">?</span><span class="Ignore">*</span>
?<span class="Special">{pattern}</span>[?]<span class="Special">&lt;CR&gt;</span>	反向查找第 <span class="Special">[count]</span> 次出现 <span class="Special">{pattern}</span> 的地方
			(<span class="Ignore">|</span><span class="Identifier">exclusive</span><span class="Ignore">|</span> 开动作)

?<span class="Special">{pattern}</span>?<span class="Special">{offset}&lt;CR&gt;</span>	反向查找第 <span class="Special">[count]</span> 次出现 <span class="Special">{pattern}</span> 的地方
			并向上或下移动 <span class="Ignore">|</span><span class="Identifier">{offset}</span><span class="Ignore">|</span> 行 <span class="Ignore">|</span><span class="Identifier">linewise</span><span class="Ignore">|</span> 行动作。

							<span class="Ignore">*</span><span class="String">?&lt;CR&gt;</span><span class="Ignore">*</span>
?<span class="Special">&lt;CR&gt;</span>			反向查找第 <span class="Special">[count]</span> 次出现处，使用上次的模式
			<span class="Ignore">|</span><span class="Identifier">last-pattern</span><span class="Ignore">|</span> 以及上次的 <span class="Ignore">|</span><span class="Identifier">{offset}</span><span class="Ignore">|</span>。

??<span class="Special">{offset}&lt;CR&gt;</span>		反向查找第 <span class="Special">[count]</span> 次出现处，使用上次的模式
			<span class="Ignore">|</span><span class="Identifier">last-pattern</span><span class="Ignore">|</span> 以及新偏移 <span class="Ignore">|</span><span class="Identifier">{offset}</span><span class="Ignore">|</span>。若 <span class="Special">{offset}</span> 为
			空，不使用任何偏移。

							<span class="Ignore">*</span><span class="String">n</span><span class="Ignore">*</span>
n			将上次的 &quot;/&quot; 或 &quot;?&quot; 重复 <span class="Special">[count]</span> 次。
			如果光标不移动，搜索重复 count + 1 次。
			<span class="Ignore">|</span><span class="Identifier">last-pattern</span><span class="Ignore">|</span> <span class="Special">{Vi: 无计数}</span>

							<span class="Ignore">*</span><span class="String">N</span><span class="Ignore">*</span>
<span class="Special">N</span>			将上次的 &quot;/&quot; 或 &quot;?&quot; 在相反方向上重复 <span class="Special">[count]</span> 次。
			<span class="Ignore">|</span><span class="Identifier">last-pattern</span><span class="Ignore">|</span> <span class="Special">{Vi: 无计数}</span>

							<span class="Ignore">*</span><span class="String">star</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E348</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E349</span><span class="Ignore">*</span>
*			正向查找第 <span class="Special">[count]</span> 次出现距离当前光标最近的单词的地
			方。用于查找的单词是以下最先符合条件的:
				1. 光标所在的关键字 <span class="Ignore">|</span><span class="Identifier">'iskeyword'</span><span class="Ignore">|</span>
				2. 当前行内的光标后的第一个关键字。
				3. 光标所在的非空白单词
				4. 当前行内的光标后的第一个非空白单词
			只查找整字，就像使用了命令 &quot;/\&lt;keyword\&gt;&quot; 一样。
			(<span class="Ignore">|</span><span class="Identifier">exclusive</span><span class="Ignore">|</span> 开动作) <span class="Special">{Vi 无此功能}</span>
			使用 <span class="Type">'ignorecase'</span>，不使用 <span class="Type">'smartcase'</span>。

							<span class="Ignore">*</span><span class="String">#</span><span class="Ignore">*</span>
#			同 &quot;*&quot;，但反向查找。也可以用磅符号 (字符 163)。如果
			&quot;#&quot; 的功能和退格键一样，试着在启动 Vim 前使用
			&quot;stty erase <span class="Special">&lt;BS&gt;</span>&quot; (<span class="Special">&lt;BS&gt;</span> 是 <span class="Special">CTRL-H</span> 或真的退格键)。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gstar</span><span class="Ignore">*</span>
g*			同 &quot;*&quot;，但不使用 &quot;\&lt;&quot; 和 &quot;\&gt;&quot;。这样查找就会匹配非整字
			的地方。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">g#</span><span class="Ignore">*</span>
g#			同 &quot;#&quot;，但不使用 &quot;\&lt;&quot; 和 &quot;\&gt;&quot;。这样查找就会匹配非整字
			的地方。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gd</span><span class="Ignore">*</span>
gd			跳转 (goto) 至局部声明 (declaration)。当光标下是一个局
			部变量时，此命令会跳转到该变量被声明的地方。
			首先，Vim 会查找当前函数的起始处，就像使用 &quot;[[&quot; 一样。
			如果找不到会停止在第一行。如果找到， Vim 会反向搜索直
			到找到一个空行，然后从这里开始正向查找光标所在的关键
			字，就像使用了 &quot;*&quot; 一样，但看起来象注释的行会被忽略。
			(见 <span class="Type">'comments'</span> 选项)。
			注意 这并非总有效。Vim 不会做语法分析。它仅仅查找关键
			字的匹配。如果头文件也需要搜索的话，可以使用
			<span class="Ignore">|</span><span class="Identifier">include-search</span><span class="Ignore">|</span> 列出的命令。
			这个命令之后，可以使用 <span class="Ignore">|</span><span class="Identifier">n</span><span class="Ignore">|</span> 正向查找下一个匹配 (不能反
			向)。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gD</span><span class="Ignore">*</span>
gD			跳转 (goto) 至全局声明 (Declaration)。当光标下是一个全
			局变量时，此命令会跳转到该变量被声明的地方。此命令和
			&quot;gd&quot; 命令一样，不过查找总是从第一行开始。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">1gd</span><span class="Ignore">*</span>
1gd			同 &quot;gd&quot;，但忽略光标位置前结束的 {} 块里的匹配。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">1gD</span><span class="Ignore">*</span>
1gD			同 &quot;gD&quot;，但忽略光标位置前结束的 {} 块里的匹配。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">CTRL-C</span><span class="Ignore">*</span>
<span class="Special">CTRL-C</span>			中止当前的 (搜索) 命令。在 MS-DOS 上用 <span class="Special">CTRL-Break</span>
			<span class="Ignore">|</span><span class="Identifier">dos-CTRL-Break</span><span class="Ignore">|</span>。
			在普通模式下，任何等待的命令将被终止。

							<span class="Ignore">*</span><span class="String">:noh</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:nohlsearch</span><span class="Ignore">*</span>
:noh[lsearch]		停止 <span class="Type">'hlsearch'</span> 选项的高亮显示。如果再执行查找命令或者
			设定 <span class="Type">'hlsearch'</span> 选项，高亮会自动打开。此命令无法在自动
			命令里使用，因为高亮的状态会在自动命令执行期间自动保存
			和恢复 <span class="Ignore">|</span><span class="Identifier">autocmd-searchpat</span><span class="Ignore">|</span>。
			执行用户函数时也是如此。

如果打开 <span class="Type">'incsearch'</span> 选项，键入查找模式时，即时显示当前的匹配。不过，你还得用
<span class="Special">&lt;CR&gt;</span> 来结束查找命令并将光标定位到显示的匹配。也可以用 <span class="Special">&lt;ESC&gt;</span> 来放弃查找。

如果打开 <span class="Type">'hlsearch'</span>，最后一次查找命令的所有匹配点都会被高亮。用 <span class="Ignore">|</span><span class="Identifier">:nohlsearch</span><span class="Ignore">|</span>
命令来暂停。

如果没找到匹配，会报错: <span class="Ignore">*</span><span class="String">E486</span><span class="Ignore">*</span> Pattern not found
注意 为 Vi 兼容起见，<span class="Ignore">|</span><span class="Identifier">:global</span><span class="Ignore">|</span> 命令会把此错误当作一个普通的消息。<span class="Ignore">|</span><span class="Identifier">:s</span><span class="Ignore">|</span> 命令的
&quot;e&quot; 标志位可用来避免此错误 <span class="Ignore">|</span><span class="Identifier">:s_flags</span><span class="Ignore">|</span>。

					<span class="Ignore">*</span><span class="String">search-offset</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">{offset}</span><span class="Ignore">*</span>
这些命令查找一个指定的模式。而 &quot;/&quot; 和 &quot;?&quot; 命令还可以指定一个额外的偏移量。有两
种偏移: 行偏移和字符偏移。<span class="Special">{Vi 没有字符偏移}</span>

偏移用来指定光标相对于找到的匹配的位置:
    <span class="Special">[num]</span>	<span class="Special">[num]</span> 行向下，第一列
    +<span class="Special">[num]</span>	<span class="Special">[num]</span> 行向下，第一列
    -<span class="Special">[num]</span>	<span class="Special">[num]</span> 行向上，第一列
    e<span class="Special">[+num]</span>	<span class="Special">[num]</span> 字符向右 (从匹配结束 (end) 处算起)
    e<span class="Special">[-num]</span>	<span class="Special">[num]</span> 字符向左 (从匹配结束 (end) 处算起)
    s<span class="Special">[+num]</span>	<span class="Special">[num]</span> 字符向右 (从匹配开始 (start) 处算起)
    s<span class="Special">[-num]</span>	<span class="Special">[num]</span> 字符向左 (从匹配开始 (start) 处算起)
    b<span class="Special">[+num]</span>	<span class="Special">[num]</span> 等价于 s<span class="Special">[+num]</span> (从匹配开始 (begin) 处算起)
    b<span class="Special">[-num]</span>	<span class="Special">[num]</span> 等价于 s<span class="Special">[-num]</span> (从匹配开始 (begin) 处算起)
    ;<span class="Special">{pattern}</span>  开始另一项搜索，见 <span class="Ignore">|</span><span class="Identifier">//;</span><span class="Ignore">|</span>

如果给出了 '-' 或 '+' 但是省略了 <span class="Special">[num]</span>，会使用缺省的 1。
如果使用了 'e' 偏移，查找会成为 <span class="Ignore">|</span><span class="Identifier">inclusive</span><span class="Ignore">|</span> 闭动作 (光标要到达的字符本身会包含
在操作里)。

示例:

<span class="PreProc">模式			光标位置</span><span class="Ignore">	~</span>
/test/+1		&quot;test&quot; 下一行，第一列
/test/e			&quot;test&quot; 的后一个 't'
/test/s+2		&quot;test&quot; 中的 's'
/test/b-3		&quot;test&quot; 前的第三个字符

如果把这些命令之一和一个操作符连用，影响的是查找之前和之后光标位置之间的字符。
然而，如果使用了行偏移，影响的是两光标位置之间的所有整行。

一个演示如何查找一个模式并用另一个单词来更改匹配的例子:<span class="Ignore"> &gt;</span>
<span class="Comment">	/foo&lt;CR&gt;	查找 &quot;foo&quot;</span>
<span class="Comment">	c//e&lt;CR&gt;	修改从当前位置到匹配结尾的部分</span>
<span class="Comment">	bar&lt;Esc&gt;	输入替换文本</span>
<span class="Comment">	//&lt;CR&gt;		跳转到下一个相同匹配的开始</span>
<span class="Comment">	c//e&lt;CR&gt;	修改从当前位置到匹配结尾的部分</span>
<span class="Comment">	beep&lt;Esc&gt;	输入替换文本</span>
<span class="Comment">			等等。</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">//;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E386</span><span class="Ignore">*</span>
一个很特别的偏移是 ';' 后面接另一个查找命令。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">   /test 1/;/test</span>
<span class="Comment">   /test.*/+1;?ing?</span>

其中第一例会先找到下一个出现 &quot;test 1&quot; 的地方，然后寻找在它之后 &quot;test&quot; 的第一次
出现之处。

这就好象接连执行两次查找命令，不同之处在于:
- 它可以被当作操作符之后的单个移动命令。
- 以后的 &quot;n&quot; 或 &quot;<span class="Special">N</span>&quot; 命令基于第一个查找操作。
- 当有错误时光标原地不动。

							<span class="Ignore">*</span><span class="String">last-pattern</span><span class="Ignore">*</span>
最近使用的模式和偏移会被记住。它们可以用来重复查找，而且查找的方向和计数都可以
修改。注意 Vim 会记住两个模式: 一个是普通模式下查找命令用的，另一个是替代命令
&quot;:s&quot; 用的。每次给出一个空白的模式时，都将用到前次使用模式。不过，如果没有前次
搜索模式，如果可以，使用前次替代模式。

<span class="Type">'magic'</span> 选项的值是和最近使用模式本身绑定的。如果你改变了 <span class="Type">'magic'</span>，最近使用模式
的解释方法不会改变。<span class="Type">'ignorecase'</span> 选项就不同。当 <span class="Type">'ignorecase'</span> 的值改变时，该模
式会匹配另外的文本。

如果你设定了 <span class="Type">'hlsearch'</span> 选项，所有最近使用的查找模式的匹配点都会高亮。

要清除最近使用的查找模式:<span class="Ignore"> &gt;</span>
<span class="Comment">	:let @/ = &quot;&quot;</span>
这不会把该模式设置为空串，因为那样会匹配所有的东西。该模式是真的清除了，就象
Vim 刚刚启动一样。

查找通常会跳过那些不移动光标位置的匹配。下一次匹配是开始于下一个字符还是在跳过
那些匹配之后取决于 <span class="Type">'cpoptions'</span> 选项中的 'c' 标志位。见 <span class="Ignore">|</span><span class="Identifier">cpo-c</span><span class="Ignore">|</span>。
	     带 'c' 标志位:   &quot;/...&quot; 前进 1 至 3 个字符
	   不带 'c' 标志位:   &quot;/...&quot; 前进 1 个字符
带 'c' 标志位对应结果难以完全确定，因为查找可以从第一列开始，忽略任何匹配，直
到找到超过光标位置的匹配为止。

如果反向寻找，要是如上所述 <span class="Type">'cpoptions'</span> 里包含了 'c' 标志位的话，从行首开始搜
索，使用光标位置之前的最后一个匹配。

在 Vi 里 &quot;:tag&quot; 命令会将最近查找模式设定为要搜索的标签。除非 <span class="Type">'cpoptions'</span> 选项
中包括 't' 标志位，Vim 不会这样做，前次查找模式仍然被记住。查找模式总被存入查
找历史记录。

如果 <span class="Type">'wrapscan'</span> 选项的值为真 (缺省) 的话，查找会在缓冲区的结尾折返到首部。如果
不为真，反向查找会在开始处停止；正向查找会在结尾处停止。如果该选项为真但找不到
该模式，会给出一个错误信息: &quot;pattern not found&quot;，光标原地不动。如果不为真，取
决于查找的方向是正向还是反向，给出的信息是: &quot;search hit BOTTOM without match&quot;
或者 &quot;search hit TOP without match&quot;。如果该选项为真，当查找折返时会分别显示:
&quot;search hit TOP, continuing at BOTTOM&quot; 或 &quot;search hit BOTTOM, continuing at
TOP&quot;。此时，消息可以用设定 <span class="Type">'shortmess'</span> 选项里的 's' 标志位来关闭。该信息的显示
会使用 'w' 的高亮方法 (缺省: 突出)。

							<span class="Ignore">*</span><span class="String">search-range</span><span class="Ignore">*</span>
用 \%&gt;l 项目，你可以限定 &quot;/&quot; 命令查找的范围。例如，要在行 199 之下行 300 之上
搜索单词 &quot;limit&quot;:<span class="Ignore"> &gt;</span>
<span class="Comment">	/\%&gt;199l\%&lt;300llimit</span>
另见 <span class="Ignore">|</span><span class="Identifier">/\%&gt;l</span><span class="Ignore">|</span>。

另一个方法是使用 &quot;:substitute&quot; 命令并与 'c' 联用。例:<span class="Ignore"> &gt;</span>
<span class="Comment">   :.,300s/Pattern//gc</span>
这个命令会从光标所在处开始查找 &quot;Pattern&quot;，直到第 300 行。在匹配处，你会被提示
键入一个字符。键入 'q' 终止；键入 'n' 找下一个匹配。

&quot;*&quot;，&quot;#&quot;，&quot;g*&quot; 和 &quot;g#&quot; 命令依照以下的次序查找在光标附近的一个单词，使用以下最
先找到的那个:
- 光标所在的关键字。
- 同行的光标右侧的第一个关键字。
- 光标下的第一个字串 (WORD)。
- 同行的光标右侧的第一个字串 (WORD)。
关键字只能包括字母和 <span class="Type">'iskeyword'</span> 中的字符。字串 (WORD) 可以包括任何非空白
(<span class="Special">&lt;Tab&gt;</span> 和／或 <span class="Special">&lt;Space&gt;</span>)。
备注 如果你用十个指头打字的话，这些字符是很容易记住的:
&quot;#&quot; 在你的左手中指上 (向左上查找)；&quot;*&quot; 在你的右手中指上 (向右下查找)。
(不过，这取决于你的键盘布局)。

<span class="PreProc">==============================================================================</span>
2. 模式的定义				<span class="Ignore">*</span><span class="String">search-pattern</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">pattern</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">[pattern]</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span class="String">regular-expression</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">regexp</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">Pattern</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span class="String">E76</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E383</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E476</span><span class="Ignore">*</span>

头一道菜已经在用户手册的第 27 章 <span class="Ignore">|</span><span class="Identifier">usr_27.txt</span><span class="Ignore">|</span> 上过了。

						<span class="Ignore">*</span><span class="String">/bar</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\bar</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/pattern</span><span class="Ignore">*</span>
1. 一个模式 (pattern) 是由 &quot;\|&quot; 分隔开的一个或多个分支 (branch)。它可以匹配其
   中的任何一个分支匹配的文本。例如: &quot;foo\|beep&quot; 可以匹配 &quot;foo&quot; 或 &quot;beep&quot;。如
   果超过一个分支可以匹配，选用其中的第一个。

   pattern ::=	    branch
		或  branch \| branch
		或  branch \| branch \| branch
		等。

						<span class="Ignore">*</span><span class="String">/branch</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\&amp;</span><span class="Ignore">*</span>
2. 一个分支是一个或多个被 &quot;\&amp;&quot; 分隔的邻接。它匹配最后一个邻接，但仅仅当前面所
   的邻接也在同样位置匹配。例:
	&quot;foobeep\&amp;...&quot; 匹配 &quot;foobeep&quot; 中的 &quot;foo&quot;。
	&quot;.*Peter\&amp;.*Bob&quot; 匹配同时包括 &quot;Peter&quot; 和 &quot;Bob&quot; 的一行

   branch ::=	    concat
		或  concat \&amp; concat
		或  concat \&amp; concat \&amp; concat
		等。

						<span class="Ignore">*</span><span class="String">/concat</span><span class="Ignore">*</span>
3. 一个邻接 (concat) 是一或多个相邻的组件 (piece)。它匹配第一个组件，后接第二
   个组件的匹配，等等。例如: &quot;f[0-9]b&quot;，先匹配 &quot;f&quot;，然后是一个数位，接着 &quot;b&quot;。

   concat  ::=	    piece
		或  piece piece
		或  piece piece piece
		等。

						<span class="Ignore">*</span><span class="String">/piece</span><span class="Ignore">*</span>
4. 一个组件是一个匹配原 (atom)，后面可能带一个倍数 (multi)，用来表示该匹配原匹
   配的次数。例如: &quot;a*&quot; 匹配任意个 &quot;a&quot; 组成的序列: &quot;&quot;，&quot;a&quot;，&quot;aa&quot; 等。参见
   <span class="Ignore">|</span><span class="Identifier">/multi</span><span class="Ignore">|</span>。

   piece   ::=	    atom
		或  atom  multi

						<span class="Ignore">*</span><span class="String">/atom</span><span class="Ignore">*</span>
5. 一个匹配原可以是一个很长的条目列表中的一个。许多匹配原用来匹配文本中的一个
   字符，通常是一个普通的字符或字符类。也可以用圆括号来将一个模式变成一个匹配
   原。下面的 &quot;\z(\)&quot; 构造仅用在语法高亮中。

   atom    ::=	    ordinary-atom		<span class="Ignore">|</span><span class="Identifier">/ordinary-atom</span><span class="Ignore">|</span>
		或  \( pattern \)		<span class="Ignore">|</span><span class="Identifier">/\(</span><span class="Ignore">|</span>
		或  \%( pattern \)		<span class="Ignore">|</span><span class="Identifier">/\%(</span><span class="Ignore">|</span>
		或  \z( pattern \)		<span class="Ignore">|</span><span class="Identifier">/\z(</span><span class="Ignore">|</span>


				<span class="Ignore">*</span><span class="String">/\%#=</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">two-engines</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">NFA</span><span class="Ignore">*</span>
Vim 包含两个正规表达式引擎:
1. 老式的基于回溯的引擎，支持所有功能。
2. 新式的 NFA 引擎，对某些模式会快很多，对某些模式可能会变慢。

Vim 会自动为你选择合适的引擎。不过，如果你遇过问题或者想特别指定某一个引擎，可
以在模式开头处加入:

	\%#=0	强制自动选择。仅在 <span class="Type">'regexpengine'</span> 设为非零时才有效果。
	\%#=1	强制使用旧引擎。
	\%#=2	强制使用 NFA 引擎。

也可用 <span class="Type">'regexpengine'</span> 选项改变缺省机制。

			 <span class="Ignore">*</span><span class="String">E864</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E868</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E874</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E875</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E876</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E877</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E878</span><span class="Ignore">*</span>
选择 NFA 引擎时如果遇到未实现的模式部分时，整个模式会不匹配。只用于调试 Vim。

<span class="PreProc">==============================================================================</span>
3. 魔术								<span class="Ignore">*</span><span class="String">/magic</span><span class="Ignore">*</span>

某些字符在模式中是按本义出现的。它们匹配自身。然而，当前面有一个反斜杠时，这些
字符具有特殊的含义。

另外一些字符即使没有反斜杠也代表特殊的意思。它们反而需要一个反斜杠来匹配按本义
出现的自身。

一个字符是否按本义出现取决于 <span class="Type">'magic'</span> 选项以及下面将解释的条目。
							<span class="Ignore">*</span><span class="String">/\m</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\M</span><span class="Ignore">*</span>
使用 &quot;\m&quot; 会使得其后的模式的解释方式就如同设定了 <span class="Type">'magic'</span> 选项一样。而且将忽略
<span class="Type">'magic'</span> 选项的实际值。
使用 &quot;\M&quot; 会使得其后的模式的解释方式就如同设定了 <span class="Type">'nomagic'</span> 选项一样。
							<span class="Ignore">*</span><span class="String">/\v</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\V</span><span class="Ignore">*</span>
使用 &quot;\v&quot; 会使得其后的模式中所有 '0'-'9'，'a'-'z'，'A'-'Z' 和 '_' 之外的字符都
当作特殊字符解释。&quot;very magic&quot;

使用 &quot;\V&quot; 会使得其后的模式中只有反斜杠和终止字符 （/ 或 ?) 有特殊的意义。&quot;very
nomagic&quot;

示例:
<span class="PreProc">在这之后: \v	   \m	    \M	     \V		匹配</span><span class="Ignore"> ~</span>
		<span class="Type">'magic'</span> <span class="Type">'nomagic'</span>
	  $	   $	    $	     \$		匹配行尾
	  .	   .	    \.	     \.		匹配任何字符
	  *	   *	    \*	     \*		前面匹配原的任意次重复
	  ~	   ~	    \~	     \~		最近替代字符串
	  ()	   \(\)     \(\)     \(\)	组成为单个匹配原
	  |	   \|	    \|	     \|		分隔可选分支
	  \a	   \a	    \a	     \a		字母字符
	  \\	   \\	    \\	     \\		反斜杠 (按本义)
	  \.	   \.	    .	     .		英文句号 (按本义)
	  \{	   {	    {	     {		'{'  (按本义)
	  a	   a	    a	     a		'a'  (按本义)

{仅 Vim 支持 \m，\M，\v 和 \V}

建议始终将 <span class="Type">'magic'</span> 选项保持在缺省值 －  <span class="Type">'magic'</span>。这可以避免移植性的麻烦。要使
模式不受该选项值的影响，在模式前面加上 &quot;\m&quot; 或 &quot;\M&quot;。

<span class="PreProc">==============================================================================</span>
4. 模式项总览						<span class="Ignore">*</span><span class="String">pattern-overview</span><span class="Ignore">*</span>
						<span class="Ignore">*</span><span class="String">E865</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E866</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E867</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E869</span><span class="Ignore">*</span>

倍数总览。						<span class="Ignore">*</span><span class="String">/multi</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E61</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E62</span><span class="Ignore">*</span>
更多解释和示例见下，点击链接即可。				<span class="Ignore">*</span><span class="String">E64</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E871</span><span class="Ignore">*</span>

	  <span class="PreProc">倍数</span><span class="Ignore"> ~</span>
     <span class="PreProc">'magic' 'nomagic'	匹配前面的匹配原</span><span class="Ignore"> ~</span>
<span class="Ignore">|</span><span class="Identifier">/star</span><span class="Ignore">|</span>	*	\*	0 或更多	尽可能多
<span class="Ignore">|</span><span class="Identifier">/\+</span><span class="Ignore">|</span>	\+	\+	1 或更多	尽可能多 (*)
<span class="Ignore">|</span><span class="Identifier">/\=</span><span class="Ignore">|</span>	\=	\=	0 或 1		尽可能多 (*)
<span class="Ignore">|</span><span class="Identifier">/\?</span><span class="Ignore">|</span>	\?	\?	0 或 1		尽可能多 (*)

<span class="Ignore">|</span><span class="Identifier">/\{</span><span class="Ignore">|</span>	\<span class="Special">{n,m}</span>	\<span class="Special">{n,m}</span>	n 到 m		尽可能多 (*)
	\<span class="Special">{n}</span>	\<span class="Special">{n}</span>	n		准确 (*)
	\<span class="Special">{n,}</span>	\<span class="Special">{n,}</span>	最少 n		尽可能多 (*)
	\<span class="Special">{,m}</span>	\<span class="Special">{,m}</span>	0 到 m		尽可能多 (*)
	\{}	\{}	0 或更多	尽可能多 (和 * 相同) (*)

<span class="Ignore">|</span><span class="Identifier">/\{-</span><span class="Ignore">|</span>	\<span class="Special">{-n,m}</span>	\<span class="Special">{-n,m}</span>	n 到 m		尽可能少 (*)
	\<span class="Special">{-n}</span>	\<span class="Special">{-n}</span>	n		准确 (*)
	\<span class="Special">{-n,}</span>	\<span class="Special">{-n,}</span>	最少 n		尽可能少 (*)
	\<span class="Special">{-,m}</span>	\<span class="Special">{-,m}</span>	0 到 m		尽可能少 (*)
	\<span class="Special">{-}</span>	\<span class="Special">{-}</span>	0 或更多	尽可能少 (*)

							<span class="Ignore">*</span><span class="String">E59</span><span class="Ignore">*</span>
<span class="Ignore">|</span><span class="Identifier">/\@&gt;</span><span class="Ignore">|</span>	\@&gt;	\@&gt;	1，要求完整的模式匹配 (不能回溯) (*)
<span class="Ignore">|</span><span class="Identifier">/\@=</span><span class="Ignore">|</span>	\@=	\@=	无，但要求匹配 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> (*)
<span class="Ignore">|</span><span class="Identifier">/\@!</span><span class="Ignore">|</span>	\@!	\@!	无，但要求_不_匹配 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> (*)
<span class="Ignore">|</span><span class="Identifier">/\@&lt;=</span><span class="Ignore">|</span>	\@&lt;=	\@&lt;=	无，但要求反向匹配 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> (*)
<span class="Ignore">|</span><span class="Identifier">/\@&lt;!</span><span class="Ignore">|</span>	\@&lt;!	\@&lt;!	无，但要其反向_不_匹配 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> (*)

(*) <span class="Special">{Vi 无此功能}</span>


普通匹配原总览。					<span class="Ignore">*</span><span class="String">/ordinary-atom</span><span class="Ignore">*</span>
更多解释和示例见下，点击链接即可。

          <span class="PreProc">普通匹配原</span><span class="Ignore"> ~</span>
      <span class="PreProc">magic   nomagic	匹配</span><span class="Ignore"> ~</span>
<span class="Ignore">|</span><span class="Identifier">/^</span><span class="Ignore">|</span>	^	^	行首 (在模式起始) <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\^</span><span class="Ignore">|</span>	\^	\^	按本义出现的 '^'
<span class="Ignore">|</span><span class="Identifier">/\_^</span><span class="Ignore">|</span>	\_^	\_^	行首 (用于任何地方) <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/$</span><span class="Ignore">|</span>	$	$	行尾 (在模式结尾) <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\$</span><span class="Ignore">|</span>	\$	\$	按本义出现的 '$'
<span class="Ignore">|</span><span class="Identifier">/\_$</span><span class="Ignore">|</span>	\_$	\_$	行尾 (用于任何地方) <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/.</span><span class="Ignore">|</span>	.	\.	任何单个字符 (不包括换行)
<span class="Ignore">|</span><span class="Identifier">/\_.</span><span class="Ignore">|</span>	\_.	\_.	任何单个字符，包括换行
<span class="Ignore">|</span><span class="Identifier">/\&lt;</span><span class="Ignore">|</span>	\&lt;	\&lt;	单词的起始 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\&gt;</span><span class="Ignore">|</span>	\&gt;	\&gt;	单词的结尾 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\zs</span><span class="Ignore">|</span>	\zs	\zs	任何字符，设定匹配部分起始
<span class="Ignore">|</span><span class="Identifier">/\ze</span><span class="Ignore">|</span>	\ze	\ze	任何字符，设定匹配部分结束
<span class="Ignore">|</span><span class="Identifier">/\%^</span><span class="Ignore">|</span>	\%^	\%^	文件首 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>		<span class="Ignore">*</span><span class="String">E71</span><span class="Ignore">*</span>
<span class="Ignore">|</span><span class="Identifier">/\%$</span><span class="Ignore">|</span>	\%$	\%$	文件尾 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\%V</span><span class="Ignore">|</span>	\%V	\%V	可视区域内 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\%#</span><span class="Ignore">|</span>	\%#	\%#	光标位置 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\%'m</span><span class="Ignore">|</span>	\%'m	\%'m	位置标记 m 的位置 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\%l</span><span class="Ignore">|</span>	\%23l	\%23l	在第 23 行 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\%c</span><span class="Ignore">|</span>	\%23c	\%23c	在第 23 列 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
<span class="Ignore">|</span><span class="Identifier">/\%v</span><span class="Ignore">|</span>	\%23v	\%23v	在虚拟第 23 列 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>

字符类 <span class="Special">{Vi 无此功能}</span>:				<span class="Ignore">*</span><span class="String">/character-classes</span><span class="Ignore">*</span>
      <span class="PreProc">magic   nomagic	匹配</span><span class="Ignore"> ~</span>
<span class="Ignore">|</span><span class="Identifier">/\i</span><span class="Ignore">|</span>	\i	\i	标识符字符 (见 <span class="Type">'isident'</span> 选项)
<span class="Ignore">|</span><span class="Identifier">/\I</span><span class="Ignore">|</span>	\I	\I	同 &quot;\i&quot;，但不包括数字字符
<span class="Ignore">|</span><span class="Identifier">/\k</span><span class="Ignore">|</span>	\k	\k	关键字字符 (见 <span class="Type">'iskeyword'</span> 选项)
<span class="Ignore">|</span><span class="Identifier">/\K</span><span class="Ignore">|</span>	\K	\K	同 &quot;\k&quot;，但不包括数字字符
<span class="Ignore">|</span><span class="Identifier">/\f</span><span class="Ignore">|</span>	\f	\f	文件名字符 (见 <span class="Type">'isfname'</span> 选项)
<span class="Ignore">|</span><span class="Identifier">/\F</span><span class="Ignore">|</span>	\F	\F	同 &quot;\f&quot;，但不包括数字字符
<span class="Ignore">|</span><span class="Identifier">/\p</span><span class="Ignore">|</span>	\p	\p	可显示字符 (见 <span class="Type">'isprint'</span> 选项)
<span class="Ignore">|</span><span class="Identifier">/\P</span><span class="Ignore">|</span>	\P	\P	同 &quot;\p&quot;，但不包括数字字符
<span class="Ignore">|</span><span class="Identifier">/\s</span><span class="Ignore">|</span>	\s	\s	空白字符； <span class="Special">&lt;Space&gt;</span> 和 <span class="Special">&lt;Tab&gt;</span>
<span class="Ignore">|</span><span class="Identifier">/\S</span><span class="Ignore">|</span>	\S	\S	非空白字符: \s 之反
<span class="Ignore">|</span><span class="Identifier">/\d</span><span class="Ignore">|</span>	\d	\d	数位:			<span class="Special">[0-9]</span>
<span class="Ignore">|</span><span class="Identifier">/\D</span><span class="Ignore">|</span>	\D	\D	非数位:			<span class="Special">[^0-9]</span>
<span class="Ignore">|</span><span class="Identifier">/\x</span><span class="Ignore">|</span>	\x	\x	十六进制数位:		<span class="Special">[0-9A-Fa-f]</span>
<span class="Ignore">|</span><span class="Identifier">/\X</span><span class="Ignore">|</span>	\X	\X	非十六进制数位:		<span class="Special">[^0-9A-Fa-f]</span>
<span class="Ignore">|</span><span class="Identifier">/\o</span><span class="Ignore">|</span>	\o	\o	八进制数位:		<span class="Special">[0-7]</span>
<span class="Ignore">|</span><span class="Identifier">/\O</span><span class="Ignore">|</span>	\O	\O	非八进制数位:		<span class="Special">[^0-7]</span>
<span class="Ignore">|</span><span class="Identifier">/\w</span><span class="Ignore">|</span>	\w	\w	单词字符:		<span class="Special">[0-9A-Za-z_]</span>
<span class="Ignore">|</span><span class="Identifier">/\W</span><span class="Ignore">|</span>	\W	\W	非单词字符:		<span class="Special">[^0-9A-Za-z_]</span>
<span class="Ignore">|</span><span class="Identifier">/\h</span><span class="Ignore">|</span>	\h	\h	单词首字符:		<span class="Special">[A-Za-z_]</span>
<span class="Ignore">|</span><span class="Identifier">/\H</span><span class="Ignore">|</span>	\H	\H	非单词首字符:		<span class="Special">[^A-Za-z_]</span>
<span class="Ignore">|</span><span class="Identifier">/\a</span><span class="Ignore">|</span>	\a	\a	英文字母字符:		<span class="Special">[A-Za-z]</span>
<span class="Ignore">|</span><span class="Identifier">/\A</span><span class="Ignore">|</span>	\A	\A	非英文字母字符:		<span class="Special">[^A-Za-z]</span>
<span class="Ignore">|</span><span class="Identifier">/\l</span><span class="Ignore">|</span>	\l	\l	小写字符:		<span class="Special">[a-z]</span>
<span class="Ignore">|</span><span class="Identifier">/\L</span><span class="Ignore">|</span>	\L	\L	非小写字符:		<span class="Special">[^a-z]</span>
<span class="Ignore">|</span><span class="Identifier">/\u</span><span class="Ignore">|</span>	\u	\u	大写字符:		<span class="Special">[A-Z]</span>
<span class="Ignore">|</span><span class="Identifier">/\U</span><span class="Ignore">|</span>	\U	\U	非大写字符		<span class="Special">[^A-Z]</span>
<span class="Ignore">|</span><span class="Identifier">/\_</span><span class="Ignore">|</span>	\_x	\_x	其中 x 可以是以上任意一个字符: 对应字符类加上换行
 (字符类结束)

      <span class="PreProc">magic   nomagic	匹配</span><span class="Ignore"> ~</span>
<span class="Ignore">|</span><span class="Identifier">/\e</span><span class="Ignore">|</span>	\e	\e	<span class="Special">&lt;Esc&gt;</span>
<span class="Ignore">|</span><span class="Identifier">/\t</span><span class="Ignore">|</span>	\t	\t	<span class="Special">&lt;Tab&gt;</span>
<span class="Ignore">|</span><span class="Identifier">/\r</span><span class="Ignore">|</span>	\r	\r	<span class="Special">&lt;CR&gt;</span>
<span class="Ignore">|</span><span class="Identifier">/\b</span><span class="Ignore">|</span>	\b	\b	<span class="Special">&lt;BS&gt;</span>
<span class="Ignore">|</span><span class="Identifier">/\n</span><span class="Ignore">|</span>	\n	\n	行尾符
<span class="Ignore">|</span><span class="Identifier">/~</span><span class="Ignore">|</span>	~	\~	上次给出的替代字符串
<span class="Ignore">|</span><span class="Identifier">/\1</span><span class="Ignore">|</span>	\1	\1	第一个 \(\) 匹配的字符 <span class="Special">{Vi 无此功能}</span>
<span class="Ignore">|</span><span class="Identifier">/\2</span><span class="Ignore">|</span>	\2	\2	如 &quot;\1&quot;，但用第二个 \(\)
	   ...
<span class="Ignore">|</span><span class="Identifier">/\9</span><span class="Ignore">|</span>	\9	\9	如 &quot;\1&quot;，但用第九个 \(\)
								<span class="Ignore">*</span><span class="String">E68</span><span class="Ignore">*</span>
<span class="Ignore">|</span><span class="Identifier">/\z1</span><span class="Ignore">|</span>	\z1	\z1	仅用于语法高亮，见 <span class="Ignore">|</span><span class="Identifier">:syn-ext-match</span><span class="Ignore">|</span>
	   ...
<span class="Ignore">|</span><span class="Identifier">/\z1</span><span class="Ignore">|</span>	\z9	\z9	仅用于语法高亮，见 <span class="Ignore">|</span><span class="Identifier">:syn-ext-match</span><span class="Ignore">|</span>

	x	x	一个没有特殊含义的字符匹配其自身

<span class="Ignore">|</span><span class="Identifier">/[]</span><span class="Ignore">|</span>	[]	\[]	[] 内指定的任何字符之一
<span class="Ignore">|</span><span class="Identifier">/\%[]</span><span class="Ignore">|</span>	\%[]	\%[]	一个可选匹配原的序列

<span class="Ignore">|</span><span class="Identifier">/\c</span><span class="Ignore">|</span>	\c	\c	忽略大小写，不使用 <span class="Type">'ignorecase'</span> 选项
<span class="Ignore">|</span><span class="Identifier">/\C</span><span class="Ignore">|</span>	\C	\C	匹配大小写，不使用 <span class="Type">'ignorecase'</span> 选项
<span class="Ignore">|</span><span class="Identifier">/\Z</span><span class="Ignore">|</span>	\Z	\Z	忽略 Unicode 中的 &quot;组合用字符&quot; 的区别，对于搜索带元音
			的希伯来和阿拉伯文本有用。

      <span class="PreProc">magic   nomagic	匹配</span><span class="Ignore"> ~</span>
<span class="Ignore">|</span><span class="Identifier">/\m</span><span class="Ignore">|</span>	\m	\m	对之后模式中字符打开 <span class="Type">'magic'</span> 选项
<span class="Ignore">|</span><span class="Identifier">/\M</span><span class="Ignore">|</span>	\M	\M	对之后模式中字符关闭 <span class="Type">'magic'</span> 选项
<span class="Ignore">|</span><span class="Identifier">/\v</span><span class="Ignore">|</span>	\v	\v	对之后模式中字符设定 <span class="Type">'magic'</span> 选项为 &quot;very magic&quot;
<span class="Ignore">|</span><span class="Identifier">/\V</span><span class="Ignore">|</span>	\V	\V	对之后模式中字符设定 <span class="Type">'magic'</span> 选项为 &quot;very nomagic&quot;
<span class="Ignore">|</span><span class="Identifier">/\%#=</span><span class="Ignore">|</span>   \%#=1   \%#=1   选择正规表达式引擎 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">/\%d</span><span class="Ignore">|</span>	\%d	\%d	匹配用十进制指定的字符 (如 \%d123)
<span class="Ignore">|</span><span class="Identifier">/\%x</span><span class="Ignore">|</span>	\%x	\%x	匹配用十六进制指定的字符 (如 \%x2a)
<span class="Ignore">|</span><span class="Identifier">/\%o</span><span class="Ignore">|</span>	\%o	\%o	匹配用八进制指定的字符 (如 \%o040)
<span class="Ignore">|</span><span class="Identifier">/\%u</span><span class="Ignore">|</span>	\%u	\%u	匹配指定的多字节字符 (如 \%u20ac)
<span class="Ignore">|</span><span class="Identifier">/\%U</span><span class="Ignore">|</span>	\%U	\%U	匹配指定的巨大多字节字符 (如 \%U12345678)
<span class="Ignore">|</span><span class="Identifier">/\%C</span><span class="Ignore">|</span>	\%C	\%C	匹配任何合成用字符

<span class="PreProc">示例			匹配</span><span class="Ignore"> ~</span>
\&lt;\I\i*		或
\&lt;\h\w*
\&lt;[a-zA-Z_][a-zA-Z0-9_]*
			一个标识符 (例如，在一个 C 程序里)。

\(\.$\|\. \)		一个英文句号后跟 <span class="Special">&lt;EOL&gt;</span> 或一个空格。

[.!?][])&quot;']*\($\|[ ]\)	一个匹配英文句子结尾的模式。几乎和 &quot;)&quot; 的定义相同。

cat\Z			匹配 &quot;cat&quot; 和 &quot;càt&quot; (&quot;a&quot; 后跟 0x0300)
			不匹配 &quot;càt&quot; (字符 0x00e0)，即使它们看起来可能一样。


<span class="PreProc">==============================================================================</span>
5. 倍数项					<span class="Ignore">*</span><span class="String">pattern-multi-items</span><span class="Ignore">*</span>

一个匹配原后面可以跟一个表示该匹配原匹配次数和方式的修饰。这个修饰称为倍数。
在 <span class="Ignore">|</span><span class="Identifier">/multi</span><span class="Ignore">|</span> 可以看到一个综述。

							<span class="Ignore">*</span><span class="String">/star</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\star</span><span class="Ignore">*</span>
*	(在没有设定 <span class="Type">'magic'</span> 时使用 \*)
	匹配 0 或更多个前面的匹配原，尽可能多地匹配。
	<span class="PreProc">示例     'nomagic'	匹配</span><span class="Ignore"> ~</span>
	a*	   a\*		&quot;&quot;、&quot;a&quot;、&quot;aa&quot;、&quot;aaa&quot; 等。
	.*	   \.\*		任意，包括空串，不包括行尾符
	\_.*	   \_.\*	匹配至缓冲区结束
	\_.*END	   \_.\*END	匹配至缓冲区中最后一次出现 &quot;END&quot; 处，包括该
				&quot;END&quot;

	特例: 当 &quot;*&quot; 用在模式的开头或者紧跟在 &quot;^&quot; 之后时，它匹配星号字符。

	要当心，重复匹配 &quot;\_.&quot; 会包括大量的文本，因而可能会花很长时间。例如，
	&quot;\_.*END&quot; 匹配从当前位置开始到文件中最后一次出现 &quot;END&quot; 的地方。因为
	&quot;*&quot; 会尽可能多的匹配，它会先跳过到文件结束前的所有行，然后一次退一个字
	符以查找 &quot;END&quot;。

							<span class="Ignore">*</span><span class="String">/\+</span><span class="Ignore">*</span>
\+	匹配一个或更多前面的匹配原。尽可能多。<span class="Special">{Vi 无此功能}</span>
	<span class="PreProc">例		匹配</span><span class="Ignore"> ~</span>
	^.\+$		任意空行
	\s\+		一个以上的空白字符

							<span class="Ignore">*</span><span class="String">/\=</span><span class="Ignore">*</span>
\=	匹配 0 或 1 个前面的匹配原。尽可能多。<span class="Special">{Vi 无此功能}</span>
	<span class="PreProc">例		匹配</span><span class="Ignore"> ~</span>
	foo\=		&quot;fo&quot; 和 &quot;foo&quot;

							<span class="Ignore">*</span><span class="String">/\?</span><span class="Ignore">*</span>
\?	和 \= 一样。不能和反向查找的 &quot;?&quot; 命令中使用。<span class="Special">{Vi 无此功能}</span>

					<span class="Ignore">*</span><span class="String">/\{</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E60</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E554</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E870</span><span class="Ignore">*</span>
\<span class="Special">{n,m}</span>	匹配 n 至 m 个前面的匹配原。尽可能多
\<span class="Special">{n}</span>	匹配 n 个前面的匹配原
\<span class="Special">{n,}</span>	匹配至少 n 个前面的匹配原。尽可能多
\<span class="Special">{,m}</span>	匹配 0 至 m 个前面的匹配原。尽可能多
\{}	匹配 0 个以上前面的匹配原。尽可能多 (和 * 等价)
							<span class="Ignore">*</span><span class="String">/\{-</span><span class="Ignore">*</span>
\<span class="Special">{-n,m}</span>	匹配 n 至 m 个前面的匹配原。尽可能少
\<span class="Special">{-n}</span>	匹配 n 个前面的匹配原
\<span class="Special">{-n,}</span>	匹配至少 n 个前面的匹配原。尽可能少
\<span class="Special">{-,m}</span>	匹配 0 至 m 个前面的匹配原。尽可能少
\<span class="Special">{-}</span>	匹配 0 个以上前面的匹配原。尽可能少
	<span class="Special">{Vi 没有这些}</span>

	n 和 m 是正的十进制数或零
								<span class="Ignore">*</span><span class="String">non-greedy</span><span class="Ignore">*</span>
	如果一个 &quot;-&quot; 紧接在 &quot;{&quot; 之后，那么最短匹配优先算法将启用 (见下面的例
	子)。特别的，&quot;\<span class="Special">{-}</span>&quot; 和 &quot;*&quot; 一样，但使用最短匹配优先算法。_不过_，更早
	开始的匹配比更短的匹配优先: &quot;a\<span class="Special">{-}</span>b&quot; 匹配 &quot;xaaab&quot; 中的 &quot;aaab&quot;。

	<span class="PreProc">示例			匹配</span><span class="Ignore"> ~</span>
	ab\<span class="Special">{2,3}</span>c		&quot;abbc&quot; 或 &quot;abbbc&quot;
	a\<span class="Special">{5}</span>			&quot;aaaaa&quot;
	ab\<span class="Special">{2,}</span>c		&quot;abbc&quot;、&quot;abbbc&quot;、&quot;abbbbc&quot; 等
	ab\<span class="Special">{,3}</span>c		&quot;ac&quot;、&quot;abc&quot;、&quot;abbc&quot; 或 &quot;abbbc&quot;
	a[bc]\<span class="Special">{3}</span>d		&quot;abbbd&quot;、&quot;abbcd&quot;、&quot;acbcd&quot;、&quot;acccd&quot; 等。
	a\(bc\)\<span class="Special">{1,2}</span>d		&quot;abcd&quot; 或 &quot;abcbcd&quot;
	a[bc]\<span class="Special">{-}</span>[cd]		&quot;abcd&quot; 中的 &quot;abc&quot;
	a[bc]*[cd]		&quot;abcd&quot; 中的 &quot;abcd&quot;

	} 之前可以加 (也可以不加) 一个反斜杠: \{n,m\}。

							<span class="Ignore">*</span><span class="String">/\@=</span><span class="Ignore">*</span>
\@=	零宽度匹配前面的匹配原。<span class="Special">{Vi 无此功能}</span>
	类似于 Perl 中的 &quot;(?=pattern)&quot;。
	<span class="PreProc">示例			匹配</span><span class="Ignore"> ~</span>
	foo\(bar\)\@=		&quot;foobar&quot; 中的 &quot;foo&quot;
	foo\(bar\)\@=foo	空
							<span class="Ignore">*</span><span class="String">/zero-width</span><span class="Ignore">*</span>
	&quot;\@=&quot; (或 &quot;^&quot;，&quot;$&quot;，&quot;\&lt;&quot;，&quot;\&gt;&quot;) 的匹配不包括任何字符。这些字符仅仅是用
	来检查匹配是否存在。这很容易搞错，因为后续的项会在同样位置作匹配。上面
	的最后一个例子不会匹配 &quot;foobarfoo&quot;，因为 Vim 会尝试在 &quot;bar&quot; 匹配的同样
	地方匹配 &quot;foo&quot;。

	注意 使用 &quot;\&amp;&quot; 同使用 &quot;\@=&quot; 是一样的: &quot;foo\&amp;..&quot; 等于 &quot;\(foo\)\@=..&quot;。
	但用 &quot;\&amp;&quot; 容易些，你可以省了那些括号。


							<span class="Ignore">*</span><span class="String">/\@!</span><span class="Ignore">*</span>
\@!	零宽度否匹配，亦即，要求前面的匹配原在当前位置_不_匹配。
	<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> <span class="Special">{Vi 无此功能}</span>
	类似于 Perl 中的 &quot;(?!pattern)&quot;。
	<span class="PreProc">示例			匹配</span><span class="Ignore"> ~</span>
	foo\(bar\)\@!		任意后面不带 &quot;bar&quot; 的 &quot;foo&quot;
	a.\<span class="Special">{-}</span>p\@!		&quot;a&quot;，&quot;ap&quot;，&quot;app&quot;，&quot;appp&quot; 等。后面不带 &quot;p&quot;
	if \(\(then\)\@!.\)*$	&quot;if &quot; 后面无跟随 &quot;then&quot;

	使用 &quot;\@!&quot; 要小心，因为很多地方一个模式可以不匹配。&quot;a.*p\@!&quot; 会匹配一
	个 &quot;a&quot; 直到行尾，因为 &quot;.*&quot; 匹配所有行内的字符，而 &quot;p&quot; 不在行尾匹配。
	&quot;a.\<span class="Special">{-}</span>p\@!&quot; 则可以匹配 &quot;a&quot;，&quot;ap&quot;，&quot;app&quot; 等中的一项，只要它们不再紧跟
	另外一个 &quot;p&quot;，这是因为 &quot;.&quot; 可以匹配 &quot;p&quot; 而 &quot;p\@!&quot; 不匹配这个 &quot;p&quot; 的后
	面。

	你不能用 &quot;\@!&quot; 去寻找匹配所在位置之前的否匹配。&quot;\(foo\)\@!bar&quot; 会匹配
	&quot;foobar&quot; 中的 &quot;bar&quot;，因为在 &quot;bar&quot; 匹配的位置上，&quot;foo&quot; 并不匹配。如果
	不想匹配 &quot;foobar&quot;，你可以尝试 &quot;\(foo\)\@!...bar&quot;，但它不能匹配在行首出
	现的 &quot;bar&quot;。最好的方法是用 &quot;\(foo\)\@&lt;!bar&quot;。

	有用的例子: 要找到包含 &quot;foo&quot; 但没有 &quot;bar&quot; 的行:<span class="Ignore"> &gt;</span>
<span class="Comment">		/^\%(.*bar\)\@!.*\zsfoo</span>
<span class="Ignore">&lt;</span>	此模式先检查某行中没有一个位置可以匹配 &quot;bar&quot;。如果 &quot;.*bar&quot; 匹配，\@!
	会拒绝本模式。否则，继续寻找 &quot;foo&quot;。&quot;\zs&quot; 使得匹配从 &quot;foo&quot; 处开始。

							<span class="Ignore">*</span><span class="String">/\@&lt;=</span><span class="Ignore">*</span>
\@&lt;=	零宽度反向匹配。要求前面的匹配原紧贴在后面的模式之前匹配。
	<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> <span class="Special">{Vi 无此功能}</span>
	类似于 Perl 的 &quot;(?&lt;=pattern)&quot;，但是 Vim 允许使用非固定宽度的模式。
	<span class="PreProc">示例			匹配</span><span class="Ignore"> ~</span>
	\(an\_s\+\)\@&lt;=file	在 &quot;an&quot; 和若干个空白或者行尾符之后的 &quot;file&quot;。
	为了提高性能，最好避免这个倍数项。可以用 &quot;\zs&quot; 替代 <span class="Ignore">|</span><span class="Identifier">/\zs</span><span class="Ignore">|</span>。要匹配
	上述的示例:
		an\_s\+\zsfile
	反向匹配时至少要设一个限制范围，见下。

	&quot;\@&lt;=&quot; 和 &quot;\@&lt;!&quot; 检查刚好在其后模式匹配点之前出现的匹配文本。理论上，
	这些匹配可以从当前位置之前的任何地方开始，为了限制所需的时间，只有其后
	匹配所在的行和它上一行 (如果有上一行的话) 会被检索。这对大多数的应用来
	说已经足够，而且也不会减慢速度太多。

	在旧的正规表达式引擎里，在 &quot;\@&lt;=&quot; 和 &quot;\@&lt;!&quot; 之后的模式部分其实先被匹
	配，所以不能用 &quot;\1&quot; 之类的结构来引用零宽度匹配原中的 \(\)。反过来倒是
	可以的。
	<span class="PreProc">坏示例				匹配</span><span class="Ignore"> ~</span>
	\%#=1\1\@&lt;=,\([a-z]\+\)		&quot;abc,abc&quot; 里的 &quot;,abc&quot;

	不过，新的正规表达式引擎工作方式不同，最好不要依赖此行为，如果可以避
	免，不要用 \@&lt;=:
	<span class="PreProc">示例				匹配</span><span class="Ignore"> ~</span>
	\([a-z]\+\)\zs,\1		&quot;abc,abc&quot; 里的 &quot;,abc&quot;

\@123&lt;=
	类似于 &quot;\@&lt;=&quot;，但只往回看 123 个字节。这样可以避免去匹配很多已知不会成
	功的但使模式很慢的尝试。例如，要检查紧接 &quot;span&quot; 之前要否有 &quot;&lt;&quot;:
		/&lt;\@1&lt;=span
	这里只须对 &quot;span&quot; 之前一个字节试图匹配 &quot;&lt;&quot;，本来这也是唯一可能的位置。
	如果跨过行边界，此限制相对于该行的行尾。这样，匹配所在行的行首部分不计
	入限制范围 (只是为了简单起见)。
	零相当于无限制。

							<span class="Ignore">*</span><span class="String">/\@&lt;!</span><span class="Ignore">*</span>
\@&lt;!	零宽度反向否匹配，要求前面的匹配原_不_紧贴在其后的模式之前匹配。换而言
	之，如果在当前行或之前的一行中没有任何位置这个匹配原可以匹配而且它的匹
	配文本刚好紧贴在其后模式的匹配点之前。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> <span class="Special">{Vi 无此功能}</span>
	类似于 Perl 的 &quot;(?&lt;!pattern)&quot;，但是 Vim 允许使用非固定宽度的模式。
	该倍数所引用的匹配原必须紧贴在其后匹配之前，所以这个匹配原可以用 &quot;.*&quot;
	结尾。警告: 该倍数项可能会很慢 (因为在匹配之前的许多位置都要被检查)。
	如有可能，请使用限制范围，见下。
	<span class="PreProc">示例			匹配</span><span class="Ignore"> ~</span>
	\(foo\)\@&lt;!bar		任何不在 &quot;foobar&quot; 中的 &quot;bar&quot;
	\(\/\/.*\)\@&lt;!in	不在 &quot;//&quot; 之后 (中间可以有间隔) 的 &quot;in&quot;

\@123&lt;!
	类似于 &quot;\@&lt;!&quot;，但只往回看 123 个字节。这样可以避免去匹配很多已知不会成
	功的但使模式很慢的尝试。

							<span class="Ignore">*</span><span class="String">/\@&gt;</span><span class="Ignore">*</span>
\@&gt;	匹配前面的匹配原时要求完整匹配 (不能回溯)。<span class="Special">{Vi 无此功能}</span>
	类似于 Perl 中的 &quot;(?&gt;pattern)&quot;。
	<span class="PreProc">示例		匹配</span><span class="Ignore"> ~</span>
	\(a*\)\@&gt;a	无 (&quot;a*&quot; 用尽了所有的 &quot;a&quot;，后面不可能再有)

	试图匹配前面的匹配原，就如同匹配一个完整的模式那样。如果以后无法匹配，
	不会用较短的子模式或者任何其它的方法来重试该匹配原。注意观察以下两者的
	不同: &quot;a*b&quot; 和 &quot;a*ab&quot; 都匹配 &quot;aaab&quot;，但是后者中的 &quot;a*&quot; 仅仅匹配前两个
	&quot;a&quot;。&quot;\(a*\)\@&gt;ab&quot; 不会匹配 &quot;aaab&quot;，因为 &quot;a*&quot; 匹配了 &quot;aaa&quot; (尽可能多
	的 &quot;a&quot;)，导致 &quot;ab&quot; 无法匹配。


<span class="PreProc">==============================================================================</span>
6.  普通匹配原					<span class="Ignore">*</span><span class="String">pattern-atoms</span><span class="Ignore">*</span>

一个普通匹配原可能是:

							<span class="Ignore">*</span><span class="String">/^</span><span class="Ignore">*</span>
^	在模式起点或在 &quot;\|&quot;，&quot;\(&quot;，&quot;\%(&quot;，&quot;\n&quot; 之后: 匹配行首；在其它位置匹配
	按本义出现的 '^' 字符。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
	<span class="PreProc">示例		匹配</span><span class="Ignore"> ~</span>
	^beep(		C 函数 &quot;beep&quot; 开始的地方 (很可能)。

							<span class="Ignore">*</span><span class="String">/\^</span><span class="Ignore">*</span>
\^	匹配按本义出现的 '^' 字符。可以用于任何位置。

							<span class="Ignore">*</span><span class="String">/\_^</span><span class="Ignore">*</span>
\_^	匹配行首。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> 可以用于任何位置。
	<span class="PreProc">示例		匹配</span><span class="Ignore"> ~</span>
	\_s*\_^foo	空白字符及空行，后接行首的 &quot;foo&quot;。

							<span class="Ignore">*</span><span class="String">/$</span><span class="Ignore">*</span>
$	在模式终点或 &quot;\|&quot;、&quot;\)&quot; 或 &quot;\n&quot; (打开 <span class="Type">'magic'</span> 的话) 之前: 匹配行尾
	<span class="Special">&lt;EOL&gt;</span>；其它位置，匹配按本义出现的 '$' 字符。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>

							<span class="Ignore">*</span><span class="String">/\$</span><span class="Ignore">*</span>
\$	匹配按本义出现的 '$' 字符。可以用于任何位置。

							<span class="Ignore">*</span><span class="String">/\_$</span><span class="Ignore">*</span>
\_$	匹配行尾。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>  可以用于任何位置。注意: &quot;a\_$b&quot; 永远无法匹
	配，因为 &quot;b&quot; 不能匹配行尾符。可以使用 &quot;a\nb&quot; 代替 <span class="Ignore">|</span><span class="Identifier">/\n</span><span class="Ignore">|</span>。
	<span class="PreProc">示例		匹配</span><span class="Ignore"> ~</span>
	foo\_$\_s*	&quot;foo&quot; 在行尾，后接空白字符及空行

.	(<span class="Type">'nomagic'</span> 的情形: \.)				<span class="Ignore">*</span><span class="String">/.</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\.</span><span class="Ignore">*</span>
	匹配任何单个字符，不包括行尾符。

							<span class="Ignore">*</span><span class="String">/\_.</span><span class="Ignore">*</span>
\_.	匹配任何单个字符或行尾符。当心: &quot;\_.*&quot; 会一直匹配到缓冲区结尾！

							<span class="Ignore">*</span><span class="String">/\&lt;</span><span class="Ignore">*</span>
\&lt;	匹配单词起点: 下一个字符是单词的首字符。<span class="Type">'iskeyword'</span> 选项指定哪些是组成
	单词的字符。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>

							<span class="Ignore">*</span><span class="String">/\&gt;</span><span class="Ignore">*</span>
\&gt;	匹配单词终点: 前一个字符是单词的尾字符。<span class="Type">'iskeyword'</span> 选项指定哪些是组成
	单词的字符。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>

							<span class="Ignore">*</span><span class="String">/\zs</span><span class="Ignore">*</span>
\zs	匹配任何位置，并将匹配起始处置于该处: 下一个字符将是整个匹配的第一个字
	符。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
	例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		&quot;^\s*\zsif&quot;</span>
<span class="Ignore">&lt;</span>	匹配行首的 &quot;if&quot;，忽略前导的空白字符。
	可以使用多次，但实际使用最后一次在匹配的分支里遇到的。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\(.\{-}\zsFab\)\{3}</span>
<span class="Ignore">&lt;</span>	找到第三次出现的 &quot;Fab&quot;。
	不能后跟倍数。 <span class="Ignore">*</span><span class="String">E888</span><span class="Ignore">*</span>
	<span class="Special">{Vi 无此功能}</span> {仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+syntax</span><span class="Ignore">|</span> 特性才可用}
							<span class="Ignore">*</span><span class="String">/\ze</span><span class="Ignore">*</span>
\ze	匹配任何位置，并将匹配结尾处置于该处: 前一个字符将是整个匹配的最后一个
	字符。<span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>
	可以使用多次，但实际使用最后一次在匹配的分支里遇到的。
	例如: &quot;end\ze\(if\|for\)&quot; 匹配 &quot;endif&quot; 和 &quot;endfor&quot; 中的 &quot;end&quot;。
	不能后跟倍数。 <span class="Ignore">|</span><span class="Identifier">E888</span><span class="Ignore">|</span>
	<span class="Special">{Vi 无此功能}</span> {仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+syntax</span><span class="Ignore">|</span> 特性才可用}

						<span class="Ignore">*</span><span class="String">/\%^</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">start-of-file</span><span class="Ignore">*</span>
\%^	匹配文件头。当用于一个字符串时，匹配字符串起始处。<span class="Special">{Vi 无此功能}</span>
	例如，要查找一个文件中首次出现 &quot;VIM&quot; 的地方:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\%^\_.\{-}\zsVIM</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span class="String">/\%$</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">end-of-file</span><span class="Ignore">*</span>
\%$	匹配文件尾。当用于一个字符串时，匹配字符串结束处。<span class="Special">{Vi 无此功能}</span>
	注意 下面的模式不匹配文件中的最后一个 &quot;VIM&quot;:<span class="Ignore"> &gt;</span>
<span class="Comment">		/VIM\_.\{-}\%$</span>
<span class="Ignore">&lt;</span>	它会找到下一个 VIM，因为其后的部分总会匹配。这样才能匹配文件中的最后一
	个 &quot;VIM&quot;:<span class="Ignore"> &gt;</span>
<span class="Comment">		/VIM\ze\(\(VIM\)\@!\_.\)*\%$</span>
<span class="Ignore">&lt;</span>	这里使用了 <span class="Ignore">|</span><span class="Identifier">/\@!</span><span class="Ignore">|</span> 来确定在首个 &quot;VIM&quot; 之后_无法_再次匹配 &quot;VIM&quot;。
	从文件尾部反向搜索会容易些！

						<span class="Ignore">*</span><span class="String">/\%V</span><span class="Ignore">*</span>
\%V	在可视区域内匹配。可视模式停止后，在 <span class="Ignore">|</span><span class="Identifier">gv</span><span class="Ignore">|</span> 将会重新选择的区域内匹配。
	这是一个零宽度 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> 匹配。要确保整个模式都在可视区域里，把本
	匹配原放在匹配模式的开始和刚好结尾之前处，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\%Vfoo.*ba\%Vr</span>
<span class="Ignore">&lt;</span>	这在可视选择只包含 &quot;foo bar&quot; 时，才会匹配。而:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\%Vfoo.*bar\%V</span>
<span class="Ignore">&lt;</span>	这在可视选择区在 &quot;r&quot; 之后继续时，才会匹配 &quot;foo bar&quot;。
	只能用于当前缓冲区。

						<span class="Ignore">*</span><span class="String">/\%#</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">cursor-position</span><span class="Ignore">*</span>
\%#	匹配光标位置。仅对显示于窗口内的缓冲区有效。<span class="Special">{Vi 无此功能}</span>
	警 告: 如果使用了该模式之后光标被移动，结果不再有效，Vim 不会自动更新
	匹配。这对语法高亮和 <span class="Type">'hlsearch'</span> 很重要。换言之: 在光标移动时显示并不因
	此而更新。Vim 只对行被修改 (整行被更新) 或用户使用 <span class="Ignore">|</span><span class="Identifier">CTRL-L</span><span class="Ignore">|</span> 命令时 (整
	个屏幕被更新) 进行更新。例如，要高亮显示光标下的单词:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\k*\%#\k*</span>
<span class="Ignore">&lt;</span>	当设定 <span class="Type">'hlsearch'</span> 时，移动光标并作若干更改，你就能清楚地看到更新在何时
	进行。

						<span class="Ignore">*</span><span class="String">/\%'m</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&lt;'m</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&gt;'m</span><span class="Ignore">*</span>
\%'m	匹配位置标记 m 的位置。
\%&lt;'m	匹配位置标记 m 之前的位置。
\%&gt;'m	匹配位置标记 m 之后的位置。
	例如，高亮位置标记 's 到 'e 的文本:<span class="Ignore"> &gt;</span>
<span class="Comment">		/.\%&gt;'s.*\%&lt;'e..</span>
<span class="Ignore">&lt;</span>	注意 在匹配里需要两个句号来包含位置标记 'e。这是因为 &quot;\%&lt;'e&quot; 匹配 'e
	位置标记之前的字符，而既然它是零宽度匹配 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span>，它并不真正包含
	该字符。
	<span class="Special">{Vi 无此功能}</span>
	警 告: 如果使用模式后移动了位置标记，结果不再有效。Vim 并不自动更新匹
	配。这和 &quot;\%#&quot; 里移动光标的情形类似 <span class="Ignore">|</span><span class="Identifier">/\%#</span><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">/\%l</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&gt;l</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&lt;l</span><span class="Ignore">*</span>
\%23l	匹配指定的行。
\%&lt;23l	匹配指定行的上方 (行号更小)。
\%&gt;23l	匹配指定行的下方 (行号更大)。
	这三个匹配原可以用来匹配缓冲区内的特定行。&quot;23&quot; 可以是任何行号。第一行
	为 1。 <span class="Special">{Vi 无此功能}</span>
	警 告: 当插入和删除行时 Vim 不会自动更新匹配。这意味着语法高亮很快就会
	有问题。
	例如，要高亮显示光标所在行:<span class="Ignore"> &gt;</span>
<span class="Comment">		:exe '/\%' . line(&quot;.&quot;) . 'l.*'</span>
<span class="Ignore">&lt;</span>	当设定 <span class="Type">'hlsearch'</span> 时，移动光标并作若干更改，你就能清楚地看到更新在何时
	进行。

						<span class="Ignore">*</span><span class="String">/\%c</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&gt;c</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&lt;c</span><span class="Ignore">*</span>
\%23c	匹配指定的列。
\%&lt;23c	匹配指定列之前。
\%&gt;23c	匹配指定列之后。
	这三个匹配原可以用来匹配缓冲区或字符串中的特定列。&quot;23&quot; 可以是任何列
	号。第一列为 1。事实上，列以字节计算 (因此对多字节字符来说是不准确
	的)。 <span class="Special">{Vi 无此功能}</span>
	警 告: 当插入和删除字符时 Vim 并不自动更新匹配。这意味着语法高亮很快就
	会有问题。
	例如，要高亮显示光标所在列:<span class="Ignore"> &gt;</span>
<span class="Comment">		:exe '/\%' . col(&quot;.&quot;) . 'c'</span>
<span class="Ignore">&lt;</span>	当设定 <span class="Type">'hlsearch'</span> 时，移动光标并作若干更改，你就能清楚地看到更新在何时
	进行。
	一个匹配第 44 列单个字节的例子:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\%&gt;43c.\%&lt;46c</span>
<span class="Ignore">&lt;</span>	注意: &quot;\%&lt;46c&quot; 匹配第 45 列，而 &quot;.&quot; 匹配 44 列的一个字节。

						<span class="Ignore">*</span><span class="String">/\%v</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&gt;v</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%&lt;v</span><span class="Ignore">*</span>
\%23v	匹配指定虚拟列。
\%&lt;23v	匹配指定虚拟列之前。
\%&gt;23v	匹配指定虚拟列之后。
	这三个匹配原可以用来匹配缓冲区或字符串中指定的虚拟列。如果不是在匹配窗
	口内的缓冲区，使用当前窗口的选项值 (如 <span class="Type">'tabstop'</span>)。
	&quot;23&quot; 可以是任何列号。第一列为 1。
	注意 某些虚拟列位置永远无法被匹配，因为它们在制表符或其它占用超过一个
	屏幕位置的特殊字符的中间某处。<span class="Special">{Vi 无此功能}</span>
	警 告: 当插入和删除字符时 Vim 并不自动更新高亮的匹配。这意味着语法高亮
	很快就会有问题。
	例如，要高亮显示所有位于虚拟第 72 列之后的字符:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\%&gt;72v.*</span>
<span class="Ignore">&lt;</span>	当设定 <span class="Type">'hlsearch'</span> 时，移动光标并作若干更改，你就能清楚地看到更新在何时
	进行。
	要匹配直到第 17 列的文本:<span class="Ignore"> &gt;</span>
<span class="Comment">		/^.*\%17v</span>
<span class="Ignore">&lt;</span>	这里不包括第 17 列，因为这是 <span class="Ignore">|</span><span class="Identifier">/zero-width</span><span class="Ignore">|</span> 匹配。要包含该列，应用:<span class="Ignore"> &gt;</span>
<span class="Comment">		/^.*\%17v.</span>
<span class="Ignore">&lt;</span>	下例同上，但如果第 17 列没有字符也同样匹配:<span class="Ignore"> &gt;</span>
<span class="Comment">		/^.*\%&lt;18v.</span>
<span class="Ignore">&lt;</span>	注意 如果没有 &quot;^&quot; 来锚住首列的匹配，第 17 列也能被高亮:<span class="Ignore"> &gt;</span>
<span class="Comment">		/.*\%17v</span>
<span class="Ignore">&lt;</span>	<span class="Type">'hlsearch'</span> 高亮第 17 列，因为存在另外一个匹配，其中 &quot;.*&quot; 匹配零个字
	符。


字符类: <span class="Special">{Vi 无此功能}</span>
\i	标识符字符 (见 <span class="Type">'isident'</span> 选项)			<span class="Ignore">*</span><span class="String">/\i</span><span class="Ignore">*</span>
\I	同 &quot;\i&quot;，但不包括数字字符			<span class="Ignore">*</span><span class="String">/\I</span><span class="Ignore">*</span>
\k	关键字字符 (见 <span class="Type">'iskeyword'</span> 选项)		<span class="Ignore">*</span><span class="String">/\k</span><span class="Ignore">*</span>
\K	同 &quot;\k&quot;，但不包括数字字符			<span class="Ignore">*</span><span class="String">/\K</span><span class="Ignore">*</span>
\f	文件名字符 (见 <span class="Type">'isfname'</span> 选项)			<span class="Ignore">*</span><span class="String">/\f</span><span class="Ignore">*</span>
\F	同 &quot;\f&quot;，但不包括数字字符			<span class="Ignore">*</span><span class="String">/\F</span><span class="Ignore">*</span>
\p	可显示字符 (见 <span class="Type">'isprint'</span> 选项)			<span class="Ignore">*</span><span class="String">/\p</span><span class="Ignore">*</span>
\P	同 &quot;\p&quot;，但不包括数字字符			<span class="Ignore">*</span><span class="String">/\P</span><span class="Ignore">*</span>

备注: 上面这些适用于多字节字符，而下面只匹配 ASCII 字符，因为它们由范围限定。

						<span class="Ignore">*</span><span class="String">whitespace</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">white-space</span><span class="Ignore">*</span>
\s	空白字符； <span class="Special">&lt;Space&gt;</span> 和 <span class="Special">&lt;Tab&gt;</span>			<span class="Ignore">*</span><span class="String">/\s</span><span class="Ignore">*</span>
\S	非空白字符: \s 之反				<span class="Ignore">*</span><span class="String">/\S</span><span class="Ignore">*</span>
\d	数位:				<span class="Special">[0-9]</span>		<span class="Ignore">*</span><span class="String">/\d</span><span class="Ignore">*</span>
\D	非数位:				<span class="Special">[^0-9]</span>		<span class="Ignore">*</span><span class="String">/\D</span><span class="Ignore">*</span>
\x	十六进制数位:			<span class="Special">[0-9A-Fa-f]</span>	<span class="Ignore">*</span><span class="String">/\x</span><span class="Ignore">*</span>
\X	非十六进制数位:			<span class="Special">[^0-9A-Fa-f]</span>	<span class="Ignore">*</span><span class="String">/\X</span><span class="Ignore">*</span>
\o	八进制数位:			<span class="Special">[0-7]</span>		<span class="Ignore">*</span><span class="String">/\o</span><span class="Ignore">*</span>
\O	非八进制数位:			<span class="Special">[^0-7]</span>		<span class="Ignore">*</span><span class="String">/\O</span><span class="Ignore">*</span>
\w	单词字符:			<span class="Special">[0-9A-Za-z_]</span>	<span class="Ignore">*</span><span class="String">/\w</span><span class="Ignore">*</span>
\W	非单词字符:			<span class="Special">[^0-9A-Za-z_]</span>	<span class="Ignore">*</span><span class="String">/\W</span><span class="Ignore">*</span>
\h	单词首字符:			<span class="Special">[A-Za-z_]</span>	<span class="Ignore">*</span><span class="String">/\h</span><span class="Ignore">*</span>
\H	非单词首字符:			<span class="Special">[^A-Za-z_]</span>	<span class="Ignore">*</span><span class="String">/\H</span><span class="Ignore">*</span>
\a	英文字母字符:			<span class="Special">[A-Za-z]</span>	<span class="Ignore">*</span><span class="String">/\a</span><span class="Ignore">*</span>
\A	非英文字母字符:			<span class="Special">[^A-Za-z]</span>	<span class="Ignore">*</span><span class="String">/\A</span><span class="Ignore">*</span>
\l	小写字符:			<span class="Special">[a-z]</span>		<span class="Ignore">*</span><span class="String">/\l</span><span class="Ignore">*</span>
\L	非小写字符:			<span class="Special">[^a-z]</span>		<span class="Ignore">*</span><span class="String">/\L</span><span class="Ignore">*</span>
\u	大写字符:			<span class="Special">[A-Z]</span>		<span class="Ignore">*</span><span class="String">/\u</span><span class="Ignore">*</span>
\U	非大写字符:			<span class="Special">[^A-Z]</span>		<span class="Ignore">*</span><span class="String">/\U</span><span class="Ignore">*</span>

	备注: 使用匹配原比使用 [] 构造要快。

	备注: 字符类不使用 <span class="Type">'ignorecase'</span>，&quot;\c&quot; 和 &quot;\C&quot; 的设定。

		<span class="Ignore">*</span><span class="String">/\_</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E63</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_i</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_I</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_k</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_K</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_f</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_F</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">/\_p</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_P</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_s</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_S</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_d</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_D</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_x</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_X</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">/\_o</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_O</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_w</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_W</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_h</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_H</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_a</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_A</span><span class="Ignore">*</span>
		<span class="Ignore">*</span><span class="String">/\_l</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_L</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_u</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_U</span><span class="Ignore">*</span>
\_x	其中 x 为上面列出的可用字符之一: 结果为对应字符类加上行尾符
(字符类结束)

\e	匹配 <span class="Special">&lt;Esc&gt;</span>					<span class="Ignore">*</span><span class="String">/\e</span><span class="Ignore">*</span>
\t	匹配 <span class="Special">&lt;Tab&gt;</span>					<span class="Ignore">*</span><span class="String">/\t</span><span class="Ignore">*</span>
\r	匹配 <span class="Special">&lt;CR&gt;</span>					<span class="Ignore">*</span><span class="String">/\r</span><span class="Ignore">*</span>
\b	匹配 <span class="Special">&lt;BS&gt;</span>					<span class="Ignore">*</span><span class="String">/\b</span><span class="Ignore">*</span>
\n	匹配行尾符					<span class="Ignore">*</span><span class="String">/\n</span><span class="Ignore">*</span>
	当对字符串而不是缓冲区进行匹配时，匹配一个按本义出现的换行字符。

~	匹配上次给出的替代字符串			<span class="Ignore">*</span><span class="String">/~</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\~</span><span class="Ignore">*</span>

\(\)	一个由转义的括号括起来的模式。			<span class="Ignore">*</span><span class="String">/\(</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\(\)</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\)</span><span class="Ignore">*</span>
	例: &quot;\(^a\)&quot; 匹配行首的 'a'。
	<span class="Ignore">*</span><span class="String">E51</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E54</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E55</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E872</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E873</span><span class="Ignore">*</span>

\1      匹配和第一个 \( 和 \) 之间的子表达式的匹配文本	<span class="Ignore">*</span><span class="String">/\1</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E65</span><span class="Ignore">*</span>
	相同的字符串。 <span class="Special">{Vi 无此功能}</span>
	例如: &quot;\([a-z]\).\1&quot; 匹配 &quot;ata&quot;，&quot;ehe&quot;，&quot;tot&quot; 等。
\2      类似于 &quot;\1&quot;，但使用第二子表达式，		<span class="Ignore">*</span><span class="String">/\2</span><span class="Ignore">*</span>
<span class="Statement">   ...							</span><span class="Ignore">*</span><span class="String">/\3</span><span class="Ignore">*</span>
\9      类似于 &quot;\1&quot;，但使用第三子表达式。		<span class="Ignore">*</span><span class="String">/\9</span><span class="Ignore">*</span>
	备注: 各组的标号是基于哪一个 &quot;\(&quot; 先出现 (自左至右)，而_非_哪一个先匹
	配。

\%(\)	一个由转义的括号括起来的模式。			<span class="Ignore">*</span><span class="String">/\%(\)</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%(</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E53</span><span class="Ignore">*</span>
	类似 \(\)，但不算作一个子表达式。这样做允许使用更多的群组，并且处理时
	会稍快些。
	<span class="Special">{Vi 无此功能}</span>

x	一个没有特殊含义的单个字符，匹配其自身

							<span class="Ignore">*</span><span class="String">/\</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\\</span><span class="Ignore">*</span>
\x	一个反斜杠带一个没有特殊含义的单个字符，保留作将来的扩展

[]	(<span class="Type">'nomagic'</span> 的情形: \[])		<span class="Ignore">*</span><span class="String">/[]</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\[]</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\_[]</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/collection</span><span class="Ignore">*</span>
\_[]
	一个集合。一组由方括号括起来的字符。匹配集合中的任何一个字符。
	<span class="PreProc">示例		匹配</span><span class="Ignore"> ~</span>
	<span class="Special">[xyz]</span>		'x'、'y' 或 'z' 之一
	<span class="Special">[a-zA-Z]</span>$	出现在行尾的字母字符
	\c[a-z]$	同上
	[Ð&lt;90&gt;-Ñ&lt;8f&gt;Ð&lt;81&gt;Ñ&lt;91&gt;]		俄语字符集 (包括 utf-8 和 cp1251)

								<span class="Ignore">*</span><span class="String">/[\n]</span><span class="Ignore">*</span>
	如果在集合前加上 &quot;\_&quot; 的话，同时匹配行尾符，这等价于给集合加上 &quot;\n&quot;。
	即使该模式以 &quot;^&quot; 开始，也能匹配行尾符！因此 &quot;\_[^ab]&quot; 将匹配行尾符以及
	所有非 &quot;a&quot; 或 &quot;b&quot; 的字符。
	这使其与 Vi 兼容: 没有 &quot;\_&quot; 或 &quot;\n&quot; 时，集合不匹配行尾符。
								<span class="Ignore">*</span><span class="String">E769</span><span class="Ignore">*</span>
	如果没有 ']'，Vim 不会给出错误信息，而是假设不使用集合。可用于直接搜索
	'['。不过内部搜索会得到 E769。同时要注意在 ”:substitute&quot; 命令里，整个
	命令作为模式处理，例如 &quot;:s/[/x/&quot; 搜索 &quot;[/x&quot; 并替换为空，而不是搜索 &quot;[&quot;
	并替换为 &quot;x&quot;！

								<span class="Ignore">*</span><span class="String">E944</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E945</span><span class="Ignore">*</span>
	如果集合以 &quot;^&quot; 开始，它匹配所有_不在_集合内的字符: &quot;[^xyz]&quot; 匹配任何不
	是 'x'、'y' 和 'z' 的字符。
	- 如果集合中的两个字符以 '-' 隔开，表示它们之间的所有 ASCII 字符。例
	  如，&quot;[0-9]&quot; 匹配任何十进制数位。如果开始字符大于结束字符，如 <span class="Special">[c-a]</span>，
	  报错 E944。可以使用非 ASCII 字符，但在旧的正规表达式引擎中字符值的距
	  离不能超过 256。例如设置 re=1 后搜索 [\u3000-\u4000]，会报错 E945。
	  在模式之前加上 \%#=2 可以解决这个问题。
	- 字符类表达式被解释为该字符类代表的字符集合。支持以下字符类:
		  <span class="PreProc">名称        函数	内容</span><span class="Ignore"> ~</span>
<span class="Ignore">*</span><span class="String">[:alnum:]</span><span class="Ignore">*</span>	  [:alnum:]   isalnum	字母和数位
<span class="Ignore">*</span><span class="String">[:alpha:]</span><span class="Ignore">*</span>	  [:alpha:]   isalpha	字母
<span class="Ignore">*</span><span class="String">[:blank:]</span><span class="Ignore">*</span>	  [:blank:]     	空格和制表
<span class="Ignore">*</span><span class="String">[:cntrl:]</span><span class="Ignore">*</span>	  [:cntrl:]   iscntrl	控制字符
<span class="Ignore">*</span><span class="String">[:digit:]</span><span class="Ignore">*</span>	  [:digit:]     	十进制数位 '0' 到 '9'
<span class="Ignore">*</span><span class="String">[:graph:]</span><span class="Ignore">*</span>	  [:graph:]   isgraph	ASCII 可显示字符，不包括空格
<span class="Ignore">*</span><span class="String">[:lower:]</span><span class="Ignore">*</span>	  [:lower:]   (1)	小写字母 (使用 <span class="Type">'ignorecase'</span> 时代表所有
					字母)
<span class="Ignore">*</span><span class="String">[:print:]</span><span class="Ignore">*</span>	  [:print:]   (2)	可显示字符，包括空格
<span class="Ignore">*</span><span class="String">[:punct:]</span><span class="Ignore">*</span>	  [:punct:]   ispunct	ASCII 标点字符
<span class="Ignore">*</span><span class="String">[:space:]</span><span class="Ignore">*</span>	  [:space:]     	空白字符: 空格、制表、CR、NL、垂直制
					表、换页
<span class="Ignore">*</span><span class="String">[:upper:]</span><span class="Ignore">*</span>	  [:upper:]   (3)	大写字母 (使用 <span class="Type">'ignorecase'</span> 时代表所有
					字母)
<span class="Ignore">*</span><span class="String">[:xdigit:]</span><span class="Ignore">*</span>	  [:xdigit:]    	十六进制数位: 0-9、a-f、A-F
<span class="Ignore">*</span><span class="String">[:return:]</span><span class="Ignore">*</span>	  [:return:]		<span class="Special">&lt;CR&gt;</span> 字符
<span class="Ignore">*</span><span class="String">[:tab:]</span><span class="Ignore">*</span>	  [:tab:]		<span class="Special">&lt;Tab&gt;</span> 字符
<span class="Ignore">*</span><span class="String">[:escape:]</span><span class="Ignore">*</span>	  [:escape:]		<span class="Special">&lt;Esc&gt;</span> 字符
<span class="Ignore">*</span><span class="String">[:backspace:]</span><span class="Ignore">*</span>	  [:backspace:]		<span class="Special">&lt;BS&gt;</span> 字符
	  方括号括起的字符类表达式是对于方括号定界的集合的扩充。例如，下面的模
	  式是一个 UNIX 文件名: &quot;[-./[:alnum:]_~]\+&quot;。即至少有一个字符的字符列
	  表，其中字符可以是 '-'，'.'，'/'，字母，数位，'_' 或 '~' 中的一个。
	  这些项仅对 8 位字符有效，但在新的正规表达式引擎里， [:lower:] 和
	  [:upper:] 也可用于多字节字符。见 <span class="Ignore">|</span><span class="Identifier">two-engines</span><span class="Ignore">|</span>。将来，其它项目可能也
	  可用于多字节字符。现在，要得到所有的 “alpha&quot; 字符，可用:
	  [[:lower:][:upper:]]。

	  &quot;函数&quot; 列显示使用的库函数。具体实现取决于系统。否则:
	  (1) 编译时带 <span class="Ignore">|</span><span class="Identifier">+multi_byte</span><span class="Ignore">|</span> 特性时，ASCII 使用 islower()，其它字符使
	  用 Vim 内建规则。
	  (2) 使用 Vim 内建规则
	  (3) 用 (1) 但使用 isupper()
							<span class="Ignore">*</span><span class="String">/[[=</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">[==]</span><span class="Ignore">*</span>
	- 等价类 (equivalence class)。匹配的字符和被比较的字符 &quot;几乎&quot; 相同，但
	  重音的区别可以忽略。目前支持 Unicode、latin1 和 latin9。形式是:
		[=a=]
							<span class="Ignore">*</span><span class="String">/[[.</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">[..]</span><span class="Ignore">*</span>
	- 排序规则元素 (collation element)。目前只能简单地接受如下形式的单个字
	  符:
		[.a.]
							  <span class="Ignore">*</span><span class="String">/\]</span><span class="Ignore">*</span>
	- 要在集合之内包括字符 ']'，^'，'-' 或 '\'，只需在该字符前加上反斜杠
	  &quot;[xyz\]]&quot;，&quot;[\^xyz]&quot;，&quot;[xy\-z]&quot; 和 &quot;[xyz\\]&quot;。
	  (备注: POSIX 不支持这种反斜杠的用法)。
	  对于 ']' 你也可以将其作为第一个字符 (但可能在 &quot;^&quot; 之后) 而无须转义:
	  &quot;[]xyz]&quot; 或 &quot;[^]xyz]&quot;  <span class="Special">{Vi 无此功能}</span>。
	  对于 '-' 你也可以将其作为第一个或最后一个字符: &quot;[-xyz]&quot;，&quot;[^-xyz]&quot;
	  或 &quot;[xyz-]&quot;。
	  对于 '\' 你也可以将其放置在除了 &quot;^]-\bdertnoUux&quot; 以外的任何一个字符
	  之前而无须转义: &quot;[\xyz]&quot; 匹配 '\'，'x'，'y' 及 'z'。但是用 &quot;\\&quot; 好
	  些，因为将来的扩展可能会在 '\' 之后使用其它字符。
	- 省略结尾的 ] 不被视为错误。&quot;[]&quot; 等同于 &quot;[]]&quot;，匹配 ']' 字符。
	- 当 <span class="Type">'cpoptions'</span> 中不包括 'l' 标志位时，以下转义可用 <span class="Special">{Vi 无此功能}</span>:
		\e	<span class="Special">&lt;Esc&gt;</span>
		\t	<span class="Special">&lt;Tab&gt;</span>
		\r	<span class="Special">&lt;CR&gt;</span>	(_不是_行尾符！)
		\b	<span class="Special">&lt;BS&gt;</span>
		\n	换行符，见上 <span class="Ignore">|</span><span class="Identifier">/[\n]</span><span class="Ignore">|</span>
		\d123	字符的十进制表示
		\o40	字符的八进制表示，最大值为 0377
		\x20	字符的十六进制表示，最大值为 0xff
		\u20AC	多字节字符的十六进制表示，最大值为 0xffff
		\U1234	多字节字符的十六进制表示，最大值为 0xffffffff
	  备注: 其它曾在前面提到的反斜杠转义码 (译者注: 如 \s、\d 等)
		在方括号 [] 之内是不起作用的！
	- 用集合来匹配可能会很慢。因为每个字符都要和集合中的每一个字符作比较。
	  尽可能使用上面提到的其它匹配原。例如: 同样是匹配一个数位，&quot;\d&quot; 要比
	  &quot;[0-9]&quot; 快的多。

						<span class="Ignore">*</span><span class="String">/\%[]</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E69</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E70</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E369</span><span class="Ignore">*</span>
\%[]	一个可选匹配原的序列。它总能匹配，但试图匹配尽量多的列出的匹配原，而在
	第一个不匹配的地方终止。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		/r\%[ead]</span>
<span class="Ignore">&lt;</span>	匹配 &quot;r&quot;，&quot;re&quot;，&quot;rea&quot; 或者 &quot;read&quot;。采用最长可能的匹配。下面例子可以用
	来匹配 Ex 命令 &quot;function&quot;，其中 &quot;fu&quot; 是必须的而 &quot;nction&quot; 是可选的:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\&lt;fu\%[nction]\&gt;</span>
<span class="Ignore">&lt;</span>	这里用到了单词结尾匹配原 &quot;\&gt;&quot; 来避免匹配 &quot;full&quot; 中的 &quot;fu&quot;。
	当要匹配的不是普通字符时，问题就变得更复杂了。你不一定会经常这样，但可
	以这么做。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		/\&lt;r\%[[eo]ad]\&gt;</span>
<span class="Ignore">&lt;</span>	匹配 &quot;r&quot;，&quot;re&quot;，&quot;ro&quot;，&quot;rea&quot;，&quot;roa&quot;，&quot;read&quot; 及 &quot;road&quot;。
	[] 里不能有 \(\)、\%(\) 或 \z(\) 项，\%[] 也不能嵌套。
	要包含 &quot;[&quot;，用 &quot;[[]&quot; 而 &quot;]&quot; 则可用 &quot;[]]&quot;，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		/index\%[[[]0[]]]</span>
<span class="Ignore">&lt;</span>	匹配 &quot;index&quot;、&quot;index[&quot;、&quot;index[0&quot; 和 &quot;index[0]&quot;。
	{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+syntax</span><span class="Ignore">|</span> 特性才有效}

				<span class="Ignore">*</span><span class="String">/\%d</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%x</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%o</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%u</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\%U</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E678</span><span class="Ignore">*</span>

\%d123	匹配十进制指定的字符。后面必须跟着非数位。
\%o40	匹配八进制指定的字符，至多 0377。
	小于 040 的数必须后面跟着非八进制的数位或非数位。
\%x2a	匹配不超过两位十六进制数位指定的字符。
\%u20AC	匹配不超过四位十六进制数位指定的字符。
\%U1234abcd	匹配不超过八位十六进制数位指定的字符。

<span class="PreProc">==============================================================================</span>
7. 忽略大小写						<span class="Ignore">*</span><span class="String">/ignorecase</span><span class="Ignore">*</span>

如果选项 <span class="Type">'ignorecase'</span> 打开的话，忽略正常字母的大小写。设定 <span class="Type">'smartcase'</span> 会在模
式只包含小写字母时才忽略大小写。
							<span class="Ignore">*</span><span class="String">/\c</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">/\C</span><span class="Ignore">*</span>
如果模式的任何位置出现了 &quot;\c&quot;，整个模式会象打开 <span class="Type">'ignorecase'</span> 一样处理。真正的
<span class="Type">'ignorecase'</span> 和 <span class="Type">'smartcase'</span> 的值会被忽略。&quot;\C&quot; 的效果恰好相反: 强制对整个模式
匹配大小写。
{仅 Vim 支持 \c 和 \C}
注意 <span class="Type">'ignorecase'</span>，&quot;\c&quot; 和 &quot;\C&quot; 对字符类无效。

例如:
	<span class="PreProc">模式	'ignorecase'  'smartcase'	匹配</span><span class="Ignore"> ~</span>
	foo	  关		-		foo
	foo	  开		-		foo Foo FOO
	Foo	  开		关		foo Foo FOO
	Foo	  开		开		    Foo
	\cfoo	  -		-		foo Foo FOO
	foo\C	  -		-		foo

技术细节:						<span class="Ignore">*</span><span class="String">NL-used-for-Nul</span><span class="Ignore">*</span>
文件中的 <span class="Special">&lt;Nul&gt;</span> 字符在内存中存储为 <span class="Special">&lt;NL&gt;</span>。显示为 &quot;^@&quot;。翻译是在读写文件时完成
的。为了在查找模式中匹配 <span class="Special">&lt;Nul&gt;</span> 你可以使用 <span class="Special">CTRL-@</span> 或 &quot;<span class="Special">CTRL-V</span> 000&quot;。这应该不出你
的所料。在内部，该字符被替换为 <span class="Special">&lt;NL&gt;</span>。不寻常的是键入 <span class="Special">CTRL-V</span> <span class="Special">CTRL-J</span> 同样插入一个
<span class="Special">&lt;NL&gt;</span>，因此也搜索文件中的 <span class="Special">&lt;Nul&gt;</span>。<span class="Special">{Vi 则完全不能处理文件中的 &lt;Nul&gt; 字符}</span>

							<span class="Ignore">*</span><span class="String">CR-used-for-NL</span><span class="Ignore">*</span>
当 <span class="Type">'fileformat'</span> 为 &quot;mac&quot; 时，<span class="Special">&lt;NL&gt;</span> 字符在内部储存为 <span class="Special">&lt;CR&gt;</span>。在文本里显示为 &quot;^J&quot;。
除此以外，和 <span class="Special">&lt;NL&gt;</span> 作为 <span class="Special">&lt;Nul&gt;</span> 的用法类似。

在作表达式求值时，模式中的 <span class="Special">&lt;NL&gt;</span> 字符匹配字符串中的 <span class="Special">&lt;NL&gt;</span>。用 &quot;\n&quot; (反斜杠 n) 来
匹配 <span class="Special">&lt;NL&gt;</span> 在这里是行不通的，它仅对缓冲区内的文本有效。

							<span class="Ignore">*</span><span class="String">pattern-multi-byte</span><span class="Ignore">*</span>
模式匹配对于多字节字符同样适用。大体上使用并无区别，不过要注意无效字节可能引起
的问题，一个包含无效字节的模式永远不会得到匹配。

<span class="PreProc">==============================================================================</span>
8. 合成用字符						<span class="Ignore">*</span><span class="String">patterns-composing</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">/\Z</span><span class="Ignore">*</span>
如果模式的任何位置出现了 &quot;\Z&quot;，所有的合成用字符将被忽略。这时，只比较基本字
符，合成用字符可以不同，其数量也可以不同。这一功能只在 <span class="Type">'encoding'</span> 为 'utf-8'
时有意义。
例外: 如果模式以一或多个合成用字符开始，它们必须匹配。
							<span class="Ignore">*</span><span class="String">/\%C</span><span class="Ignore">*</span>
&quot;\%C&quot; 可用来跳过任何合成用字符。例如，模式 &quot;a&quot; 不匹配 &quot;càt&quot; (这里 a 有合成用字
符 0x0300)，但 &quot;a\%C&quot; 可以。注意 不匹配 &quot;cát&quot; (这里 á 是字符 0xe1，没有合成用
字符)。但匹配 &quot;cat&quot; (这里 a 就是简单的 a)。

如果一个合成用字符出现在模式的开始处或在不包含合成用字符的项目之后出现，它匹配
任何包含该合成用字符的字符。

句号和合成用字符联用和合成用字符本身的效果相同，但是你不用担心该字符前面出现的
是什么项目。

合成用字符出现的顺序无关重要。另外，文本可以使用比模式更多的合成用字符，它仍然
匹配。但模式中合成用字符必须全数出现在文本中。

假定 B 是基本字符，x 和 y 是合成用字符:
	<span class="PreProc">模式		文本		匹配与否</span><span class="Ignore"> ~</span>
	Bxy		Bxy		是 (完全匹配)
	Bxy		Byx		是 (忽略顺序)
	Bxy		By		否 (缺失 x)
	Bxy		Bx		否 (缺失 y)
	Bx		Bx		是 (完全匹配)
	Bx		By		否 (缺失 x)
	Bx		Bxy		是 (忽略多余的 y)
	Bx		Byx		是 (忽略多余的 y)

<span class="PreProc">==============================================================================</span>
9. 与 Perl 模式的比较					<span class="Ignore">*</span><span class="String">perl-patterns</span><span class="Ignore">*</span>

Vim 中的正则表达式和 Perl 的在功能上来说非常相似。它们之间的区别基本上只是在表
示方法上。这里给出一个它们之间的区别的总结:

<span class="PreProc">功能				Vim 方言	Perl 方言</span><span class="Ignore"> ~</span>
<span class="PreProc">----------------------------------------------------------------</span>
强制不区分大小写		\c		(?i)
强制区分大小写			\C		(?-i)
不须被引用的群组		\%(atom\)	(?:atom)
保守的倍数描述			\<span class="Special">{-n,m}</span>		*?，+?，??，{}?
零宽度匹配			atom\@=		(?=atom)
零宽度否匹配			atom\@!		(?!atom)
零宽度反向匹配			atom\@&lt;=	(?&lt;=atom)
零宽度反向否匹配		atom\@&lt;!	(?&lt;!atom)
无重试匹配			atom\@&gt;		(?&gt;atom)

(译注: 常见的其它译法
不须被引用的群组		非捕获分组
保守的倍数描述			非贪婪匹配
零宽度匹配			正向预搜索匹配
零宽度否匹配			正向预搜索不匹配
零宽度反向匹配			反向预搜索匹配
零宽度反向否匹配		反向预搜索不匹配
)

Vim 和 Perl 匹配一个字符串中的换行符时有所不同:

在 Perl 里，^ 和 $ 缺省只匹配文本的开始和结尾。但是你也可以设定 'm' 标志位来使
它们匹配内嵌的换行符。你还可以设定 's' 标志位使句号 (.) 可以也用来匹配换行符。
(顺便提一下，使用类似上面 i 标志位的用法，可以在在模式内部改变这两个标志位。)

另一方面，Vim 中的 ^ 和 $ 永远匹配内嵌的换行符。但另外有两个匹配原:  \%^ 和
\%$，可以分别用来匹配 (且只匹配) 文本的起始和结尾。对第二个问题，Vim 用 \_ &quot;修
饰符&quot; 来解决: 把它放在一个句号或字符类之前，对应的模式就可以同时匹配换行字符。

最后，以下这些结构是 Perl 独有的:
- 在正则表达式内执行任意代码:  (?{perl 代码})
- 条件表达式:  (?(条件)真值表达式|假值表达式)

... 而这些是 Vim 独有的:
- 改变模式的 <span class="Type">'magic'</span> 属性:  \v \V \m \M (对于避免反斜杠非常有用)
- 可选匹配原的序列:  \%[atoms]
- \&amp; (\&amp; 之于 \| 就像 &quot;与&quot; 之于 &quot;或&quot;；它强迫多个模式在同一个位置匹配)
- 通过行/列号匹配:  \%5l \%5c \%5v
- 设置匹配的开始和结束位置:  \zs \ze

<span class="PreProc">==============================================================================</span>
10. 高亮显示匹配					<span class="Ignore">*</span><span class="String">match-highlight</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:mat</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:match</span><span class="Ignore">*</span>
:mat[ch] <span class="Special">{group}</span> /<span class="Special">{pattern}</span>/
		定义一个在当前窗口高亮显示的模式。它会以 <span class="Special">{group}</span> 高亮。例:<span class="Ignore"> &gt;</span>
<span class="Comment">			:highlight MyGroup ctermbg=green guibg=green</span>
<span class="Comment">			:match MyGroup /TODO/</span>
<span class="Ignore">&lt;</span>		除了 // 以外，任何字符都可以用来标识一个 <span class="Special">{pattern}</span> 的开始和结
		束。要当心某些特殊的字符，例如 '&quot;' 和 '|'。

		该命令执行时，<span class="Special">{group}</span> 必须已经定义。

		对于 <span class="Type">'hlsearch'</span> 要高亮的字符，仍然适用 <span class="Special">{group}</span> 高亮，因为匹配
		高亮的优先级比 <span class="Type">'hlsearch'</span> 要高。同样的，语法高亮 (见 <span class="Type">'syntax'</span>)
		也被匹配否决。

		注意 使用 <span class="Type">'hlsearch'</span> 高亮显示最近使用的查找模式对所有窗口都有
		效，而以 &quot;:match&quot; 定义的模式仅仅对当前窗口生效。当切换至另一个
		缓冲区时，该设定被保留。

		<span class="Type">'ignorecase'</span> 不起作用。在模式中使用 <span class="Ignore">|</span><span class="Identifier">/\c</span><span class="Ignore">|</span> 来忽略大小写，否则，
		大小写总是区分的。

		<span class="Type">'redrawtime'</span> 定义搜索模式匹配的最大时间。

		匹配行尾而 Vim 只重绘部分显示时，结果可能会令你意想不到。这是
		因为 Vim 在重绘开始的行上寻找匹配的缘故。

		另见 <span class="Ignore">|</span><span class="Identifier">matcharg()</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">getmatches()</span><span class="Ignore">|</span>。前者返回上次 <span class="Ignore">|</span><span class="Identifier">:match</span><span class="Ignore">|</span> 命
		令使用的高亮组和模式。后者返回 <span class="Ignore">|</span><span class="Identifier">matchadd()</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:match</span><span class="Ignore">|</span> 两者定
		义的所有高亮组和模式的列表。

		<span class="Ignore">|</span><span class="Identifier">:match</span><span class="Ignore">|</span> 定义的高亮匹配仅限于三个 (除了 <span class="Ignore">|</span><span class="Identifier">:match</span><span class="Ignore">|</span> 以外，还有
		<span class="Ignore">|</span><span class="Identifier">:2match</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:3match</span><span class="Ignore">|</span> 可用)。而 <span class="Ignore">|</span><span class="Identifier">matchadd()</span><span class="Ignore">|</span> 无此限制，而且还
		能排定匹配的优先级。

		另一个例子，高亮显示虚拟第 72 列之后的所有文本:<span class="Ignore"> &gt;</span>
<span class="Comment">			:highlight rightMargin term=bold ctermfg=blue guifg=blue</span>
<span class="Comment">			:match rightMargin /.\%&gt;72v/</span>
<span class="Ignore">&lt;</span>		要高亮显示所有位于虚拟第 7 列的文本:<span class="Ignore"> &gt;</span>
<span class="Comment">			:highlight col8 ctermbg=grey guibg=grey</span>
<span class="Comment">			:match col8 /\%&lt;8v.\%&gt;7v/</span>
<span class="Ignore">&lt;</span>		注意 用两个项目是为了匹配那些占用了超过一个虚拟列的字符，例如
		TAB。

:mat[ch]
:mat[ch] none
		清除上次定义的匹配模式。


:2mat[ch] <span class="Special">{group}</span> /<span class="Special">{pattern}</span>/					<span class="Ignore">*</span><span class="String">:2match</span><span class="Ignore">*</span>
:2mat[ch]
:2mat[ch] none
:3mat[ch] <span class="Special">{group}</span> /<span class="Special">{pattern}</span>/					<span class="Ignore">*</span><span class="String">:3match</span><span class="Ignore">*</span>
:3mat[ch]
:3mat[ch] none
		和上面的 <span class="Ignore">|</span><span class="Identifier">:match</span><span class="Ignore">|</span> 完全类似，但设置不同的匹配。这样，同时可以有
		三组激活的匹配。如果不同匹配在相同位置出现，最小编号的匹配优
		先。
		&quot;:3match&quot; 命令用于 <span class="Ignore">|</span><span class="Identifier">matchparen</span><span class="Ignore">|</span> 插件。建议使用 &quot;:match&quot; 进行手
		动的搜索，而 &quot;:2match&quot; 用于其它的插件。


 vim&#0058;tw=78:ts=8:ft=help:norl:
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
