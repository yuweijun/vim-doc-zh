<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/github.com/yuweijun/yuweijun.github.io/vim-zh/if_pyth.cnx.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="molokai">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #d0d0d0; background-color: #121212; }
body { font-family: monospace; color: #d0d0d0; background-color: #121212; }
* { font-size: 1em; }
.String { color: #afaf87; }
.Type { color: #5fd7ff; }
.PreProc { color: #87ff00; }
.Identifier { color: #ff8700; }
.Comment { color: #5f5f5f; }
.Special { color: #5fd7ff; }
.Ignore { color: #808080; background-color: #080808; padding-bottom: 1px; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span class="String">if_pyth.txt</span><span class="Ignore">*</span>   For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年7月


		  VIM 参考手册    by Paul Moore
		  译者: lang2，Willis <span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>


Vim 的 Python 编程接口					<span class="Ignore">*</span><span class="String">python</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">Python</span><span class="Ignore">*</span>

1. 命令						<span class="Ignore">|</span><span class="Identifier">python-commands</span><span class="Ignore">|</span>
2. vim 模块					<span class="Ignore">|</span><span class="Identifier">python-vim</span><span class="Ignore">|</span>
3. 缓冲区对象					<span class="Ignore">|</span><span class="Identifier">python-buffer</span><span class="Ignore">|</span>
4. 范围对象					<span class="Ignore">|</span><span class="Identifier">python-range</span><span class="Ignore">|</span>
5. 窗口对象					<span class="Ignore">|</span><span class="Identifier">python-window</span><span class="Ignore">|</span>
6. 标签页对象					<span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span>
7. vim.bindeval 对象				<span class="Ignore">|</span><span class="Identifier">python-bindeval-objects</span><span class="Ignore">|</span>
8. pyeval()、py3eval() Vim 函数			<span class="Ignore">|</span><span class="Identifier">python-pyeval</span><span class="Ignore">|</span>
9. 动态调入					<span class="Ignore">|</span><span class="Identifier">python-dynamic</span><span class="Ignore">|</span>
10. Python 3					<span class="Ignore">|</span><span class="Identifier">python3</span><span class="Ignore">|</span>
11. Python X					<span class="Ignore">|</span><span class="Identifier">python_x</span><span class="Ignore">|</span>
12. 编译时带 Python 支持			<span class="Ignore">|</span><span class="Identifier">python-building</span><span class="Ignore">|</span>

<span class="Special">{Vi 无此功能}</span>

Vim 的 Python 2.x 接口仅当 <span class="Ignore">|</span><span class="Identifier">+python</span><span class="Ignore">|</span> 特性被编译进 Vim 时才有效。
Vim 的 Python 3 接口仅当 <span class="Ignore">|</span><span class="Identifier">+python3</span><span class="Ignore">|</span> 特性被编译进 Vim 时才有效。
可以同时使用两者，但请阅读 <span class="Ignore">|</span><span class="Identifier">python-2-and-3</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
1. 命令							<span class="Ignore">*</span><span class="String">python-commands</span><span class="Ignore">*</span>

					<span class="Ignore">*</span><span class="String">:python</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:py</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E263</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E264</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E887</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>py[thon] <span class="Special">{stmt}</span>
			执行 Python 语句 <span class="Special">{stmt}</span>。一个判断 &quot;:python&quot; 命令是否可
			用的简单检查:<span class="Ignore"> &gt;</span>
<span class="Comment">				:python print &quot;Hello&quot;</span>

:<span class="Special">[range]</span>py[thon] &lt;&lt; <span class="Special">{endmarker}</span>
<span class="Special">{script}</span>
<span class="Special">{endmarker}</span>
			执行 Python 脚本 <span class="Special">{script}</span>。
			备注: 此命令在没有编译进 Python 特性时无效。为了避免这
			样的错误，参阅 <span class="Ignore">|</span><span class="Identifier">script-here</span><span class="Ignore">|</span>。

<span class="Special">{endmarker}</span> 前面_不能_有任何空白字符。如果在 &quot;&lt;&lt;&quot; 之后省略了 <span class="Special">{endmarker}</span>，在
<span class="Special">{script}</span> 之后一定要有一个点 '.'。这和 <span class="Ignore">|</span><span class="Identifier">:append</span><span class="Ignore">|</span> 及 <span class="Ignore">|</span><span class="Identifier">:insert</span><span class="Ignore">|</span> 命令的道理是一样
的。这种形式的 <span class="Ignore">|</span><span class="Identifier">:python</span><span class="Ignore">|</span> 命令主要用于在 Vim 脚本中嵌入 Python 代码。

例子:<span class="Ignore"> &gt;</span>
<span class="Comment">	function! IcecreamInitialize()</span>
<span class="Comment">	python &lt;&lt; EOF</span>
<span class="Comment">	class StrawberryIcecream:</span>
<span class="Comment">		def __call__(self):</span>
<span class="Comment">			print 'EAT ME'</span>
<span class="Comment">	EOF</span>
<span class="Comment">	endfunction</span>

要看运行的 Python 版本:<span class="Ignore"> &gt;</span>
<span class="Comment">	:python import sys</span>
<span class="Comment">	:python print(sys.version)</span>

备注: Python 对于缩进是非常敏感的。要确保 &quot;class&quot; 所在行及 &quot;EOF&quot; 没有任何缩
进。

							<span class="Ignore">*</span><span class="String">:pydo</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>pydo <span class="Special">{body}</span>	对 <span class="Special">[range]</span> 里的每一行执行 Python 函数 &quot;def
			_vim_pydo(line, linenr): <span class="Special">{body}</span>&quot;，其中的函数参数设为每
			行不带尾部 <span class="Special">&lt;EOL&gt;</span> 的文本，以及行号。该函数应该返回字符
			串或者 None。如果返回字符串，它会用来替代当前执行的
			行。缺省 <span class="Special">[range]</span> 为整个文件: &quot;1,$&quot;。
			<span class="Special">{Vi 无此功能}</span>

示例:
<span class="Ignore">&gt;</span>
<span class="Comment">	:pydo return &quot;%s\t%d&quot; % (line[::-1], len(line))</span>
<span class="Comment">	:pydo if line: return &quot;%4d: %s&quot; % (linenr, line)</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">:pyfile</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:pyf</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>pyf[ile] <span class="Special">{file}</span>
			执行 <span class="Special">{file}</span> 文件中包含的 Python 脚本。整个参数被用作一
			个文件名。 <span class="Special">{Vi 无此功能}</span>

这些命令根本上都差不多 － 它们都将当前范围 <span class="Ignore">|</span><span class="Identifier">python-range</span><span class="Ignore">|</span> 设定为指定的行范围，
并对其执行 Python 代码。

:python 的情况所执行的代码来自命令行。
:pyfile 的情况所执行的代码来自一个指定的文件。

Python 命令不能在 <span class="Ignore">|</span><span class="Identifier">sandbox</span><span class="Ignore">|</span> 里使用。

需要传递参数的话，你得使用 sys.argv[]。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">	:python import sys</span>
<span class="Comment">	:python sys.argv = [&quot;foo&quot;, &quot;bar&quot;]</span>
<span class="Comment">	:pyfile myscript.py</span>

下面是一些例子						<span class="Ignore">*</span><span class="String">python-examples</span><span class="Ignore">*</span> <span class="Ignore"> &gt;</span>

<span class="Comment">	:python from vim import *</span>
<span class="Comment">	:python from string import upper</span>
<span class="Comment">	:python current.line = upper(current.line)</span>
<span class="Comment">	:python print &quot;Hello&quot;</span>
<span class="Comment">	:python str = current.buffer[42]</span>

(注意 如同导入 (import) 模块一样，变动对后续命令持续有效。这和 Python 的解释
程序是一样的。)

<span class="PreProc">==============================================================================</span>
2. vim 模块						<span class="Ignore">*</span><span class="String">python-vim</span><span class="Ignore">*</span>

Python 的代码所有对 Vim 的操作 (只有一个例外 － 看下面的 <span class="Ignore">|</span><span class="Identifier">python-output</span><span class="Ignore">|</span>) 都是
通过 &quot;vim&quot; 模块来进行的。该模块包括两个方法，三个常量，以及一个异常对象。在使
用它们之前你得先导入 (import) vim 模块。

总览<span class="Ignore"> &gt;</span>
<span class="Comment">	:py print &quot;Hello&quot;		# 显示信息</span>
<span class="Comment">	:py vim.command(cmd)		# 执行 Ex 命令</span>
<span class="Comment">	:py w = vim.windows[n]		# 获取窗口 &quot;n&quot;</span>
<span class="Comment">	:py cw = vim.current.window	# 获取当前窗口</span>
<span class="Comment">	:py b = vim.buffers[n]		# 获取缓冲区 &quot;n&quot;</span>
<span class="Comment">	:py cb = vim.current.buffer	# 获取当前缓冲区</span>
<span class="Comment">	:py w.height = lines		# 设定窗口高度</span>
<span class="Comment">	:py w.cursor = (row, col)	# 设定光标位置</span>
<span class="Comment">	:py pos = w.cursor		# 获取 tuple (行，列)</span>
<span class="Comment">	:py name = b.name		# 获取缓冲区的文件名</span>
<span class="Comment">	:py line = b[n]			# 获取缓冲区内的一行</span>
<span class="Comment">	:py lines = b[n:m]		# 获取数行</span>
<span class="Comment">	:py num = len(b)		# 获取统计的行数</span>
<span class="Comment">	:py b[n] = str			# 在缓冲区里写入一行文本</span>
<span class="Comment">	:py b[n:m] = [str1, str2, str3]	# 一次性写入多行文本</span>
<span class="Comment">	:py del b[n]			# 删除一行</span>
<span class="Comment">	:py del b[n:m]			# 删除数行</span>

&quot;vim&quot; 模块中的方法

vim.command(str)					<span class="Ignore">*</span><span class="String">python-command</span><span class="Ignore">*</span>
	执行 vim (ex-模式) 命令 str。无返回值。
	例如:<span class="Ignore"> &gt;</span>
<span class="Comment">		:py vim.command(&quot;set tw=72&quot;)</span>
<span class="Comment">		:py vim.command(&quot;%s/aaa/bbb/g&quot;)</span>
<span class="Ignore">&lt;</span>	下面的定义可以执行普通模式命令:<span class="Ignore"> &gt;</span>
<span class="Comment">		def normal(str):</span>
<span class="Comment">			vim.command(&quot;normal &quot;+str)</span>
<span class="Comment">		# 注意使用单引号标识出含有双引号的字符串</span>
<span class="Comment">		normal('&quot;a2dd&quot;aP')</span>
<span class="Ignore">&lt;</span>								<span class="Ignore">*</span><span class="String">E659</span><span class="Ignore">*</span>
	&quot;:python&quot; 在 Python 2.2 及之前版本上不能嵌套使用。下面命令只对 Python
	2.3 之后版本适用:<span class="Ignore"> &gt;</span>
<span class="Comment">		:py vim.command(&quot;python print 'Hello again Python'&quot;)</span>


vim.eval(str)						<span class="Ignore">*</span><span class="String">python-eval</span><span class="Ignore">*</span>
	使用 vim 内部的表达式处理器来对表达式 str 求值。(参阅 <span class="Ignore">|</span><span class="Identifier">expression</span><span class="Ignore">|</span>)。
	返回表达式的结果:
	-如果 Vim 表达式计算结果是字符串或者数值，那么返回一个字符串。
	-如果 Vim 表达式计算结果是 Vim 列表，那么返回一个列表
	-如果 Vim 表达式计算结果是 Vim 字典，那么返回一个字典
	字典和列表被递归扩展。
	例:<span class="Ignore"> &gt;</span>
<span class="Comment">	    :py text_width = vim.eval(&quot;&amp;tw&quot;)</span>
<span class="Comment">	    :py str = vim.eval(&quot;12+12&quot;)		# 注意: 结果是个字符串！</span>
<span class="Comment">						# 使用 string.atoi()</span>
<span class="Comment">						# 把它转换成数字</span>

<span class="Comment">	    :py tagList = vim.eval('taglist(&quot;eval_expr&quot;)')</span>
<span class="Ignore">&lt;</span>	后一个将返回一个 python 类型的字典列表，例如:
	<span class="PreProc">[{'cmd': '/^eval_expr(arg, nextcmd)$/', 'static': 0, 'name':</span><span class="Ignore"> ~</span>
	<span class="PreProc">'eval_expr', 'kind': 'f', 'filename': './src/eval.c'}]</span><span class="Ignore"> ~</span>

vim.bindeval(str)					<span class="Ignore">*</span><span class="String">python-bindeval</span><span class="Ignore">*</span>
	类似于 <span class="Ignore">|</span><span class="Identifier">python-eval</span><span class="Ignore">|</span>，但返回 <span class="Ignore">|</span><span class="Identifier">python-bindeval-objects</span><span class="Ignore">|</span> 中描述的特殊
	对象。这些 python 对象可用于修改 (<span class="Ignore">|</span><span class="Identifier">List</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">Dictionary</span><span class="Ignore">|</span>) 或调用
	(<span class="Ignore">|</span><span class="Identifier">Funcref</span><span class="Ignore">|</span>) vim 对象。

vim.strwidth(str)					<span class="Ignore">*</span><span class="String">python-strwidth</span><span class="Ignore">*</span>
	类似于 <span class="Ignore">|</span><span class="Identifier">strwidth()</span><span class="Ignore">|</span>: 返回 str 占据的显示单元数，制表符算作一个单元。

vim.foreach_rtp(callable)				<span class="Ignore">*</span><span class="String">python-foreach_rtp</span><span class="Ignore">*</span>
	对 <span class="Type">'runtimepath'</span> 的每个路径调用给定的 callable，直到某次 callable 返回
	非 None 值、抛出例外、或者没有更多的路径为止。如果因为 callable 返回
	非 None 而停止，vim.foreach_rtp 函数返回 callable 返回的值。

vim.chdir(*args, **kwargs)				<span class="Ignore">*</span><span class="String">python-chdir</span><span class="Ignore">*</span>
vim.fchdir(*args, **kwargs)				<span class="Ignore">*</span><span class="String">python-fchdir</span><span class="Ignore">*</span>
	运行 os.chdir 或 os.fchdir，然后做合适的 vim 的事情。
	备注: 你不应直接使用这些函数，用 os.chdir 或 os.fchdir
	代替。如果 os.fchdir 不存在，则 vim.fchdir 的行为未定义。


&quot;vim&quot; 模块中的异常对象

	vim.error					<span class="Ignore">*</span><span class="String">python-error</span><span class="Ignore">*</span>
	当遇到 Vim 的错误时，Python 引起一个 vim.error 类的异常。
	例:<span class="Ignore"> &gt;</span>
<span class="Comment">		try:</span>
<span class="Comment">			vim.command(&quot;put a&quot;)</span>
<span class="Comment">		except vim.error:</span>
<span class="Comment">			# nothing in register a</span>

&quot;vim&quot; 模块中的常量
	注意 这些其实并非真正的常量 － 你还是可以对它们赋值。但这毫无意义，因
	为你会丢失该 vim 对象本来代表的值。

vim.buffers						<span class="Ignore">*</span><span class="String">python-buffers</span><span class="Ignore">*</span>
	一个映射对象，用来提供对 vim 缓冲区的操作。该对象支持以下操作:<span class="Ignore"> &gt;</span>
<span class="Comment">	    :py b = vim.buffers[i]	# 索引 (只读)</span>
<span class="Comment">	    :py b in vim.buffers	# 成员测试</span>
<span class="Comment">	    :py n = len(vim.buffers)	# 成员个数</span>
<span class="Comment">	    :py for b in vim.buffers:	# 遍历缓冲区列表</span>
<span class="Ignore">&lt;</span>
vim.windows						<span class="Ignore">*</span><span class="String">python-windows</span><span class="Ignore">*</span>
	一个序列对象，用来提供对 vim 窗口的操作。该对象支持以下操作:<span class="Ignore"> &gt;</span>
<span class="Comment">	    :py w = vim.windows[i]	# 索引 (只读)</span>
<span class="Comment">	    :py w in vim.windows	# 成员测试</span>
<span class="Comment">	    :py n = len(vim.windows)	# 成员个数</span>
<span class="Comment">	    :py for w in vim.windows:	# 顺序存取</span>
<span class="Ignore">&lt;</span>	注意: vim.windows 对象总是访问当前标签页。<span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span>.windows 对
	象和父 <span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span> 对象绑定，总是使用该标签页的窗口 (如果该标签页
	该删除，抛出 vim.error)。你可以得到两者的引用而无需保存 vim 模块对象或
	<span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span> 的引用。此时它们不会失去自己的属性。

vim.tabpages						<span class="Ignore">*</span><span class="String">python-tabpages</span><span class="Ignore">*</span>
	一个序列对象，用来提供 vim 标签页的操作。该对象支持以下操作:<span class="Ignore"> &gt;</span>
<span class="Comment">	    :py t = vim.tabpages[i]	# 索引 (只读)</span>
<span class="Comment">	    :py t in vim.tabpages	# 成员测试</span>
<span class="Comment">	    :py n = len(vim.tabpages)	# 成员个数</span>
<span class="Comment">	    :py for t in vim.tabpages:	# 顺序存取</span>
<span class="Ignore">&lt;</span>
vim.current						<span class="Ignore">*</span><span class="String">python-current</span><span class="Ignore">*</span>
	一个用来提供对各种各样当前 &quot;current&quot; 对象进行操作的对象。它包括一些特
	定的属性:
		vim.current.line	当前行 (读写)			字符串
		vim.current.buffer	当前缓冲区 (读写)		缓冲区
		vim.current.window	当前窗口 (读写)			窗口
		vim.current.tabpage	当前标签页 (读写)		标签页
		vim.current.range	当前行范围 (只读)		范围

	最后一种情况需要一些额外的解释。当用 :python 或 :pyfile 命令指定一个范
	围之后，该范围将成为 &quot;当前范围&quot;。一个范围就如同一个缓冲区，只不过所操
	作的对象界限于所有行的一个子集。请参阅 <span class="Ignore">|</span><span class="Identifier">python-range</span><span class="Ignore">|</span>。

	注意: 赋值给 vim.current.<span class="Special">{buffer,window,tagpage}</span> 时，分别期待合法的
	<span class="Ignore">|</span><span class="Identifier">python-buffer</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">python-window</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span> 对象。赋值触发
	到给定缓冲区、窗口、标签页的正常切换 (带有 <span class="Ignore">|</span><span class="Identifier">autocommand</span><span class="Ignore">|</span> 自动命令)。这
	是在 python 里切换 UI 对象的唯一方法: 不能给 <span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span>.window
	属性赋值。要想进行切换但不执行自动命令，可用<span class="Ignore"> &gt;</span>
<span class="Comment">	    py &lt;&lt; EOF</span>
<span class="Comment">	    saved_eventignore = vim.options['eventignore']</span>
<span class="Comment">	    vim.options['eventignore'] = 'all'</span>
<span class="Comment">	    try:</span>
<span class="Comment">	        vim.current.buffer = vim.buffers[2] # 切换到缓冲区 2</span>
<span class="Comment">	    finally:</span>
<span class="Comment">	        vim.options['eventignore'] = saved_eventignore</span>
<span class="Comment">	    EOF</span>

vim.vars						<span class="Ignore">*</span><span class="String">python-vars</span><span class="Ignore">*</span>
vim.vvars						<span class="Ignore">*</span><span class="String">python-vvars</span><span class="Ignore">*</span>
	类似字典的对象，分别对应全局 (<span class="Ignore">|</span><span class="Identifier">g:</span><span class="Ignore">|</span>) 和 vim (<span class="Ignore">|</span><span class="Identifier">v:</span><span class="Ignore">|</span>) 变量。等价于
	<span class="Ignore">`</span><span class="Comment">vim.bindeval(&quot;g:&quot;)</span><span class="Ignore">`</span>，但更快。

vim.options						<span class="Ignore">*</span><span class="String">python-options</span><span class="Ignore">*</span>
	部分支持映射协议 (即读写子项目) 的对象，用于对全局选项进行读写访问。
	注意: 和 <span class="Ignore">|</span><span class="Identifier">:set</span><span class="Ignore">|</span> 不同，此对象只能访问全局选项，不能用于读写局部变量的
	值或以任何方式去访问只限局部的变量。如果没有指定名字的全局变量，抛出
	KeyError (也即，对 <span class="Ignore">|</span><span class="Identifier">global-local</span><span class="Ignore">|</span> 或只限全局的选项，不会抛出此例外，
	但对局部于窗口或局部于缓冲区的则会)。<span class="Ignore">|</span><span class="Identifier">python-buffer</span><span class="Ignore">|</span> 对象可用于访问局
	部于缓冲区的选项，<span class="Ignore">|</span><span class="Identifier">python-window</span><span class="Ignore">|</span> 选项则可用于访问局部于窗口的选项。

	可通过 vim 模块的 &quot;Options&quot; 属性取得此对象的类型。

Python 的输出						<span class="Ignore">*</span><span class="String">python-output</span><span class="Ignore">*</span>
	Vim 将所有 Python 代码的输出都显示在信息区。普通的输出会以一般信息出
	现，错误会以出错信息出现。

	用具体实现的术语来讲，这表示所有 sys.stdout (包括 print 语句的输出) 以
	一般信息形式出现，而所有 sys.stderr (包括 error tracebacks) 都会被显示
	成出错信息。

							<span class="Ignore">*</span><span class="String">python-input</span><span class="Ignore">*</span>
	Vim 并不支持用 Python 来输入 (通过 sys.stdin，包括 input() 和
	raw_input())。这些调用可能会导致崩溃。这个问题可能以后会修正。

		    <span class="Ignore">*</span><span class="String">python2-directory</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">python3-directory</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">pythonx-directory</span><span class="Ignore">*</span>
Python <span class="Type">'runtimepath'</span> 处理				<span class="Ignore">*</span><span class="String">python-special-path</span><span class="Ignore">*</span>

在 python 中，vim.VIM_SPECIAL_PATH 特殊目录用于代表 <span class="Type">'runtimepath'</span> 的路径列表:
如果 sys.path 包含此目录而且 sys.path_hooks 包含 vim.path_hooks，python 会试图
载入 <span class="Type">'runtimepath'</span> 的每个 <span class="Special">{rtp}</span> 对应的 <span class="Special">{rtp}</span>/python2 (或 python3) 和
<span class="Special">{rtp}</span>/pythonx (同时适用于两个 python 版本) 模块。

实现大致如下，但以 C 编写:<span class="Ignore"> &gt;</span>

<span class="Comment">    from imp import find_module, load_module</span>
<span class="Comment">    import vim</span>
<span class="Comment">    import sys</span>

<span class="Comment">    class VimModuleLoader(object):</span>
<span class="Comment">        def __init__(self, module):</span>
<span class="Comment">            self.module = module</span>

<span class="Comment">        def load_module(self, fullname, path=None):</span>
<span class="Comment">            return self.module</span>

<span class="Comment">    def _find_module(fullname, oldtail, path):</span>
<span class="Comment">        idx = oldtail.find('.')</span>
<span class="Comment">        if idx &gt; 0:</span>
<span class="Comment">            name = oldtail[:idx]</span>
<span class="Comment">            tail = oldtail[idx+1:]</span>
<span class="Comment">            fmr = find_module(name, path)</span>
<span class="Comment">            module = load_module(fullname[:-len(oldtail)] + name, *fmr)</span>
<span class="Comment">            return _find_module(fullname, tail, module.__path__)</span>
<span class="Comment">        else:</span>
<span class="Comment">            fmr = find_module(fullname, path)</span>
<span class="Comment">            return load_module(fullname, *fmr)</span>

<span class="Comment">    # It uses vim module itself in place of VimPathFinder class: it does not</span>
<span class="Comment">    # matter for python which object has find_module function attached to as</span>
<span class="Comment">    # an attribute.</span>
<span class="Comment">    class VimPathFinder(object):</span>
<span class="Comment">        @classmethod</span>
<span class="Comment">        def find_module(cls, fullname, path=None):</span>
<span class="Comment">            try:</span>
<span class="Comment">                return VimModuleLoader(_find_module(fullname, fullname, path or vim._get_paths()))</span>
<span class="Comment">            except ImportError:</span>
<span class="Comment">                return None</span>

<span class="Comment">        @classmethod</span>
<span class="Comment">        def load_module(cls, fullname, path=None):</span>
<span class="Comment">            return _find_module(fullname, fullname, path or vim._get_paths())</span>

<span class="Comment">    def hook(path):</span>
<span class="Comment">        if path == vim.VIM_SPECIAL_PATH:</span>
<span class="Comment">            return VimPathFinder</span>
<span class="Comment">        else:</span>
<span class="Comment">            raise ImportError</span>

<span class="Comment">    sys.path_hooks.append(hook)</span>

vim.VIM_SPECIAL_PATH					<span class="Ignore">*</span><span class="String">python-VIM_SPECIAL_PATH</span><span class="Ignore">*</span>
	字符串常数，和 vim 路径钩联合使用。如果 vim 安装的路径钩被要求处理任何
	非 vim.VIM_SPECIAL_PATH 常数的路径，抛出 ImportError。在唯一可能的另一
	种情况下，使用特殊载入程序。

	注意: 不能直接使用该常数的值，必须使用 vim.VIM_SPECIAL_PATH 对象。

vim.find_module(...)					<span class="Ignore">*</span><span class="String">python-find_module</span><span class="Ignore">*</span>
vim.path_hook(path)					<span class="Ignore">*</span><span class="String">python-path_hook</span><span class="Ignore">*</span>
	用于实现上述路径载入的方法或对象。除非你想对 sys.meta_path 进行处理而
	可以看看 vim.path_hook，请不要直接使用它们。将来的 vim 版本不一定保证
	任何这里描述的对象会继续存在。

vim._get_paths						<span class="Ignore">*</span><span class="String">python-_get_paths</span><span class="Ignore">*</span>
	用于产生给路径钩搜索的路径列表的方法。可以用于调试，但不要假定将来的
	vim 版本中此方法会继续存在。

	返回 <span class="Type">'runtimepath'</span> 中每个 <span class="Special">{rtp}</span> 对应的 <span class="Special">{rtp}</span>/python2 (或
	<span class="Special">{rtp}</span>/python3) 和 <span class="Special">{rtp}</span>/pythonx 的目录列表。

<span class="PreProc">==============================================================================</span>
3. 缓冲区对象						<span class="Ignore">*</span><span class="String">python-buffer</span><span class="Ignore">*</span>

缓冲区对象代表 vim 缓冲区。你可以用以下这几种办法来获取缓冲区的列表:
	- 通过 vim.current.buffer (<span class="Ignore">|</span><span class="Identifier">python-current</span><span class="Ignore">|</span>)
	- 通过 vim.buffers 的索引访问 (<span class="Ignore">|</span><span class="Identifier">python-buffers</span><span class="Ignore">|</span>)
	- 通过一个窗口的 &quot;buffer&quot; 属性 (<span class="Ignore">|</span><span class="Identifier">python-window</span><span class="Ignore">|</span>)

缓冲区对象有两个只读属性 - name - 缓冲区的文件全名，还有 number - 缓冲区号。
该对象还包括三个方法 (append，mark 及 range；见下)。

你也可以将缓冲区对象视为序列对象。这样的话，它们就可以被看作字符串的列表进行存
取 (它们是可变的)。每一个元素是缓冲区中的一行。所有通常的序列存取操作，包括索
引，索引赋值，切片 (slice) 及切片赋值，等等，都可以被使用。注意 索引 (切片) 操
作的结果是一个字符串 (字符串列表)。这产生了一个意想不到的结果 - b[:] 和 b 是不
同的。确切一些，&quot;b[:] = None&quot; 会清空整个缓冲区，而 &quot;b = None&quot; 仅仅更新变量 b
的值，完全不会影响到缓冲区。

缓冲区索引从 0 开始算起，这与通常的 Python 语法一致。但这和 Vim 的行号从 1 算
起有分歧。这一点在处理标记 (见下) 是要特别留意，因为标记是以行号区分的。

缓冲区对象的属性有:
	b.vars		类似字典的对象，可用于访问 <span class="Ignore">|</span><span class="Identifier">buffer-variable</span><span class="Ignore">|</span>。
	b.options	映射对象 (支持子项目的读写和删除)，用于访问局部于缓冲
			区的选项和 <span class="Ignore">|</span><span class="Identifier">global-local</span><span class="Ignore">|</span> 选项的缓冲区局部值。如果选项
			局部于窗口，请使用 <span class="Ignore">|</span><span class="Identifier">python-window</span><span class="Ignore">|</span>.options，使用此对象
			会抛出 KeyError。如果选项是 <span class="Ignore">|</span><span class="Identifier">global-local</span><span class="Ignore">|</span> 而没有局部
			的部分，返回 None。
	b.name		字符串，可读写。包含缓冲区名 (完整路径)。
			备注: 给 b.name 赋值时激活 <span class="Ignore">|</span><span class="Identifier">BufFilePre</span><span class="Ignore">|</span> 和
			<span class="Ignore">|</span><span class="Identifier">BufFilePost</span><span class="Ignore">|</span> 自动事件。
	b.number	缓冲区编号。可用作 <span class="Ignore">|</span><span class="Identifier">python-buffers</span><span class="Ignore">|</span> 的键。只读。
	b.valid		True 或 False。如果对应的缓冲区被删除 (wipe)，缓冲区对
			象就成为非法。

缓冲区对象的方法有:
	b.append(str)	对缓冲区附加一行
	b.append(str, nr)  同上，在第 &quot;nr&quot; 行之后
	b.append(list)	对缓冲区附加一系列行
			备注: append 方法可以带一个字符串列表作为参数，这和
			Python 中内建的列表对象的对应方法是不同的。
	b.append(list, nr)  同上，在第 &quot;nr&quot; 行之后
	b.mark(name)	返回一个 tuple (行，列) 用来代表该位置上的一个命名标记
			(也可以用于 []&quot;&lt;&gt; 等标记)
	b.range(s,e)	返回一个范围对象 (参见 <span class="Ignore">|</span><span class="Identifier">python-range</span><span class="Ignore">|</span>) 用来代表指定缓
			冲区中行 s 与 行 e (包含 s 和 e <span class="Ignore">|</span><span class="Identifier">inclusive</span><span class="Ignore">|</span>) 之间的部
		 	分。

注意: 当增加一行的时候，这一行里一定不要含有换行符 '\n'。行尾的 '\n' 可以，
但会被忽略，所以下面的操作是可以的:
	:py b.append(f.readlines())

可通过 vim 模块的 &quot;Buffer&quot; 属性取得缓冲区对象的类型。

例如 (假定 b 是当前缓冲区)<span class="Ignore"> &gt;</span>
<span class="Comment">	:py print b.name		# 输出缓冲区的名字</span>
<span class="Comment">	:py b[0] = &quot;hello!!!&quot;		# 替换最顶上的一行</span>
<span class="Comment">	:py b[:] = None			# 删除整个缓冲区</span>
<span class="Comment">	:py del b[:]			# 删除整个缓冲区</span>
<span class="Comment">	:py b[0:0] = [ &quot;a line&quot; ]	# 在第一行前添加一行</span>
<span class="Comment">	:py del b[2]			# 删除一行 (第三行)</span>
<span class="Comment">	:py b.append(&quot;bottom&quot;)		# 在缓冲区结尾添加一行</span>
<span class="Comment">	:py n = len(b)			# 总行数</span>
<span class="Comment">	:py (row,col) = b.mark('a') 	# 命名标记</span>
<span class="Comment">	:py r = b.range(1,5)		# 缓冲区内的一个范围</span>
<span class="Comment">	:py b.vars[&quot;foo&quot;] = &quot;bar&quot;	# 给 b:foo 变量赋值</span>
<span class="Comment">	:py b.options[&quot;ff&quot;] = &quot;dos&quot;	# 设置 fileformat</span>
<span class="Comment">	:py del b.options[&quot;ar&quot;]		# 等同于 :set autoread&lt;</span>

<span class="PreProc">==============================================================================</span>
4. 范围对象						<span class="Ignore">*</span><span class="String">python-range</span><span class="Ignore">*</span>

范围对象代表一个 vim 缓冲区内的一个部分。你可以用以下的方法之一来获取一个缓冲
区对象:
	- 通过 vim.current.range (<span class="Ignore">|</span><span class="Identifier">python-current</span><span class="Ignore">|</span>)
	- 通过一个缓冲区的 range() 方法 (<span class="Ignore">|</span><span class="Identifier">python-buffer</span><span class="Ignore">|</span>)

一个范围对象在操作上几乎和一个缓冲区对象完全一样。不过，其操作的目标仅显于范围
指定的行 (当然，这个行范围会随着切片赋值，行删除，或者 range.append() 等等操作
而改变)。

范围对象的属性有:
	r.start		首行在缓冲区内的索引
	r.end		尾行在缓冲区内的索引

范围对象的方法有:
	r.append(str)	给范围附加一行
	r.append(str, nr)  同上，在第 &quot;nr&quot; 行之后
	r.append(list)	给范围附加一系列行
			备注: append 方法可以带一个字符串列表作为参数，这和
			Python 中内建的列表对象的对应方法是不同的。
	r.append(list, nr)  同上，在第 &quot;nr&quot; 行之后

可通过 vim 模块的 &quot;Range&quot; 属性取得范围对象的类型。

例如 (假设 r 是当前范围):
	# 发送范围内的所有行给缺省打印机
	vim.command(&quot;%d,%dhardcopy!&quot; % (r.start+1,r.end+1))

<span class="PreProc">==============================================================================</span>
5. 窗口对象						<span class="Ignore">*</span><span class="String">python-window</span><span class="Ignore">*</span>

窗口对象代表一个 vim 窗口。你可以用以下几种方法来获取一个窗口对象:
	- 通过 vim.current.window (<span class="Ignore">|</span><span class="Identifier">python-current</span><span class="Ignore">|</span>)
	- 通过对 vim.windows 的索引操作 (<span class="Ignore">|</span><span class="Identifier">python-windows</span><span class="Ignore">|</span>)
	- 通过对标签页的 &quot;windows&quot; 属性的索引操作 (<span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span>)
	- 通过标签页的 &quot;window&quot; 属性 (<span class="Ignore">|</span><span class="Identifier">python-tabpage</span><span class="Ignore">|</span>)

你只能通过窗口对象的属性来控制它。这些对象没有方法，也没有序列等其它接口。

窗口的属性包括:
	buffer (只读)		窗口中显示的缓冲区
	cursor (读写)		窗口中的当前光标位置
				这是一个 tuple (行，列)。
	height (读写)		行数表示的窗口高度
	width (读写)		列数表示的窗口宽度
	vars (只读)		窗口 <span class="Ignore">|</span><span class="Identifier">w:</span><span class="Ignore">|</span> 变量。不能给本属性赋值，但可以用此属
				性修改窗口变量
	options (只读)		局部于窗口的选项。不能给本属性赋值，但可以用此
				属性修改窗口选项。只能用于访问局部于窗口的选
				项，对局部于缓冲区的选项要用 <span class="Ignore">|</span><span class="Identifier">python-buffer</span><span class="Ignore">|</span>，
				对全局选项用 <span class="Ignore">|</span><span class="Identifier">python-options</span><span class="Ignore">|</span>。如果选项是
				<span class="Ignore">|</span><span class="Identifier">global-local</span><span class="Ignore">|</span> 的而没有局部值，返回 None。
	number (只读)		窗口编号。首个窗口的编号为 1。如果不能决定才
				会返回 0 (例如当窗口对象属于其他标签页时)。
	row、col (只读)		窗口在屏幕上的位置，以显示单元计。首个位置为
				零。
	tabpage (只读)		窗口的标签页。
	valid (读写)		True 或 False。当对应窗口关闭时窗口对象成为非
				法。

height 属性只有当屏幕被水平分割时才可写。
width  属性只有当屏幕被垂直分割时才可写。

可通过 vim 模块的 &quot;Window&quot; 属性取得窗口对象的类型。

<span class="PreProc">==============================================================================</span>
6. 标签页对象						<span class="Ignore">*</span><span class="String">python-tabpage</span><span class="Ignore">*</span>

标签页对象代表一个 vim 标签页。你可以用以下几种方法来获取之:
	- 通过 vim.current.tabpage (<span class="Ignore">|</span><span class="Identifier">python-current</span><span class="Ignore">|</span>)
	- 通过对 vim.tabpages 的索引操作 (<span class="Ignore">|</span><span class="Identifier">python-tabpages</span><span class="Ignore">|</span>)

你可以通过该对象来访问标签页里的窗口。这些对象没有方法，也没有序列等其它接口。

标签页的属性包括:
	number		标签页编号，和 <span class="Ignore">|</span><span class="Identifier">tabpagenr()</span><span class="Ignore">|</span> 相同。
	windows		类似于 <span class="Ignore">|</span><span class="Identifier">python-windows</span><span class="Ignore">|</span>，但对应当前标签页
	vars		标签页 <span class="Ignore">|</span><span class="Identifier">t:</span><span class="Ignore">|</span> 变量。
	valid		True 或 False。当对应标签页关闭时标签页对象成为非法。

可通过 vim 模块的 &quot;TabPage&quot; 属性取得标签页对象的类型。

<span class="PreProc">==============================================================================</span>
7. vim.bindeval 对象				<span class="Ignore">*</span><span class="String">python-bindeval-objects</span><span class="Ignore">*</span>

vim.Dictionary 对象				<span class="Ignore">*</span><span class="String">python-Dictionary</span><span class="Ignore">*</span>
    类字典对象，用于访问 vim <span class="Ignore">|</span><span class="Identifier">Dictionary</span><span class="Ignore">|</span> 类型。
    属性:
        <span class="PreProc">属性       描述</span><span class="Ignore"> ~</span>
        locked     以下值之一                   <span class="Ignore">*</span><span class="String">python-.locked</span><span class="Ignore">*</span>
                    <span class="PreProc">值              描述</span><span class="Ignore"> ~</span>
                    zero            变量没有上锁
                    vim.VAR_LOCKED  变量已上锁，但可以解锁
                    vim.VAR_FIXED   变量已上锁，且不可以解锁
                   读写。可以通过给本属性赋值 <span class="Ignore">`</span><span class="Comment">True</span><span class="Ignore">`</span> 或 <span class="Ignore">`</span><span class="Comment">False</span><span class="Ignore">`</span> 来给变量解锁。
                   不支持递归上锁。
        scope      以下值之一
                    <span class="PreProc">值                 描述</span><span class="Ignore"> ~</span>
                    zero               字典无作用域
                    vim.VAR_DEF_SCOPE  <span class="Ignore">|</span><span class="Identifier">g:</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">l:</span><span class="Ignore">|</span> 字典
                    vim.VAR_SCOPE      其他作用域的字典，
                                       见 <span class="Ignore">|</span><span class="Identifier">internal-variables</span><span class="Ignore">|</span>
    方法 (备注: 方法不支持关键字参数):
        <span class="PreProc">方法        描述</span><span class="Ignore"> ~</span>
        keys()      返回字典所有键的列表。
        values()    返回字典所有值的列表。
        items()     返回字典所有内容的二元组的列表。
        update(iterable)、update(dictionary)、update(**kwargs)
                    把新的键值加入字典。
        get(key[, default=None])
                    从字典读入 key 对应值，如果不存在返回 default。
        pop(key[, default])
                    从字典中删除给定 key 并返回对应值。如果找不到 key 且给出
                    default 返回 default，不然抛出 KeyErrror。
        popitem()
                    从字典中删除随机键，并返回 (键, 值) 对。
        has_key(key)
                    检查字典中是否包含给定的键 key，类似于 <span class="Ignore">`</span><span class="Comment">key in dict</span><span class="Ignore">`</span>。

        __new__(), __new__(iterable), __new__(dictionary), __new__(update)
                    用 <span class="Ignore">`</span><span class="Comment">vim.Dictionary()</span><span class="Ignore">`</span> 可以建立新的 vim 字典。
                    <span class="Ignore">`</span><span class="Comment">d=vim.Dictionary(arg)</span><span class="Ignore">`</span> 等价于
                    <span class="Ignore">`</span><span class="Comment">d=vim.bindeval('{}');d.update(arg)</span><span class="Ignore">`</span>。无参数的版本构建空
                    字典。

    示例:<span class="Ignore"> &gt;</span>
<span class="Comment">        d = vim.Dictionary(food=&quot;bar&quot;)		# 构造函数</span>
<span class="Comment">        d['a'] = 'b'				# 子项目赋值</span>
<span class="Comment">        print d['a']				# 读取子项目</span>
<span class="Comment">        d.update({'c': 'd'})			# .update(dictionary)</span>
<span class="Comment">        d.update(e='f')				# .update(**kwargs)</span>
<span class="Comment">        d.update((('g', 'h'), ('i', 'j')))	# .update(iterable)</span>
<span class="Comment">        for key in d.keys():			# .keys()</span>
<span class="Comment">        for val in d.values():			# .values()</span>
<span class="Comment">        for key, val in d.items():		# .items()</span>
<span class="Comment">        print isinstance(d, vim.Dictionary)	# True</span>
<span class="Comment">        for key in d:				# 遍历所有键</span>
<span class="Comment">        class Dict(vim.Dictionary):		# 子类</span>
<span class="Ignore">&lt;</span>
    注意: 遍历键时不应对字典进行修改。

vim.List 对象					<span class="Ignore">*</span><span class="String">python-List</span><span class="Ignore">*</span>
    类序列对象，用于访问 vim <span class="Ignore">|</span><span class="Identifier">List</span><span class="Ignore">|</span> 类型。
    支持 <span class="Ignore">`</span><span class="Comment">.locked</span><span class="Ignore">`</span> 属性，见 <span class="Ignore">|</span><span class="Identifier">python-.locked</span><span class="Ignore">|</span>。还支持以下方法:
        <span class="PreProc">方法            描述</span><span class="Ignore"> ~</span>
        extend(item)    给列表加入项目 item。

        __new__(), __new__(iterable)
                        用 <span class="Ignore">`</span><span class="Comment">vim.List()</span><span class="Ignore">`</span> 可以建立新的 vim 列表。
                        <span class="Ignore">`</span><span class="Comment">l=vim.List(iterable)</span><span class="Ignore">`</span> 等价于
                        <span class="Ignore">`</span><span class="Comment">l=vim.bindeval('[]');l.extend(iterable)</span><span class="Ignore">`</span>。无参数的版
                        本方法构建空列表。
    示例:<span class="Ignore"> &gt;</span>
<span class="Comment">        l = vim.List(&quot;abc&quot;)		# 构造函数，返回: ['a', 'b', 'c']</span>
<span class="Comment">        l.extend(['abc', 'def'])	# .extend() 方法</span>
<span class="Comment">        print l[1:]			# 分片 (slicing)</span>
<span class="Comment">        l[:0] = ['ghi', 'jkl']		# 分片赋值</span>
<span class="Comment">        print l[0]			# 读取项目</span>
<span class="Comment">        l[0] = 'mno'			# 赋值</span>
<span class="Comment">        for i in l:			# 遍历</span>
<span class="Comment">        print isinstance(l, vim.List)	# True</span>
<span class="Comment">        class List(vim.List):		# 子类</span>

vim.Function 对象				<span class="Ignore">*</span><span class="String">python-Function</span><span class="Ignore">*</span>
    类函数对象，相当于 vim <span class="Ignore">|</span><span class="Identifier">Funcref</span><span class="Ignore">|</span> 对象。接受特殊关键字参数 <span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span>，见
    <span class="Ignore">|</span><span class="Identifier">Dictionary-function</span><span class="Ignore">|</span>。也可用 <span class="Ignore">`</span><span class="Comment">vim.Function(name)</span><span class="Ignore">`</span> 构造函数，等价于
    <span class="Ignore">`</span><span class="Comment">vim.bindeval('function(%s)'%json.dumps(name))</span><span class="Ignore">`</span>。

    属性 (只读):
        <span class="PreProc">属性         描述</span><span class="Ignore"> ~</span>
        name         函数名。
	args         <span class="Ignore">`</span><span class="Comment">None</span><span class="Ignore">`</span> 或用作参数的 <span class="Ignore">|</span><span class="Identifier">python-List</span><span class="Ignore">|</span> 对象。注意 这是参数列表
		     的备份，每次请求参属性时都会重新构建。列表的修改被忽略 (
		     但不适用于参数列表里的容器: 类似于 <span class="Ignore">|</span><span class="Identifier">copy()</span><span class="Ignore">|</span> 而不是
		     <span class="Ignore">|</span><span class="Identifier">deepcopy()</span><span class="Ignore">|</span>)。
        self         <span class="Ignore">`</span><span class="Comment">None</span><span class="Ignore">`</span> 或用作 self 字典的 <span class="Ignore">|</span><span class="Identifier">python-Dictionary</span><span class="Ignore">|</span> 对象。注意
                     调用函数对象时显式的 <span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span> 参数覆盖此属性。
        auto_rebind  布尔值。如果为真，此 Python 对象建立和在 Vim 脚本里存贮的
		     字典里的的偏函数会在此字典被访问时自动重新绑定此字典。这
		     体现了 Vim 内部 <span class="Ignore">`</span><span class="Comment">dict.func</span><span class="Ignore">`</span> (auto_rebind=True) 和
		     <span class="Ignore">`</span><span class="Comment">function(dict.func,dict)</span><span class="Ignore">`</span> (auto_rebind=False) 的差异。
		     如果 <span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span> 属性为 <span class="Ignore">`</span><span class="Comment">None</span><span class="Ignore">`</span>，此属性无意义。

    构造函数额外接受 <span class="Ignore">`</span><span class="Comment">args</span><span class="Ignore">`</span>、<span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">auto_rebind</span><span class="Ignore">`</span> 关键字。如果给出 <span class="Ignore">`</span><span class="Comment">args</span><span class="Ignore">`</span>
    和/或 <span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span> 参数，构造偏函数，见 <span class="Ignore">|</span><span class="Identifier">function()</span><span class="Ignore">|</span>。只有给定 <span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span> 时才使用
    <span class="Ignore">`</span><span class="Comment">auto_rebind</span><span class="Ignore">`</span>，否则无论是否给出，总是假定为 <span class="Ignore">`</span><span class="Comment">True</span><span class="Ignore">`</span>。如果给出 <span class="Ignore">`</span><span class="Comment">self</span><span class="Ignore">`</span>，缺省
    为 <span class="Ignore">`</span><span class="Comment">False</span><span class="Ignore">`</span>。

    示例:<span class="Ignore"> &gt;</span>
<span class="Comment">        f = vim.Function('tr')			# 构造函数</span>
<span class="Comment">        print f('abc', 'a', 'b')		# 调用 tr('abc', 'a', 'b')</span>
<span class="Comment">        vim.command('''</span>
<span class="Comment">            function DictFun() dict</span>
<span class="Comment">                return self</span>
<span class="Comment">            endfunction</span>
<span class="Comment">        ''')</span>
<span class="Comment">        f = vim.bindeval('function(&quot;DictFun&quot;)')</span>
<span class="Comment">        print f(self={})			# 相当于 call('DictFun', [], {})</span>
<span class="Comment">        print isinstance(f, vim.Function)	# True</span>

<span class="Comment">        p = vim.Function('DictFun', self={})</span>
<span class="Comment">        print f()</span>
<span class="Comment">        p = vim.Function('tr', args=['abc', 'a'])</span>
<span class="Comment">        print f('b')</span>

<span class="PreProc">==============================================================================</span>
8. pyeval() 和 py3eval() Vim 函数			<span class="Ignore">*</span><span class="String">python-pyeval</span><span class="Ignore">*</span>

为了访问双向接口的方便，可用 <span class="Ignore">|</span><span class="Identifier">pyeval()</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">py3eval()</span><span class="Ignore">|</span> 函数来计算 Python 表达
式然后返回计算结果给 Vim 脚本。也可用 <span class="Ignore">|</span><span class="Identifier">pyxeval()</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
9. 动态调入						<span class="Ignore">*</span><span class="String">python-dynamic</span><span class="Ignore">*</span>

MS-Windows 和 Unix 上，可以动态调入 Python 库。<span class="Ignore">|</span><span class="Identifier">:version</span><span class="Ignore">|</span> 输出这时应包括
<span class="Ignore">|</span><span class="Identifier">+python/dyn</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">+python3/dyn</span><span class="Ignore">|</span>。

这意味着 Vim 只有在必要时才寻找 Python DLL 文件或共享库。如果不使用 Python 接
口，你就不需要它。这样，即使没有该文件，你也可使用 Vim。


<span class="PreProc">MS-Windows</span><span class="Ignore"> ~</span>

要使用 Python 接口，Python DLL 必须在搜索路径上。控制台窗口里输入 &quot;path&quot; 可以
看到 (搜索路径) 当前使用的目录。也可用 <span class="Type">'pythondll'</span> 或 <span class="Type">'pythonthreedll'</span> 选项来
指定 Python DLL。

DLL 的名字应该匹配 Vim 编译时所使用的 Python 版本。目前，用于 Python 2 的名字
为 &quot;python27.dll&quot;，也就是 Python 2.7。用于 Python 3 的是 python35.dll (Python
3.5)。要确信这一点，编辑 &quot;gvim.exe&quot; 文件并查找 &quot;python\d*.dll\c&quot;。


<span class="PreProc">Unix</span><span class="Ignore"> ~</span>

<span class="Type">'pythondll'</span> 或 <span class="Type">'pythonthreedll'</span> 选项可用来指定 Python 共享库文件，而不用编译时
指定的 DYNAMIC_PYTHON_DLL 或 DYNAMIC_PYTHON3_DLL 文件。共享库的版本必须和 Vim
编译使用的 Python 2.x 或 Python 3 版本保持一致。

<span class="PreProc">==============================================================================</span>
10. Python 3						<span class="Ignore">*</span><span class="String">python3</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:py3</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:python3</span><span class="Ignore">*</span>
<span class="Ignore">`</span><span class="Comment">:py3</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:python3</span><span class="Ignore">`</span> 命令和 <span class="Ignore">`</span><span class="Comment">:python</span><span class="Ignore">`</span> 类似。判断 <span class="Ignore">`</span><span class="Comment">:py3</span><span class="Ignore">`</span> 命令是否可用的一个简单
检查:<span class="Ignore"> &gt;</span>
<span class="Comment">	:py3 print(&quot;Hello&quot;)</span>

要看运行的 Python 版本:<span class="Ignore"> &gt;</span>
<span class="Comment">	:py3 import sys</span>
<span class="Comment">	:py3 print(sys.version)</span>
<span class="Ignore">&lt;</span>							<span class="Ignore">*</span><span class="String">:py3file</span><span class="Ignore">*</span>
<span class="Ignore">`</span><span class="Comment">:py3file</span><span class="Ignore">`</span> 命令和 <span class="Ignore">`</span><span class="Comment">:pyfile</span><span class="Ignore">`</span> 类似。
							<span class="Ignore">*</span><span class="String">:py3do</span><span class="Ignore">*</span>
<span class="Ignore">`</span><span class="Comment">:py3do</span><span class="Ignore">`</span> 命令和 <span class="Ignore">`</span><span class="Comment">:pydo</span><span class="Ignore">`</span> 类似。


Vim 可以用四种方式编译 (:version 输出结果):
1. 无 Python 支持	    (-python、-python3)
2. 只有 Python 2 支持       (+python 或 +python/dyn、-python3)
3. 只有 Python 3 支持       (-python、+python3 或 +python3/dyn)
4. Python 2 和 3 支持       (+python/dyn、+python3/dyn)

关于第四种特殊情况的更多细节:  <span class="Ignore">*</span><span class="String">python-2-and-3</span><span class="Ignore">*</span>

要同时支持 Python 2 和 Python 3，两者必须都是动态载入。

在 Linux/Unix 系统上用这种方式并导入全局符号的时候，使用第二个 Python 版本会导
致系统崩溃。所以，要么载入全局符号但只激活一个 Python 版本，要么考虑不载入全局
符号。后者使 Python 导入 (&quot;import&quot;) 某些期待 Vim 提供某些符号的库的时候会失
败。
							<span class="Ignore">*</span><span class="String">E836</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E837</span><span class="Ignore">*</span>
Vim 的配置脚本根据一个特定的 Python 标准库 (termios) 对所有的库进行猜测。如果
对两个 Python 版本导入该库均成功，那么可以在 Vim 中同时使用两者。否则在一个会
话中，只允许使用先用到的版本。使用第二个版本会得到 E836 或 E837 的错误信息。

这里 Vim 的行为取决于配置所在的系统。如果两个 Python 版本都用了
--enable-shared 进行配置，两者会同时激活。但没有链接进 libPython 的第三方库仍
然会有问题。

要回避这些问题，有以下几个方案:
1. 重新编译有问题的库，把它链接进相应的 libpython.so 里。
2. 重新编译 Vim，只用一个 Python 版本。
3. 配置完后，撤销 auto/config.h 中 PY_NO_RTLD_GLOBAL 的定义。这可能会使 Vim 崩
   溃。

							<span class="Ignore">*</span><span class="String">E880</span><span class="Ignore">*</span>
从 python 抛出 SystemExit 例外不是退出 vim 的好方法，要用:<span class="Ignore"> &gt;</span>
<span class="Comment">	:py vim.command(&quot;qall!&quot;)</span>
<span class="Ignore">&lt;</span>

							<span class="Ignore">*</span><span class="String">has-python</span><span class="Ignore">*</span>
以下方法可用来测试哪个 Python 版本可用:<span class="Ignore"> &gt;</span>
<span class="Comment">	if has('python')</span>
<span class="Comment">	  echo '有 Python 2.x'</span>
<span class="Comment">  	elseif has('python3')</span>
<span class="Comment">	  echo '有 Python 3.x'</span>
<span class="Comment">	endif</span>

注意 不过，当 Python 2 和 3 同时存在且都是动态载入，这些 has() 调用会试图载入
它们。如果两个版本不能同时载入，单单对 Python 2 或 3 是否可用的检查就会导致另
一个版本不能调入。

<span class="PreProc">==============================================================================</span>
11. Python X						<span class="Ignore">*</span><span class="String">python_x</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">pythonx</span><span class="Ignore">*</span>

大多数 python 代码可以用 python 2.6+ 和 python 3 兼容的方式编写，因而我们提供
了 pyx+ 函数和命令。其工作方式和 Python 2 和 3 变种完全相同，但根据
<span class="Type">'pyxversion'</span> 设置选择 Python 版本。

应在 <span class="Ignore">|</span><span class="Identifier">.vimrc</span><span class="Ignore">|</span> 中设置 <span class="Type">'pyxversion'</span>，可为 Python 命令选择 Python 2 或 Python 3。
如果在运行时改变此设置，可能会冒丢失插件状态 (如初始化) 的风险。

要用的模块可放在 <span class="Special">{rtp}</span>/pythonx 目录里。见 <span class="Ignore">|</span><span class="Identifier">pythonx-directory</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:pyx</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:pythonx</span><span class="Ignore">*</span>
<span class="Ignore">`</span><span class="Comment">:pyx</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:pythonx</span><span class="Ignore">`</span> 命令的工作方式类似于 <span class="Ignore">`</span><span class="Comment">:python</span><span class="Ignore">`</span>。要看 <span class="Ignore">`</span><span class="Comment">:pyx</span><span class="Ignore">`</span> 命令是否可用
的简单检查:<span class="Ignore"> &gt;</span>
<span class="Comment">	:pyx print(&quot;Hello&quot;)</span>

要看运行的 Python 版本:<span class="Ignore"> &gt;</span>
<span class="Comment">	:pyx import sys</span>
<span class="Comment">	:pyx print(sys.version)</span>
<span class="Ignore">&lt;</span>
					<span class="Ignore">*</span><span class="String">:pyxfile</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">python_x-special-comments</span><span class="Ignore">*</span>
<span class="Ignore">`</span><span class="Comment">:pyxfile</span><span class="Ignore">`</span> 命令的工作方式类似于 <span class="Ignore">`</span><span class="Comment">:pyfile</span><span class="Ignore">`</span>。不过你可以加上以下注释之一强制 Vim
使用 <span class="Ignore">`</span><span class="Comment">:pyfile</span><span class="Ignore">`</span> 或 <span class="Ignore">`</span><span class="Comment">:py3file</span><span class="Ignore">`</span>:<span class="Ignore"> &gt;</span>
<span class="Comment">  #!/任何字符串/python2		&quot; Shebang。必须是文件的首行。</span>
<span class="Comment">  #!/任何字符串/python3		&quot; Shebang。必须是文件的首行。</span>
<span class="Comment">  # requires python 2.x		&quot; 最大行数取决于 'modelines'。</span>
<span class="Comment">  # requires python 3.x		&quot; 最大行数取决于 'modelines'。</span>
和普通模式行不同，不检查文件尾部。如果找不到这样注释，使用 <span class="Type">'pyxversion'</span> 设置。
							<span class="Ignore">*</span><span class="String">W20</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">W21</span><span class="Ignore">*</span>
如果 Vim 不支持所选的 Python 版本，安静地打印一行消息。用 <span class="Ignore">`</span><span class="Comment">:messages</span><span class="Ignore">`</span> 可读该消
息。

							<span class="Ignore">*</span><span class="String">:pyxdo</span><span class="Ignore">*</span>
<span class="Ignore">`</span><span class="Comment">:pyxdo</span><span class="Ignore">`</span> 命令的工作方式类似于 <span class="Ignore">`</span><span class="Comment">:pydo</span><span class="Ignore">`</span>。

							<span class="Ignore">*</span><span class="String">has-pythonx</span><span class="Ignore">*</span>
可以这样测试 pyx* 系列命令是否可用:<span class="Ignore"> &gt;</span>
<span class="Comment">	if has('pythonx')</span>
<span class="Comment">	  echo 'pyx* 命令可用. (Python ' . &amp;pyx . ')'</span>
<span class="Comment">	endif</span>

如果编译时只有 <span class="Ignore">|</span><span class="Identifier">+python</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">+python3</span><span class="Ignore">|</span> 之一，has() 返回 1。
如果编译时 <span class="Ignore">|</span><span class="Identifier">+python</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">+python3</span><span class="Ignore">|</span> 两者兼有，测试结果取决于 <span class="Type">'pyxversion'</span> 设
置。如果 <span class="Type">'pyxversion'</span> 为 0，先测试 Python 3，如果不可用再测试 Python 2。如果
<span class="Type">'pyxversion'</span> 为 2 或 3，只测试对应的 Python 2 或 3。

注意 为了使 <span class="Ignore">`</span><span class="Comment">has('pythonx')</span><span class="Ignore">`</span> 能工作，可能会试图动态载入 Python 3 或 2。这可能
有副作用，尤其是 Vim 只能载入两者之一的时候。

如果用户希望首选 Python 2 而使用 Python 3 作后备，需要在 <span class="Ignore">|</span><span class="Identifier">.vimrc</span><span class="Ignore">|</span> 里显式设置
<span class="Type">'pyxversion'</span>。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	if has('python')</span>
<span class="Comment">	  set pyx=2</span>
<span class="Comment">	elseif has('python3')</span>
<span class="Comment">	  set pyx=3</span>
<span class="Comment">	endif</span>

<span class="PreProc">==============================================================================</span>
12. 编译时带 Python 支持				<span class="Ignore">*</span><span class="String">python-building</span><span class="Ignore">*</span>

编译时带 Python 2 或 3 支持的若干提示。

UNIX

关于如何打开 Python 接口的支持，见 src/Makefile。

Ubuntu 上需要为 Python 2 安装以下包:
	python
	python-dev
Python 3:
	python3
	pytyon3-dev
Python 3.6:
	python3.6
	pytyon3.6-dev

如果有多于一个 Python 3 版本，在运行 configure 前链接 python3 到你选择的那
个版本。

<span class="PreProc">==============================================================================</span>
 vim&#0058;tw=78:ts=8:ft=help:norl:
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
