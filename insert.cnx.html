<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/github.com/yuweijun/yuweijun.github.io/vim-zh/insert.cnx.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="molokai">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #d0d0d0; background-color: #121212; }
body { font-family: monospace; color: #d0d0d0; background-color: #121212; }
* { font-size: 1em; }
.String { color: #afaf87; }
.Type { color: #5fd7ff; }
.Todo { color: #ffffff; background-color: #080808; padding-bottom: 1px; font-weight: bold; }
.PreProc { color: #87ff00; }
.Identifier { color: #ff8700; }
.Comment { color: #5f5f5f; }
.Statement { color: #d7005f; font-weight: bold; }
.Special { color: #5fd7ff; }
.Ignore { color: #808080; background-color: #080808; padding-bottom: 1px; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span class="String">insert.txt</span><span class="Ignore">*</span>    For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年8月


		  VIM 参考手册    by Bram Moolenaar
				译者: Willis，tocer
				<span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>


						<span class="Ignore">*</span><span class="String">Insert</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">Insert-mode</span><span class="Ignore">*</span>
插入和替换文本					<span class="Ignore">*</span><span class="String">mode-ins-repl</span><span class="Ignore">*</span>

本文件主要讨论插入和替换模式。最后讨论一些其它方式插入文本的命令。

最常用的命令的总览可以在用户手册第 24 章 <span class="Ignore">|</span><span class="Identifier">usr_24.txt</span><span class="Ignore">|</span> 找到。

1. 特殊键						<span class="Ignore">|</span><span class="Identifier">ins-special-keys</span><span class="Ignore">|</span>
2. 特殊的特殊键						<span class="Ignore">|</span><span class="Identifier">ins-special-special</span><span class="Ignore">|</span>
3. <span class="Type">'textwidth'</span> 和 <span class="Type">'wrapmargin'</span> 选项			<span class="Ignore">|</span><span class="Identifier">ins-textwidth</span><span class="Ignore">|</span>
4. <span class="Type">'expandtab'</span>、<span class="Type">'smarttab'</span> 和 <span class="Type">'softtabstop'</span>  选项	<span class="Ignore">|</span><span class="Identifier">ins-expandtab</span><span class="Ignore">|</span>
5. 替换模式						<span class="Ignore">|</span><span class="Identifier">Replace-mode</span><span class="Ignore">|</span>
6. 虚拟替换模式						<span class="Ignore">|</span><span class="Identifier">Virtual-Replace-mode</span><span class="Ignore">|</span>
7. 插入模式补全						<span class="Ignore">|</span><span class="Identifier">ins-completion</span><span class="Ignore">|</span>
8. 插入模式命令						<span class="Ignore">|</span><span class="Identifier">inserting</span><span class="Ignore">|</span>
9. Ex 插入命令						<span class="Ignore">|</span><span class="Identifier">inserting-ex</span><span class="Ignore">|</span>
10. 插入文件						<span class="Ignore">|</span><span class="Identifier">inserting-file</span><span class="Ignore">|</span>

关于如何移动光标到没有字符的位置，另见 <span class="Type">'virtualedit'</span>。对编辑表格有用。

<span class="PreProc">==============================================================================</span>
1. 特殊键						<span class="Ignore">*</span><span class="String">ins-special-keys</span><span class="Ignore">*</span>

在插入和替换模式里，以下字符有特殊含义；其它字符被直接插入。要插入这些特殊字符
到缓冲区里，在前面加上 <span class="Special">CTRL-V</span>。要插入 <span class="Special">&lt;Nul&gt;</span> 字符，使用 &quot;<span class="Special">CTRL-V</span> <span class="Special">CTRL-@</span>&quot; 或者
&quot;<span class="Special">CTRL-V</span> 000&quot;。在有的系统上，你必须使用 &quot;<span class="Special">CTRL-V</span> 003&quot; 来插入 <span class="Special">CTRL-C</span>。注意: 如果
<span class="Special">CTRL-V</span> 被映射，你也许会经常使用 <span class="Special">CTRL-Q</span> 来代替 <span class="Ignore">|</span><span class="Identifier">i_CTRL-Q</span><span class="Ignore">|</span>。

如果插入时你在特殊的语言模式下工作，参见 <span class="Type">'langmap'</span> 选项 <span class="Ignore">|</span><span class="Identifier">'langmap'</span><span class="Ignore">|</span> 了解如何避
免反复进出这些模式。

如果置位了 <span class="Type">'insertmode'</span>，<span class="Special">&lt;Esc&gt;</span> 和一些其它的键有另外的含义。见 <span class="Ignore">|</span><span class="Identifier">'insertmode'</span><span class="Ignore">|</span>。

<span class="PreProc">字符		动作</span><span class="Ignore">	~</span>
<span class="PreProc">-----------------------------------------------------------------------</span>
						<span class="Ignore">*</span><span class="String">i_CTRL-[</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_&lt;Esc&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;Esc&gt;</span> 或 <span class="Special">CTRL-[</span>	结束插入或替换模式，回到普通模式。结束缩写。
		注意: 如果你很难在键盘上敲上 <span class="Special">&lt;Esc&gt;</span> 键，训练自己使用 <span class="Special">CTRL-[</span>。
		如果 Esc 不能用而你使用的是 Mac，试试 <span class="Special">CTRL-E</span>sc。或者在辅助功能
		里关闭收听。
						<span class="Ignore">*</span><span class="String">i_CTRL-C</span><span class="Ignore">*</span>
<span class="Special">CTRL-C</span>		退出插入模式，回到普通模式。不检查缩写。不激活 <span class="Ignore">|</span><span class="Identifier">InsertLeave</span><span class="Ignore">|</span>
		自动命令事件。

						<span class="Ignore">*</span><span class="String">i_CTRL-@</span><span class="Ignore">*</span>
<span class="Special">CTRL-@</span>		插入最近插入的文本，并停止插入 <span class="Special">{Vi: 仅当敲入第一个字符时，而且</span>
		<span class="Special">只限于前 128 个字符}</span>
						<span class="Ignore">*</span><span class="String">i_CTRL-A</span><span class="Ignore">*</span>
<span class="Special">CTRL-A</span>		插入最近插入的文本。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-H</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_&lt;BS&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_BS</span><span class="Ignore">*</span>
<span class="Special">&lt;BS&gt;</span> 或 <span class="Special">CTRL-H</span>	删除光标前的字符 (关于连接行，见 <span class="Ignore">|</span><span class="Identifier">i_backspacing</span><span class="Ignore">|</span>)。
		如果你的 <span class="Special">&lt;BS&gt;</span> 键不正确，见 <span class="Ignore">|</span><span class="Identifier">:fixdel</span><span class="Ignore">|</span>。<span class="Special">{Vi: 不删除自动的缩进}</span>
						<span class="Ignore">*</span><span class="String">i_&lt;Del&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_DEL</span><span class="Ignore">*</span>
<span class="Special">&lt;Del&gt;</span>		删除光标下的字符。如果光标在行尾，并且 <span class="Type">'backspace'</span> 选项包括
		&quot;eol&quot;，删除 <span class="Special">&lt;EOL&gt;</span>；下一行就此附加于当前行之后。
		如果你的 <span class="Special">&lt;Del&gt;</span> 键不正确，见 <span class="Ignore">|</span><span class="Identifier">:fixdel</span><span class="Ignore">|</span>。<span class="Special">{Vi: 不删除自动的缩进}</span>
		<span class="Special">{Vi 无此功能}</span>
						<span class="Ignore">*</span><span class="String">i_CTRL-W</span><span class="Ignore">*</span>
<span class="Special">CTRL-W</span>		删除光标前的单词 (关于连接行，见 <span class="Ignore">|</span><span class="Identifier">i_backspacing</span><span class="Ignore">|</span>)。关于单词的
		定义，见 <span class="Ignore">|</span><span class="Identifier">word-motions</span><span class="Ignore">|</span> 关于 &quot;单词动作&quot; 的定义。
						<span class="Ignore">*</span><span class="String">i_CTRL-U</span><span class="Ignore">*</span>
<span class="Special">CTRL-U</span>		删除当前行上光标前的所有输入字符。如果没有新输入的字符而
		<span class="Type">'backspace'</span> 不为空，删除当前行上光标前的所有字符。
		关于连接行，见 <span class="Ignore">|</span><span class="Identifier">i_backspacing</span><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">i_CTRL-I</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_&lt;Tab&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_Tab</span><span class="Ignore">*</span>
<span class="Special">&lt;Tab&gt;</span> 或 <span class="Special">CTRL-I</span> 插入制表。如果打开 <span class="Type">'expandtab'</span> 选项，等价数目的空格被插入 (使
		用 <span class="Special">CTRL-V</span> <span class="Special">&lt;Tab&gt;</span> 避免这种扩展: 如果 <span class="Special">CTRL-V</span> 被映射，可以使用
		<span class="Special">CTRL-Q</span> <span class="Special">&lt;Tab&gt;</span>。<span class="Ignore">|</span><span class="Identifier">i_CTRL-Q</span><span class="Ignore">|</span>)。另见 <span class="Type">'smarttab'</span> 选项和
		<span class="Ignore">|</span><span class="Identifier">ins-expandtab</span><span class="Ignore">|</span>。
						<span class="Ignore">*</span><span class="String">i_CTRL-J</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_&lt;NL&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;NL&gt;</span> 或 <span class="Special">CTRL-J</span>	开始新行。
						<span class="Ignore">*</span><span class="String">i_CTRL-M</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_&lt;CR&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;CR&gt;</span> 或 <span class="Special">CTRL-M</span>	开始新行。
						<span class="Ignore">*</span><span class="String">i_CTRL-K</span><span class="Ignore">*</span>
<span class="Special">CTRL-K</span> <span class="Special">{char1}</span> <span class="Special">[char2]</span>
		输入二合字母 (见 <span class="Ignore">|</span><span class="Identifier">digraphs</span><span class="Ignore">|</span>)。当 <span class="Special">{char1}</span> 为特殊字符时，该键的
		键码以 &lt;&gt; 形式插入。例如字符串 &quot;<span class="Special">&lt;S-Space&gt;</span>&quot; 可以这样输入:
		<span class="Special">&lt;C-K&gt;&lt;S-Space&gt;</span> (两个键)。两个键都不考虑映射。 <span class="Special">{Vi 无此功能}</span>

<span class="Special">CTRL-N</span>		查找下一个关键字 (见 <span class="Ignore">|</span><span class="Identifier">i_CTRL-N</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>
<span class="Special">CTRL-P</span>		查找上一个关键字 (见 <span class="Ignore">|</span><span class="Identifier">i_CTRL-P</span><span class="Ignore">|</span>)。<span class="Special">{Vi 无此功能}</span>

<span class="Special">CTRL-R</span> <span class="Special">{0-9a-z&quot;%#*+:.-=}</span>					<span class="Ignore">*</span><span class="String">i_CTRL-R</span><span class="Ignore">*</span>
		插入寄存器内容。在输入 <span class="Special">CTRL-R</span> 和第二个字符之间，'&quot;' 会显示出
		来，以提示你需要输入寄存器的名字。文本插入方式和直接输入相同，
		但不使用映射和缩写。如果设置了 <span class="Type">'textwidth'</span>、<span class="Type">'formatoptions'</span> 或
		<span class="Type">'autoindent'</span>，插入的结果会受到影响。这和使用 &quot;p&quot; 命令和用鼠标
		粘贴文本不同。
		特殊寄存器:
			'&quot;'	无名寄存器，包含最近删除或抽出的文本
			'%'	当前文件名
			'#'	轮换文件名
			'*'	剪贴板内容 (X11: 主选择)
			'+'	剪贴板内容
			'/'	最近的搜索模式
			':'	最近的命令行
			'.'	最近插入的文本
			'-'	最近的行内 (少于一行) 删除
							<span class="Ignore">*</span><span class="String">i_CTRL-R_=</span><span class="Ignore">*</span>
			'='	表达式寄存器；你会被提示输入一个表达式 (见
				<span class="Ignore">|</span><span class="Identifier">expression</span><span class="Ignore">|</span>)
				注意 0x80 (十进制 128) 用于特殊键。例如，你可
				以这样移动光标向上:
					<span class="Special">CTRL-R</span> =&quot;\<span class="Special">&lt;Up&gt;</span>&quot;
				用 <span class="Special">CTRL-R</span> <span class="Special">CTRL-R</span> 可以按本义插入文本。
				如果结果是 <span class="Ignore">|</span><span class="Identifier">List</span><span class="Ignore">|</span>，里面的项目被看作行，之间以
				换行符连接。
				如果结果是浮点数，自动转化为字符串。
				调用 append() 或 setline() 会破坏撤销序列。
		关于寄存器见 <span class="Ignore">|</span><span class="Identifier">registers</span><span class="Ignore">|</span>。<span class="Special">{Vi 无此功能}</span>

<span class="Special">CTRL-R</span> <span class="Special">CTRL-R</span> <span class="Special">{0-9a-z&quot;%#*+/:.-=}</span>			<span class="Ignore">*</span><span class="String">i_CTRL-R_CTRL-R</span><span class="Ignore">*</span>
		插入寄存器内容。和单个 <span class="Special">CTRL-R</span> 类似，但是文本按本义插入，而不是
		像键盘输入那样。这意味着如果寄存器包含 <span class="Special">&lt;BS&gt;</span> 这样的字符，结果会
		不同。例如，如果寄存器包含 &quot;ab^Hc&quot;:<span class="Ignore"> &gt;</span>
<span class="Comment">	CTRL-R a		产生 &quot;ac&quot;。</span>
<span class="Comment">	CTRL-R CTRL-R a		产生 &quot;ab^Hc&quot;。</span>
<span class="Ignore">&lt;</span>		<span class="Type">'textwidth'</span>、<span class="Type">'formatoptions'</span> 等等选项仍然适用。如果你连这些都
		想避免，使用 <span class="Special">CTRL-R</span> <span class="Special">CTRL-O</span>，见下。
		'.' 寄存器 (最近插入的文本) 依然如同键盘输入那样的方式插入。
		<span class="Special">{Vi 无此功能}</span>

<span class="Special">CTRL-R</span> <span class="Special">CTRL-O</span> <span class="Special">{0-9a-z&quot;%#*+/:.-=}</span>			<span class="Ignore">*</span><span class="String">i_CTRL-R_CTRL-O</span><span class="Ignore">*</span>
		按本义插入寄存器内容，并且不进行自动缩进。和鼠标粘贴文本相同
		<span class="Ignore">|</span><span class="Identifier">&lt;MiddleMouse&gt;</span><span class="Ignore">|</span>。如果寄存器是面向行的，在当前行之上插入文本，
		类似于 P。
		不会替换字符！
		'.' 寄存器 (最近插入的文本) 依然如同键盘输入那样的方式插入。
		<span class="Special">{Vi 无此功能}</span>

<span class="Special">CTRL-R</span> <span class="Special">CTRL-P</span> <span class="Special">{0-9a-z&quot;%#*+/:.-=}</span>			<span class="Ignore">*</span><span class="String">i_CTRL-R_CTRL-P</span><span class="Ignore">*</span>
		按本义插入寄存器内容，修正缩进，和 <span class="Ignore">|</span><span class="Identifier">[&lt;MiddleMouse&gt;</span><span class="Ignore">|</span> 类似。
		不会替换字符！
		'.' 寄存器 (最近插入的文本) 依然如同键盘输入那样的方式插入。
		<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-T</span><span class="Ignore">*</span>
<span class="Special">CTRL-T</span>		在当前行开始处插入一个 shiftwidth 的缩进。缩进总是取整到
		<span class="Type">'shiftwidth'</span> 的倍数 (这是 vi 兼容的)。
		<span class="Special">{Vi: 只有在缩进内部才能用}</span>
						<span class="Ignore">*</span><span class="String">i_CTRL-D</span><span class="Ignore">*</span>
<span class="Special">CTRL-D</span>		在当前行开始处删除一个 shiftwidth 的缩进。缩进总是取整到
		<span class="Type">'shiftwidth'</span> 的倍数 (这是 vi 兼容的)。
		<span class="Special">{Vi: CTRL-D 只有在使用自动缩进之后才有效}</span>
						<span class="Ignore">*</span><span class="String">i_0_CTRL-D</span><span class="Ignore">*</span>
0 <span class="Special">CTRL-D</span>	删除所有当前行的缩进。
		<span class="Special">{Vi: CTRL-D 只有在使用自动缩进之后才有效}</span>
						<span class="Ignore">*</span><span class="String">i_^_CTRL-D</span><span class="Ignore">*</span>
^ <span class="Special">CTRL-D</span>	删除当前行的所有缩进。缩进在下一行上恢复。这可以用于插入卷标。
		<span class="Special">{Vi: CTRL-D 只有在使用自动缩进之后才有效}</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-V</span><span class="Ignore">*</span>
<span class="Special">CTRL-V</span>		如果下一个是非数字，按本义插入。对特殊键而言，插入其终端代码。
		不然，输入的是字符的十、八或十六进制值。<span class="Ignore">|</span><span class="Identifier">i_CTRL-V_digit</span><span class="Ignore">|</span>。
		<span class="Special">CTRL-V</span> 之后紧接着输入的字符不经过映射。
		<span class="Special">{Vi: 没有十进制字节输入}</span>
		注意: 当 <span class="Special">CTRL-V</span> 被映射时 (例如，用来粘贴文本)，你可能经常需要
		使用 <span class="Special">CTRL-Q</span> 来代替。<span class="Ignore">|</span><span class="Identifier">i_CTRL-Q</span><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">i_CTRL-Q</span><span class="Ignore">*</span>
<span class="Special">CTRL-Q</span>		等同于 <span class="Special">CTRL-V</span>。
		注意: 有的终端连接会吃掉 <span class="Special">CTRL-Q</span>，导致该快捷键无效。在 GUI 版本
		里就不会出现这样的问题。

<span class="Special">CTRL-X</span>		进入 <span class="Special">CTRL-X</span> 模式，一个子模式。那里你可以给出命令来补全单词或者
		滚动窗口。见 <span class="Ignore">|</span><span class="Identifier">i_CTRL-X</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">ins-completion</span><span class="Ignore">|</span>。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-E</span><span class="Ignore">*</span>
<span class="Special">CTRL-E</span>		插入光标下面的字符。<span class="Special">{Vi 无此功能}</span>
						<span class="Ignore">*</span><span class="String">i_CTRL-Y</span><span class="Ignore">*</span>
<span class="Special">CTRL-Y</span>		插入光标上面的字符。<span class="Special">{Vi 无此功能}</span>
		注意 <span class="Special">CTRL-E</span> 和 <span class="Special">CTRL-Y</span> 不使用 <span class="Type">'textwidth'</span>，从而可以从长行里复制
		字符。

						<span class="Ignore">*</span><span class="String">i_CTRL-_</span><span class="Ignore">*</span>
<span class="Special">CTRL-_</span>		切换语言，如下:
		-  在从右到左的窗口里，切换 revins 和 nohkmap，因为在这种情况
		   下英语的输入可能就是倒过来的。
		-  在非从右到左的窗口里，切换 revins 和 hkmap。因为希伯来语等
		   语种可能是倒过来输入的。

		<span class="Special">CTRL-_</span> 移动光标到输入文本的尾部。

		该命令只有在 <span class="Type">'allowrevins'</span> 选项置位的时候才有效。
		请参考 <span class="Ignore">|</span><span class="Identifier">rileft.txt</span><span class="Ignore">|</span>，那里可以了解到更多有关从右到左模式的信
		息。<span class="Special">{Vi 无此功能}</span>
		只有在编译时加入 <span class="Ignore">|</span><span class="Identifier">+rightleft</span><span class="Ignore">|</span> 特性才有效。

						<span class="Ignore">*</span><span class="String">i_CTRL-^</span><span class="Ignore">*</span>
<span class="Special">CTRL-^</span>		切换语言字符输入的使用方式。
		如果定义了语言映射 <span class="Ignore">|</span><span class="Identifier">:lmap</span><span class="Ignore">|</span>:
		- 如果 <span class="Type">'iminsert'</span> 为 1 (使用 langmap 映射)，变成 0 (不使用
		  langmap 映射)。
		- 如果 <span class="Type">'iminsert'</span> 为其它值，变成 1，这样打开了 langmap 映射。
		如果没有定义语言映射:
		- 如果 <span class="Type">'iminsert'</span> 为 2 (使用输入方法 (Input Method))，变成 0
		  (不使用输入方法)。
		- 如果 <span class="Type">'iminsert'</span> 为其它值，变成 2，从而打开输入方法。
		如果 &quot;b:keymap_name&quot; 变量的值设为 1，<span class="Type">'keymap'</span> 选项或者
		&quot;<span class="Special">&lt;lang&gt;</span>&quot; 出现在状态行上。语言映射通常用来输入不同于键盘上能直
		接产生的字符。<span class="Type">'keymap'</span> 选项用来安装若干完整的映射表。<span class="Special">{Vi 无此</span>
		<span class="Special">功能}</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-]</span><span class="Ignore">*</span>
<span class="Special">CTRL-]</span>		切换缩写，不插入字符。<span class="Special">{Vi 无此功能}</span>

						<span class="Ignore">*</span><span class="String">i_&lt;Insert&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;Insert&gt;</span>	切换插入和替换模式。<span class="Special">{Vi 无此功能}</span>
<span class="PreProc">-----------------------------------------------------------------------</span>

						<span class="Ignore">*</span><span class="String">i_backspacing</span><span class="Ignore">*</span>
<span class="Special">&lt;BS&gt;</span>、<span class="Special">CTRL-W</span> 和 <span class="Special">CTRL-U</span> 的效果决定于 <span class="Type">'backspace'</span> 选项 (除非置位了 <span class="Type">'revins'</span>)。这
时一个逗号分隔的项目列表:

<span class="PreProc">项目	    动作</span><span class="Ignore"> ~</span>
indent	    允许退格删除自动缩进
eol	    允许退格删除换行符 (连接行)
start	    允许退格删除插入开始之前的位置；<span class="Special">CTRL-W</span> 和 <span class="Special">CTRL-U</span> 在开始位置停止

如果 <span class="Type">'backspace'</span> 为空，则使用 Vi 兼容的退格方式。不能退格删除自动缩进、回到第
一列之前、或者超过插入开始的地方。

为了后向兼容起见，取值 &quot;0&quot;、&quot;1&quot; 和 &quot;2&quot; 也是允许的，见 <span class="Ignore">|</span><span class="Identifier">'backspace'</span><span class="Ignore">|</span>。

如果 <span class="Type">'backspace'</span> 选项的确包含 &quot;eol&quot;，光标在第一列，而使用了这三个键中的一个，
当前行会和上一行连接。这实际上删除了光标之前的 <span class="Special">&lt;EOL&gt;</span>。
<span class="Special">{Vi: 不会跨行，不会删除插入开始位置之前的内容}</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-V_digit</span><span class="Ignore">*</span>
使用 <span class="Special">CTRL-V</span>，字符的十、八、十六进制值可以直接输入。这样你可以输入任何字符，除
了换行符 (<span class="Special">&lt;NL&gt;</span>，其值为 10)。有五个方法可以输入字符值:

<span class="PreProc">第一个字符	模式	       最大字符数   最大值</span><span class="Ignore"> ~</span>
(无)		十进制		   3		255
o 或 O		八进制		   3		377	 (255)
x 或 X		十六进制	   2		ff	 (255)
u		十六进制	   4		ffff	 (65535)
U		十六进制	   8		7fffffff (2147483647)

通常你会输入最大数目的字符数。这样，要输入空格 (值为 32)，你需要键入
<span class="Special">&lt;C-V&gt;</span>032。你可以忽略开头的零，这时，数字之后的字符必须不能再是数字。其它模式下
也一样: 一旦你输入在该模式下不合法的字符，那么这之前的值就会被使用，而 &quot;非法&quot;
的这个字符以正常的方式继续处理。

如果你输入的值为 10，在文件中最后会以 0 出现。10 是 <span class="Special">&lt;NL&gt;</span>，内部被用来代表 <span class="Special">&lt;Nul&gt;</span>
字符。在写入文件时，<span class="Special">&lt;NL&gt;</span> 字符被翻译成 <span class="Special">&lt;Nul&gt;</span>。而在每行的最后写入 <span class="Special">&lt;NL&gt;</span>。所以，如
果你想在文件中插入 <span class="Special">&lt;NL&gt;</span> 字符，你需要使用换行。

						<span class="Ignore">*</span><span class="String">i_CTRL-X</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">insert_expand</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> 进入一个子模式，那里可以使用若干命令。绝大多数命令执行关键字补全；见
<span class="Ignore">|</span><span class="Identifier">ins-completion</span><span class="Ignore">|</span>。只有在 Vim 编译时加入 <span class="Ignore">|</span><span class="Identifier">+insert_expand</span><span class="Ignore">|</span> 特性才能使用这些功
能。

有两个命令可以在不退出插入模式的前提下上下滚动窗口:

						<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-E</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-E</span>		窗口滚动上移一行。
			补全时看这里: <span class="Ignore">|</span><span class="Identifier">complete_CTRL-E</span><span class="Ignore">|</span>

						<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-Y</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-Y</span>		窗口滚动下移一行。
			补全时看这里: <span class="Ignore">|</span><span class="Identifier">complete_CTRL-Y</span><span class="Ignore">|</span>

按了 <span class="Special">CTRL-X</span> 以后，每个 <span class="Special">CTRL-E</span> (<span class="Special">CTRL-Y</span>) 滚动窗口上 (下) 移一行，除非这使得光标
不得不离开当前文件中所在的位置。一旦按了另外一个键，<span class="Special">CTRL-X</span> 模式就会退出，而回
到插入模式下解释该键。


<span class="PreProc">==============================================================================</span>
2. 特殊的特殊键					<span class="Ignore">*</span><span class="String">ins-special-special</span><span class="Ignore">*</span>

一些的键是特殊的。它们停止当前的插入，做一些事情，然后重新插入。这意味着你可以
不脱离插入模式的情况下做一些事情。这适合于经常使用插入模式的用户，就像编辑器没
有单独的普通模式一样。这时，也可以设置 <span class="Type">'backspace'</span> 选项为 &quot;indent,eol,start&quot;
还有置位 <span class="Type">'insertmode'</span> 选项。如果你想给功能键映射到一个命令，你可以使用
<span class="Special">CTRL-O</span>。

这些键前后的改动 (插入或者删除字符) 可以分别撤销。只有最后的改动可以重做，而其
行为和 &quot;i&quot; 命令相当。

<span class="PreProc">字符		动作</span><span class="Ignore">	~</span>
<span class="PreProc">-----------------------------------------------------------------------</span>
<span class="Special">&lt;Up&gt;</span>		光标上移一行				     <span class="Ignore">*</span><span class="String">i_&lt;Up&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;Down&gt;</span>		光标下移一行				     <span class="Ignore">*</span><span class="String">i_&lt;Down&gt;</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> <span class="Special">&lt;Up&gt;</span>	光标上移一行，到插入开始时所在的列	     <span class="Ignore">*</span><span class="String">i_CTRL-G_&lt;Up&gt;</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> k	光标上移一行，到插入开始时所在的列  	     <span class="Ignore">*</span><span class="String">i_CTRL-G_k</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> <span class="Special">CTRL-K</span>	光标上移一行，到插入开始时所在的列 	     <span class="Ignore">*</span><span class="String">i_CTRL-G_CTRL-K</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> <span class="Special">&lt;Down&gt;</span>	光标下移一行，到插入开始时所在的列	     <span class="Ignore">*</span><span class="String">i_CTRL-G_&lt;Down&gt;</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> j	光标下移一行，到插入开始时所在的列	     <span class="Ignore">*</span><span class="String">i_CTRL-G_j</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> <span class="Special">CTRL-J</span>	光标下移一行，到插入开始时所在的列	     <span class="Ignore">*</span><span class="String">i_CTRL-G_CTRL-J</span><span class="Ignore">*</span>
<span class="Special">&lt;Left&gt;</span>		光标左移一个字符			     <span class="Ignore">*</span><span class="String">i_&lt;Left&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;Right&gt;</span>		光标右移一个字符		     	     <span class="Ignore">*</span><span class="String">i_&lt;Right&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-Left&gt;</span>	光标反向一个单词 (像 &quot;b&quot; 命令那样)	     <span class="Ignore">*</span><span class="String">i_&lt;S-Left&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;C-Left&gt;</span>	光标反向一个单词 (像 &quot;b&quot; 命令那样)	     <span class="Ignore">*</span><span class="String">i_&lt;C-Left&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-Right&gt;</span>	光标正向一个单词 (像 &quot;w&quot; 命令那样)	     <span class="Ignore">*</span><span class="String">i_&lt;S-Right&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;C-Right&gt;</span>	光标正向一个单词 (像 &quot;w&quot; 命令那样)	     <span class="Ignore">*</span><span class="String">i_&lt;C-Right&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;Home&gt;</span>		光标移到该行第一个字符			     <span class="Ignore">*</span><span class="String">i_&lt;Home&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;End&gt;</span>		光标移到该行最后一个字符		     <span class="Ignore">*</span><span class="String">i_&lt;End&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;C-Home&gt;</span>	光标移到该文件第一个字符		     <span class="Ignore">*</span><span class="String">i_&lt;C-Home&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;C-End&gt;</span>		光标移到该文件最后一个字符		     <span class="Ignore">*</span><span class="String">i_&lt;C-End&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;LeftMouse&gt;</span>	光标移动鼠标点击处			     <span class="Ignore">*</span><span class="String">i_&lt;LeftMouse&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-Up&gt;</span>		上翻窗口一页				     <span class="Ignore">*</span><span class="String">i_&lt;S-Up&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;PageUp&gt;</span>	上翻窗口一页			     	     <span class="Ignore">*</span><span class="String">i_&lt;PageUp&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-Down&gt;</span>	下翻窗口一页				     <span class="Ignore">*</span><span class="String">i_&lt;S-Down&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;PageDown&gt;</span>	下翻窗口一页				     <span class="Ignore">*</span><span class="String">i_&lt;PageDown&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;ScrollWheelDown&gt;</span>    窗口向下滚动三行			<span class="Ignore">*</span><span class="String">i_&lt;ScrollWheelDown&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-ScrollWheelDown&gt;</span>  窗口向下滚动一个整页		<span class="Ignore">*</span><span class="String">i_&lt;S-ScrollWheelDown&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;ScrollWheelUp&gt;</span>      窗口向上滚动三行			<span class="Ignore">*</span><span class="String">i_&lt;ScrollWheelUp&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-ScrollWheelUp&gt;</span>    窗口向上滚动一个整页		<span class="Ignore">*</span><span class="String">i_&lt;S-ScrollWheelUp&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;ScrollWheelLeft&gt;</span>    窗口向左滚动六列			<span class="Ignore">*</span><span class="String">i_&lt;ScrollWheelLeft&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-ScrollWheelLeft&gt;</span>  窗口向左滚动一个整页		<span class="Ignore">*</span><span class="String">i_&lt;S-ScrollWheelLeft&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;ScrollWheelRight&gt;</span>   窗口向右滚动六列			<span class="Ignore">*</span><span class="String">i_&lt;ScrollWheelRight&gt;</span><span class="Ignore">*</span>
<span class="Special">&lt;S-ScrollWheelRight&gt;</span> 窗口向右滚动一个整页		<span class="Ignore">*</span><span class="String">i_&lt;S-ScrollWheelRight&gt;</span><span class="Ignore">*</span>
<span class="Special">CTRL-O</span>		执行命令，然后返回到插入模式		     <span class="Ignore">*</span><span class="String">i_CTRL-O</span><span class="Ignore">*</span>
<span class="Special">CTRL-\</span> <span class="Special">CTRL-O</span>	类似于 <span class="Special">CTRL-O</span>，但不移动光标		     <span class="Ignore">*</span><span class="String">i_CTRL-\_CTRL-O</span><span class="Ignore">*</span>
<span class="Special">CTRL-L</span>		置位 <span class="Type">'insertmode'</span> 时: 转到普通模式	     <span class="Ignore">*</span><span class="String">i_CTRL-L</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> u	打断撤销序列，开始新的改变		     <span class="Ignore">*</span><span class="String">i_CTRL-G_u</span><span class="Ignore">*</span>
<span class="Special">CTRL-G</span> U	下个左/右光标移动不打断撤销 (但只在光标停在  <span class="Ignore">*</span><span class="String">i_CTRL-G_U</span><span class="Ignore">*</span>
		同一行上才是如此)
<span class="PreProc">-----------------------------------------------------------------------</span>

注意: 如果光标键把你带出插入模式，查查 <span class="Type">'noesckeys'</span> 选项。

<span class="Special">CTRL-O</span> 命令有时有副作用: 如果光标在行尾之后，它会先被移动该行最后一个字符上。
在映射里，通常更好的方法是使用 <span class="Special">&lt;Esc&gt;</span>  (先在文本中放一个 &quot;x&quot;，<span class="Special">&lt;Esc&gt;</span> 这时总会把
光标放到它的上面)。或者使用 <span class="Special">CTRL-\</span> <span class="Special">CTRL-O</span>，不过这时要注意光标可能移到行尾之外
的位置。注意 <span class="Special">CTRL-\</span> <span class="Special">CTRL-O</span> 之后的命令仍然可以移动光标，光标不会自动恢复到原来
的位置。

<span class="Special">CTRL-O</span> 命令带你到普通模式，此时你如使用进入插入模式的命令，插入模式通常不会嵌
套。因而，输入完 &quot;a<span class="Special">&lt;C-O&gt;</span>a&quot; 然后按 <span class="Special">&lt;Esc&gt;</span>，你会回到普通模式，不需要按 <span class="Special">&lt;Esc&gt;</span> 两
次。此规则有例外，如果不是键入此命令，也即，在执行映射或执行脚本时，就会嵌套。
这样，短暂切换到插入模式的映射才可以工作。

不是在所有的终端上都能用 Shift + 光标键。

另外一个副作用是 &quot;i&quot; 或 &quot;a&quot; 命令之前指定的计数会被忽略。这是因为要实现 <span class="Special">CTRL-O</span>
之后的命令的重复执行太复杂了。

一个使用 <span class="Special">CTRL-G</span> u 的例子:<span class="Ignore"> &gt;</span>

<span class="Comment">	:inoremap &lt;C-H&gt; &lt;C-G&gt;u&lt;C-H&gt;</span>

它重定义退格键开始新的撤销序列。你可以撤销退格键的效果，而不会改变你之前输入的
内容，就像 <span class="Special">CTRL-O</span> u 那样。另一例:<span class="Ignore"> &gt;</span>

<span class="Comment">	:inoremap &lt;CR&gt; &lt;C-]&gt;&lt;C-G&gt;u&lt;CR&gt;</span>

这样，每行之后就不能撤销。在此之前也进行缩写的扩展。

一个使用 <span class="Special">CTRL-G</span> U 的例子:<span class="Ignore"> &gt;</span>

<span class="Comment">	inoremap &lt;Left&gt;  &lt;C-G&gt;U&lt;Left&gt;</span>
<span class="Comment">	inoremap &lt;Right&gt; &lt;C-G&gt;U&lt;Right&gt;</span>
<span class="Comment">	inoremap &lt;expr&gt; &lt;Home&gt; col('.') == match(getline('.'), '\S') + 1 ?</span>
<span class="Comment">	 \ repeat('&lt;C-G&gt;U&lt;Left&gt;', col('.') - 1) :</span>
<span class="Comment">	 \ (col('.') &lt; match(getline('.'), '\S') ?</span>
<span class="Comment">	 \     repeat('&lt;C-G&gt;U&lt;Right&gt;', match(getline('.'), '\S') + 0) :</span>
<span class="Comment">	 \     repeat('&lt;C-G&gt;U&lt;Left&gt;', col('.') - 1 - match(getline('.'), '\S')))</span>
<span class="Comment">	inoremap &lt;expr&gt; &lt;End&gt; repeat('&lt;C-G&gt;U&lt;Right&gt;', col('$') - col('.'))</span>
<span class="Comment">	inoremap ( ()&lt;C-G&gt;U&lt;Left&gt;</span>

这样，可以在插入模式下使用光标键而不会打断撤销序列，从而 . (重做) 命令就能正常
工作。
另外，输入以下的文本 (使用上述的 &quot;(&quot; 映射):<span class="Ignore"> &gt;</span>

<span class="Comment">   Lorem ipsum (dolor</span>

可以用 . 重复直到出现期待结果为止

   Lorem ipsum (dolor)

<span class="Special">CTRL-O</span> 的使用分割撤销: 之前输入的文本和之后的被分别撤销。如果不想如此 (比如用
在映射里)，你可以用 <span class="Special">CTRL-R</span> = <span class="Ignore">|</span><span class="Identifier">i_CTRL-R</span><span class="Ignore">|</span>。例如，要调用函数:<span class="Ignore"> &gt;</span>
<span class="Comment">	:imap &lt;F2&gt; &lt;C-R&gt;=MyFunc()&lt;CR&gt;</span>

如果正确设置 <span class="Type">'whichwrap'</span> 选项，在一行的第一个/最后一个字符上按 <span class="Special">&lt;Left&gt;</span> 和
<span class="Special">&lt;Right&gt;</span> 键使得光标回绕到上一行/下一行。

<span class="Special">CTRL-G</span> j 和 <span class="Special">CTRL-G</span> k 命令可以用来在某一列前插入文本。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">   int i;</span>
<span class="Comment">   int j;</span>
把光标定位在第一个 &quot;int&quot; 上，输入 &quot;istatic <span class="Special">&lt;C-G&gt;</span>j       &quot;。结果是:<span class="Ignore"> &gt;</span>
<span class="Comment">   static int i;</span>
<span class="Comment">	  int j;</span>
要把相同的文本插入在每行的某列之前，使用可视列块命令 &quot;I&quot; <span class="Ignore">|</span><span class="Identifier">v_b_I</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
3. <span class="Type">'textwidth'</span> 和 <span class="Type">'wrapmargin'</span> 选项			<span class="Ignore">*</span><span class="String">ins-textwidth</span><span class="Ignore">*</span>

<span class="Type">'textwidth'</span> 选项可以用来在行变得很长之前自动断行。设置 <span class="Type">'textwidth'</span> 选项为希望
的最大行长。如果你输入更多字符 (不是空格或者制表)，最后一个单词会放在一个新行
上 (除非这是该行唯一一个单词)。如果你设置 <span class="Type">'textwidth'</span> 为 0，关闭该特性。

<span class="Type">'wrapmargin'</span> 选项做的事情基本相同。区别在于 <span class="Type">'textwidth'</span> 是一个固定的宽度，而
<span class="Type">'wrapmargin'</span> 根据屏幕的宽度设置。如果设置 <span class="Type">'wrapmargin'</span>，这等价于 <span class="Type">'textwidth'</span>
设为 (columns - <span class="Type">'wrapmargin'</span>)，其中 columns 是屏幕的宽度。

如果同时设置 <span class="Type">'textwidth'</span> 和 <span class="Type">'wrapmargin'</span>，使用 <span class="Type">'textwidth'</span>。

如果你并不真的想断开行，而只是想文本行在合适的位置回绕，见 <span class="Type">'linebreak'</span> 选项。

文本行只有在插入模式下或者附加到行后的时候才会自动断开。在替换模式下，只要行的
长度没有变，就不会断行。

长行在你输入一个出现在边界之后的非空白字符的时候断开。什么时候断行的限制还可以
通过在 <span class="Type">'formatoptions'</span> 选项增加如下字母决定:
&quot;l&quot;  断行只有在插入开始时文本行的长度不超过 <span class="Type">'textwidth'</span> 才会发生。
&quot;v&quot;  只有在当前插入命令中输入的空白字符上才会断行。这是和 Vi 最兼容的行为。
&quot;lv&quot; 断行只有在插入开始时文本行的长度不超过 <span class="Type">'textwidth'</span> 并且在当前插入命令中输
     入的空白字符上才会发生。和 &quot;l&quot; 唯一的不同在超过 <span class="Type">'textwidth'</span> 边界之后输入
     非空白字符的时候。

通常使用内部函数来决定哪里断行。如果你想使用不同的方法，设置 <span class="Type">'formatexpr'</span> 选项
为一个表达式，它处理换行的行为。

如果你想排版文本块，可以使用 &quot;gq&quot; 操作符。输入 &quot;gq&quot; 和可以移动光标到块尾的移动
命令。在许多情况下，命令 &quot;gq}&quot; 会做你想要做的事情 (排版直到段落尾部)。或者，你
可以使用 &quot;gqap&quot;。它会排版整个段落，和当前光标所在的位置无关。或者，你可以使用
可视模式: 敲击 &quot;v&quot;，移动到块尾，然后输入 &quot;gq&quot;。另见 <span class="Ignore">|</span><span class="Identifier">gq</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
4. <span class="Type">'expandtab'</span>、<span class="Type">'smarttab'</span> 和 <span class="Type">'softtabstop'</span> 选项	<span class="Ignore">*</span><span class="String">ins-expandtab</span><span class="Ignore">*</span>

如果打开 <span class="Type">'expandtab'</span> 选项，空格可以用来填充制表键的空白位置。如果你需要输入一
个真正的 <span class="Special">&lt;Tab&gt;</span>，先输入 <span class="Special">CTRL-V</span> (用 <span class="Special">CTRL-Q</span> 如果 <span class="Special">CTRL-V</span> 被映射的话 <span class="Ignore">|</span><span class="Identifier">i_CTRL-Q</span><span class="Ignore">|</span>)。
缺省 <span class="Type">'expandtab'</span> 选项是关闭的。注意 在替换模式里，一个字符被多个空格字符所代
替。结果是，行内的字符数会增加。退格键只会一次删一个空格键。原来的字符只有在一
个空格 (最后一个) 上退格才能得回来 <span class="Special">{Vi 没有 'expandtab' 选项}</span>

							<span class="Ignore">*</span><span class="String">ins-smarttab</span><span class="Ignore">*</span>
当 <span class="Type">'smarttab'</span> 选项打开时，<span class="Special">&lt;Tab&gt;</span> 在行首插入 <span class="Type">'shiftwidth'</span> 个位置，而在其它地方插
入 <span class="Type">'tabstop'</span> 个。这意味着经常会插入空格而不是 <span class="Special">&lt;Tab&gt;</span> 字符。当 <span class="Type">'smarttab'</span> 关闭
时，<span class="Special">&lt;Tab&gt;</span> 总是插入 <span class="Type">'tabstop'</span> 个位置，而 <span class="Type">'shiftwidth'</span> 只有在 &quot;&gt;&gt;&quot; 和类似的命令
中才会用到。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">ins-softtabstop</span><span class="Ignore">*</span>
如果 <span class="Type">'softtabstop'</span> 选项不为零，<span class="Special">&lt;Tab&gt;</span> 插入 <span class="Type">'softtabstop'</span> 个位置，而过去用来删除
空格的  <span class="Special">&lt;BS&gt;</span>，现在会删除 <span class="Type">'softtabstop'</span> 个位置。感觉上， <span class="Type">'tabstop'</span> 被设成了
<span class="Type">'softtabstop'</span> 的值，但实际上一个真正的 <span class="Special">&lt;Tab&gt;</span> 字符还是占据 <span class="Type">'tabstop'</span> 个位置。从
而，你的文件在别的应用程序里看起来还是正确的。

如果 <span class="Type">'softtabstop'</span> 不为零，<span class="Special">&lt;BS&gt;</span> 会试图删除尽量多的空白，以便能够回到往前
<span class="Type">'softtabstop'</span> 的位置，除非前面一个插入的字符正好就是一个空格，这时它只会删除光
标前的那个字符。否则，你不一定总能删除光标前的一个字符。你需要先删除
<span class="Type">'softabstop'</span> 个字符，然后再输入额外的空格，以到达你想要的地方。

<span class="PreProc">==============================================================================</span>
5. 替换模式				<span class="Ignore">*</span><span class="String">Replace</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">Replace-mode</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">mode-replace</span><span class="Ignore">*</span>

在普通模式里输入 &quot;R&quot; 命令进入替换模式。

在替换模式里，行内的单个字符在你输入字符的时候被删除。如果没有字符可以删了 (在
行尾)，输入的字符被附加 (和插入模式一样)。这样，一行内的字符数保持不变，直到你
到达行尾为止。如果输入了 <span class="Special">&lt;NL&gt;</span>，插入一个换行符，但不会删除任何字符。

要小心 <span class="Special">&lt;Tab&gt;</span> 字符。如果你输入一个正常的打印字符在它上面，字符数仍然一样，但是
列数看起来少了。

如果你在替换模式下删除字符 (用 <span class="Special">&lt;BS&gt;</span>、<span class="Special">CTRL-W</span> 或 <span class="Special">CTRL-U</span>)，实际发生的事是你删除了
改变。被替换的字符被复原了。如果你的输入超过已有的部分，新增的字符被删除了。实
际上，这可以看作是一次一个字符的撤销。

如果打开了 <span class="Type">'expandtab'</span> 选项，<span class="Special">&lt;Tab&gt;</span> 会用多个空格替换一个字符。结果是，行内的字
符数增加了。退格键只能一次删一个空格。原来的字符只有在一个空格 (最后一个) 上退
格才能得回来 <span class="Special">{Vi 没有 'expandtab' 选项}</span>

<span class="PreProc">==============================================================================</span>
6. 虚拟替换模式				<span class="Ignore">*</span><span class="String">vreplace-mode</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">Virtual-Replace-mode</span><span class="Ignore">*</span>

在普通模式里输入 &quot;gR&quot; 命令进入虚拟替换模式。
{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+vreplace</span><span class="Ignore">|</span> 特性才会有效}
<span class="Special">{Vi 没有虚拟替换模式}</span>

虚拟替换模式和替换模式类似，但不是替换文件里的实际字符，而是替换屏幕的领地。这
样，文件里的字符看起来不会移动。

所以，如果你输入了 <span class="Special">&lt;Tab&gt;</span>，它会替换多个普通的字符，而如果你在 <span class="Special">&lt;Tab&gt;</span> 上输入字
母，它可能什么都没有代替，因为 <span class="Special">&lt;Tab&gt;</span> 还是会占据相同的位置。

输入 <span class="Special">&lt;NL&gt;</span> 不是导致文件后面的字符看起来在移动。结果是，当前行的后面部分被 <span class="Special">&lt;NL&gt;</span>
所替换 (也就是，它们被删除)，而替换继续在下一行进行。新行_不_会被插入，除非你
到达文件尾部之后。

输入 <span class="Special">CTRL-T</span> 和 <span class="Special">CTRL-D</span> 会看到有趣的效果。光标前面的字符向一边移动，跟平常一样，
但是光标后面的字符保持不动。<span class="Special">CTRL-T</span> 会隐藏一些被移动字符遮盖的旧行，但是 <span class="Special">CTRL-D</span>
会重新让它们显现出来。

和替换模式一样，使用 <span class="Special">&lt;BS&gt;</span> 等会恢复被替换的字符。即使和 <span class="Type">'smartindent'</span>、<span class="Special">CTRL-T</span>
和 <span class="Special">CTRL-D</span>、<span class="Type">'expandtab'</span>、<span class="Type">'smarttab'</span>、<span class="Type">'softtabstop'</span> 等一起使用的效果也是如此。

在 <span class="Type">'list'</span> 模式下，虚拟替换模式的行为和不在 <span class="Type">'list'</span> 模式下一样，除非 <span class="Type">'cpoptions'</span>
里设置了 &quot;L&quot;。

注意 此模式下，不在光标位置上的字符看起来在移动的可能性仅有如下情况: 列表模式
<span class="Ignore">|</span><span class="Identifier">'list'</span><span class="Ignore">|</span>，置位 <span class="Type">'wrap'</span> 时偶尔也会出现 (这时行改变长度，使得比屏幕宽度更窄或者更
宽)。其他情况下会插入空格以防止之后的字符移动。

该模式对编辑 <span class="Special">&lt;Tab&gt;</span> 分隔表格列的时候很有用，因为输入新的数据的时候同时还能保持
所有的列对齐。

<span class="PreProc">==============================================================================</span>
7. 插入模式补全						<span class="Ignore">*</span><span class="String">ins-completion</span><span class="Ignore">*</span>

在插入和替换模式下，有若干命令可以补全输入的部分关键字或者行。这可以用于使用复
杂关键字的场合 (例如，函数名里有大写字母或者下划线)。

如果编译时关闭了 <span class="Ignore">|</span><span class="Identifier">+insert_expand</span><span class="Ignore">|</span> 特性，这些功能都不可用。

补全可以是针对:

1. 整行							<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-L</span><span class="Ignore">|</span>
2. 当前文件内的关键字					<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-N</span><span class="Ignore">|</span>
3. <span class="Type">'dictionary'</span>	的关键字				<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-K</span><span class="Ignore">|</span>
4. <span class="Type">'thesaurus'</span> 的关键字，同义词风格			<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-T</span><span class="Ignore">|</span>
5. 当前和头文件内的关键字				<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-I</span><span class="Ignore">|</span>
6. 标签							<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-]</span><span class="Ignore">|</span>
7. 文件名						<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-F</span><span class="Ignore">|</span>
8. 定义或宏						<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-D</span><span class="Ignore">|</span>
9. Vim 命令						<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-V</span><span class="Ignore">|</span>
10. 用户定义的补全					<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-U</span><span class="Ignore">|</span>
11. 全能 (omni) 补全					<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-O</span><span class="Ignore">|</span>
12. 拼写建议						<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_s</span><span class="Ignore">|</span>
13. <span class="Type">'complete'</span> 的关键字					<span class="Ignore">|</span><span class="Identifier">i_CTRL-N</span><span class="Ignore">|</span> <span class="Ignore">|</span><span class="Identifier">i_CTRL-P</span><span class="Ignore">|</span>

所有这些，除了 <span class="Special">CTRL-N</span> 和 <span class="Special">CTRL-P</span> 以外，都通过 <span class="Special">CTRL-X</span> 模式完成。这是插入和替
换模式的一个子模式。你可以键入 <span class="Special">CTRL-X</span> 和一个 <span class="Special">CTRL-X</span> 命令进入 <span class="Special">CTRL-X</span> 模式。要退
出，输入不合法的 <span class="Special">CTRL-X</span> 模式的命令。合法的键包括 <span class="Special">CTRL-X</span> 命令本身，<span class="Special">CTRL-N</span> (下一
个) 和 <span class="Special">CTRL-P</span> (前一个)。

如果你想调整匹配的大小写，参见 <span class="Type">'infercase'</span> 选项。

							<span class="Ignore">*</span><span class="String">complete_CTRL-E</span><span class="Ignore">*</span>
如果补全处于激活状态，可以用 <span class="Special">CTRL-E</span> 来停止补全并回到原来录入的文字。<span class="Special">CTRL-E</span> 本
身不会被插入。

							<span class="Ignore">*</span><span class="String">complete_CTRL-Y</span><span class="Ignore">*</span>
如果已经弹出菜单，可以使用 <span class="Special">CTRL-Y</span> 停止补全并接受当前的选择项。<span class="Special">CTRL-Y</span> 本身不会
被插入。键入空格、回车或者其他不可显示字符将离开补全模式并插入键入的字符。

弹出菜单显示时，有一些特殊键可用，见 <span class="Ignore">|</span><span class="Identifier">popupmenu-keys</span><span class="Ignore">|</span>。

注意: <span class="Special">CTRL-X</span> 模式下合法的键不经过映射。这使得 &quot;:map ^F ^X^F&quot; 能够工作 (其中 ^F
是 <span class="Special">CTRL-F</span> 而 ^X 是 <span class="Special">CTRL-X</span>)。能够使得 <span class="Special">CTRL-X</span> 模式退出的键 (任何不是合法 <span class="Special">CTRL-X</span>
模式命令的键) 则经过映射。
另外，通过 <span class="Type">'complete'</span> 的补全也使用映射。

注意: 补全激活时，不能递归使用插入模式。以某种方式调用 &quot;:normal i..&quot; 的映射将
产生 E523 错误。

建议使用以下映射来使得输入补全命令简单一点 (不过它们可能屏蔽其它的命令):<span class="Ignore"> &gt;</span>
<span class="Comment">    :inoremap ^] ^X^]</span>
<span class="Comment">    :inoremap ^F ^X^F</span>
<span class="Comment">    :inoremap ^D ^X^D</span>
<span class="Comment">    :inoremap ^L ^X^L</span>

一个特例是，执行寄存器插入的 <span class="Special">CTRL-R</span> (见 <span class="Ignore">|</span><span class="Identifier">i_CTRL-R</span><span class="Ignore">|</span>) 不会退出 <span class="Special">CTRL-X</span> 模式。这主
要是为了允许通过使用 '=' 寄存器来调用若干函数来决定下一个操作。如果该寄存器的
内容 (或者 '=' 寄存器计算的结果) 不是合法的 <span class="Special">CTRL-X</span> 模式键，那么就会退出 <span class="Special">CTRL-X</span>
模式，如同键盘输入这些内容一样。

例如，下面的程序会如此映射 <span class="Special">&lt;Tab&gt;</span>: 如果当前行只有空白，就插入 <span class="Special">&lt;Tab&gt;</span>，不然就开始
或继续 <span class="Special">CTRL-N</span> 补全操作:<span class="Ignore"> &gt;</span>

<span class="Comment">	function! CleverTab()</span>
<span class="Comment">	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'</span>
<span class="Comment">	      return &quot;\&lt;Tab&gt;&quot;</span>
<span class="Comment">	   else</span>
<span class="Comment">	      return &quot;\&lt;C-N&gt;&quot;</span>
<span class="Comment">	   endif</span>
<span class="Comment">	endfunction</span>
<span class="Comment">	inoremap &lt;Tab&gt; &lt;C-R&gt;=CleverTab()&lt;CR&gt;</span>



补全整行						<span class="Ignore">*</span><span class="String">compl-whole-line</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-L</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-L</span>		反向搜索和当前行光标前字符序列完全相同的行。忽略缩进。
			找到的行插入在光标的前面。
			<span class="Type">'complete'</span> 选项用来决定匹配在哪个缓冲区里搜索，已载入
			和未载入的缓冲区都被使用。
	<span class="Special">CTRL-L</span>	或
	<span class="Special">CTRL-P</span>		反向搜索前一个匹配行。替换上一次匹配的行。

	<span class="Special">CTRL-N</span>		正向搜索下一个匹配行。替换上一次匹配的行。

	<span class="Special">CTRL-X</span> <span class="Special">CTRL-L</span>	在扩展一行以后，你可以通过接着输入 <span class="Special">CTRL-X</span> <span class="Special">CTRL-L</span> 得到
			紧接着匹配行之后的行，直到见到两个 <span class="Special">CTRL-X</span> 为止。只能用
			于已载入的缓冲区。

补全当前文件内的关键字					<span class="Ignore">*</span><span class="String">compl-current</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-P</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-N</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span>		正向搜索以光标前面的关键字开始的单词。找到的关键字插入
			在光标的前面。

<span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span>		反向搜索以光标前面的关键字开始的单词。找到的关键字插入
			在光标的前面。

	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 或
	<span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span>	继续使用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 或 <span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span> 会复制上次本类
			型补全在其它上下文里扩展的单词之后紧跟的单词，直到见到
			两个 <span class="Special">CTRL-X</span> 为止。

如果在光标的前面有一个关键字 (由字母字符和 <span class="Type">'iskeyword'</span> 指定的字符组成的名字)，
它的前面再加上 &quot;\&lt;&quot; (含义: 单词开始) 就被用作搜索模式。否则 &quot;\&lt;\k\k&quot; 被用作搜
索模式 (任何包含至少两个字符的关键字的开始)。

在替换模式里，替换的字符数目决定于匹配字符串的长度。这和直接在替换模式下键盘输
入经过替换的字符串类似。

如果光标前面不是一个合法的关键字字符，则匹配任何至少有两个字符的关键字。
	例如，要得到:
	    printf(&quot;(%g, %g, %g)&quot;, vector[0], vector[1], vector[2]);
	只需输入:
	    printf(&quot;(%g, %g, %g)&quot;, vector[0], ^P[1], ^P[2]);

搜索会在文件末尾回绕，这里不使用 <span class="Type">'wrapscan'</span> 的值。

相同的补全内容多次重复会被跳过；这样每次 <span class="Special">CTRL-N</span> 和 <span class="Special">CTRL-P</span> 都会插入不同的匹配
(除非只有一个匹配的关键字)。

永远不会得到单个字符的匹配，因为它们通常不是你真想要的。
	例如，要得到:
		printf(&quot;name = %s\n&quot;, name);
	或者:
		printf(&quot;name = %s\n&quot;, n^P);
	甚至:
		printf(&quot;name = %s\n&quot;, ^P);
'\n' 中的 'n' 被跳过。

在扩展完一个词后，你可以使用  <span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span> 或 <span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 得到紧跟在扩展词
之后的单词。这些序列搜索刚刚扩展的文本，并且继续扩展之，使之包括另外一个词。这
可以用于你需要重复一系列复杂的单词的场合。尽管 <span class="Special">CTRL-P</span> 和 <span class="Special">CTRL-N</span> 只找至少两个字
符的字符串，<span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span> 和 <span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 可以用来扩展只有一个字符的单词。
	例如，要得到:
		M&amp;eacute;xico
	你可以输入:
		M^<span class="Special">N</span>^P^X^P^X^P
<span class="Special">CTRL-N</span> 开始一个扩展，而 <span class="Special">CTRL-P</span> 回到单个字符 &quot;M&quot;，然后后面的两个 <span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span>
分别得到 &quot;&amp;eacute&quot; 和 &quot;;xico&quot;。

如果上次的扩展因为超过 <span class="Type">'textwidth'</span> 被分割，则只会使用当前行的文本。

如果匹配在行尾，那么下一行的第一个单词会被插入，而且显示消息 &quot;word from next
line&quot;。如果该词被接受，那么下个 <span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span> 或者 <span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 会搜索那些以
这个单词开始的行。


补全 <span class="Type">'dictionary'</span> 的关键字				<span class="Ignore">*</span><span class="String">compl-dictionary</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-K</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-K</span>		根据 <span class="Type">'dictionary'</span> 选项给出的文件搜索光标前关键字开始的
			单词。这和 <span class="Special">CTRL-N</span> 类似，只不过搜索的是字典文件，而不是
			当前文件。找到的关键字插入在光标之前。这可能很慢，因为
			在第一个匹配用到之前，所有的匹配都会被找到。缺省，
			<span class="Type">'dictionary'</span> 选项为空。
			要得到哪里能找单词列表的建议，见 <span class="Type">'dictionary'</span> 选项。

	<span class="Special">CTRL-K</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的关键字。替换上一次匹配的关键字。

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-T</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-T</span>		和 <span class="Special">CTRL-X</span> <span class="Special">CTRL-K</span> 类似，但稍有不同。它使用 <span class="Type">'thesaurus'</span>
			选项，而不是 <span class="Type">'dictionary'</span>。如果匹配在同义词字典里找
			到，同一行里其余单词也在匹配里列出，即使它们并不真的匹
			配。这样一个单词可以被完全替换。

			举一个例子，假想 <span class="Type">'thesaurus'</span> 文件有一行形如:<span class="Ignore"> &gt;</span>
<span class="Comment">				angry furious mad enraged</span>
<span class="Ignore">&lt;</span>			把光标放在字母 &quot;ang&quot; 之后并输入 <span class="Special">CTRL-X</span> <span class="Special">CTRL-T</span> 会匹配单
			词 &quot;angry&quot;；继续按会把单词改为 &quot;furious&quot;、&quot;mad&quot; 等等。
			其它的使用包括两种语言之间的翻译，或者用关键字给 API
			函数归类。

	<span class="Special">CTRL-T</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的关键字。替换上一次匹配的关键字。


补全当前和头文件内的关键字				<span class="Ignore">*</span><span class="String">compl-keyword</span><span class="Ignore">*</span>

<span class="Type">'include'</span> 选项指定如何找到含有头文件名字的行。<span class="Type">'path'</span> 选项用来搜索头文件。

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-I</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-I</span>		搜索当前和头文件里第一个以光标前面的字母序列开始的关键
			字。找到的关键字插入在光标的前面。

	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的关键字。替换上一次匹配的关键字。
			注意: <span class="Special">CTRL-I</span> 和 <span class="Special">&lt;Tab&gt;</span> 相同，而这可能会在成功的补全之后
			输入，因此不使用 <span class="Special">CTRL-I</span> 来搜索下一个匹配。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-X</span> <span class="Special">CTRL-I</span>	继续使用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-I</span> 会复制上次本类型补全在其它上下
			文里扩展的单词之后紧跟的单词，直到见到两个 <span class="Special">CTRL-X</span> 为
			止。

补全标签						<span class="Ignore">*</span><span class="String">compl-tag</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-]</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-]</span>		搜索第一个以光标前面的字母序列开始的标签。匹配的标签插
			在光标前面。标签名可以包含字母字符和由 <span class="Type">'iskeyword'</span> 决
			定的字符 (和关键字相同)。另见 <span class="Ignore">|</span><span class="Identifier">CTRL-]</span><span class="Ignore">|</span>。
			<span class="Type">'showfulltag'</span> 选项可以用来增加标签定义前后的上下文。
	<span class="Special">CTRL-]</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的标签。替换上一次匹配的标签。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的标签。替换上一次匹配的标签。


补全文件名						<span class="Ignore">*</span><span class="String">compl-filename</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-F</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-F</span>		搜索第一个以光标前面的字母序列开始的文件。匹配的文件插
			在光标前面。标签名可以包含字母字符和由 <span class="Type">'isfname'</span> 决
			定的字符 (和关键字相同)。注意，(目前) 这里不使用
			<span class="Type">'path'</span> 选项。
	<span class="Special">CTRL-F</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的文件名。替换上一次匹配的文件名。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的文件名。替换上一次匹配的文件名。


补全定义或宏						<span class="Ignore">*</span><span class="String">compl-define</span><span class="Ignore">*</span>

<span class="Type">'define'</span> 选项用来指定包含定义的行。<span class="Type">'include'</span> 选项用来指定包含头文件名的行。
<span class="Type">'path'</span> 选项用来搜索头文件。

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-D</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-D</span>		搜索当前和头文件里第一个以光标前面的字母序列开始的
			定义 (或宏)。找到的定义名插入在光标的前面。
	<span class="Special">CTRL-D</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的定义。替换上一次匹配的定义。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的定义。替换上一次匹配的定义。

	<span class="Special">CTRL-X</span> <span class="Special">CTRL-D</span>	继续使用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-D</span> 会复制上次本类型补全在其它上下
			文里扩展的单词之后紧跟的单词，直到见到两个 <span class="Special">CTRL-X</span> 为
			止。


补全 Vim 命令						<span class="Ignore">*</span><span class="String">compl-vim</span><span class="Ignore">*</span>

这里，补全是上下文敏感的，和命令行上的情况相似。它既能补全 Ex 命令，又能补全它
的参数。可用于编写 Vim 脚本。

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-V</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-V</span>		猜测光标前的项目的条目，并找到第一个匹配。
			注意: 如果 <span class="Special">CTRL-V</span> 被映射，你通常可以用 <span class="Special">CTRL-Q</span> 来代替
			<span class="Ignore">|</span><span class="Identifier">i_CTRL-Q</span><span class="Ignore">|</span>。
	<span class="Special">CTRL-V</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配。替换上一次匹配。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配。替换上一次匹配。

	<span class="Special">CTRL-X</span> <span class="Special">CTRL-V</span>	继续使用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-V</span> 和 <span class="Special">CTRL-V</span> 一样。这允许映射键来
			执行 Vim 命令补全，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:imap &lt;Tab&gt; &lt;C-X&gt;&lt;C-V&gt;</span>

用户定义补全						<span class="Ignore">*</span><span class="String">compl-function</span><span class="Ignore">*</span>

命令补全可以由用户通过 <span class="Type">'completefunc'</span> 选项自定义一个函数来完成。下面说明如何调
用此函数，并提供示例 <span class="Ignore">|</span><span class="Identifier">complete-functions</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-U</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-U</span>		猜测光标前面项目的类型，并寻找它的第一个匹配。
	<span class="Special">CTRL-U</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配。替换上一次匹配。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配。替换上一次匹配。


全能 (omni) 补全					<span class="Ignore">*</span><span class="String">compl-omni</span><span class="Ignore">*</span>

命令补全可以由用户通过 <span class="Type">'omnifunc'</span> 选项自定义一个函数来完成。这通常用于特定文件
类型的补全。

下面说明如何调用此函数，并提供示例 <span class="Ignore">|</span><span class="Identifier">complete-functions</span><span class="Ignore">|</span>。
关于特定文件类型的说明，见 <span class="Ignore">|</span><span class="Identifier">compl-omni-filetypes</span><span class="Ignore">|</span>。
将来会有更多补全脚本，欢迎查阅 <span class="String">www.vim.org</span>。目前已经有了 C++ 的首个版本。

							<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-O</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span>		猜测光标前面项目的类型，并寻找它的第一个匹配。
	<span class="Special">CTRL-O</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个匹配。替换上一次匹配。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配。替换上一次匹配。


拼写建议						<span class="Ignore">*</span><span class="String">compl-spelling</span><span class="Ignore">*</span>

定位光标所在或之前的单词，然后提出正确拼写的单词作为建议进行替代。如果该行里有
一个错误拼写的单词在光标之前或之下，移动光标到它后面。否则，使用刚刚在光标之前
的那个单词来提出建议，即使该单词没有拼写错误。

<span class="Todo">NOTE</span>: 很多 Unix 终端上，<span class="Special">CTRL-S</span> 暂停显示。这时用 's' 可以代替。如果显示暂停，输
入 <span class="Special">CTRL-Q</span> 会继续显示。

						<span class="Ignore">*</span><span class="String">i_CTRL-X_CTRL-S</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">i_CTRL-X_s</span><span class="Ignore">*</span>
<span class="Special">CTRL-X</span> <span class="Special">CTRL-S</span>  或
<span class="Special">CTRL-X</span> s		定位光标之前的单词，并寻找它的第一个拼写建议。
	<span class="Special">CTRL-S</span>	或
	<span class="Special">CTRL-N</span>		正向搜索下一个建议。替换上一次的建议。 注意 这里不能用
			's'。

	<span class="Special">CTRL-P</span>		反向搜索前一个建议。替换上一次的建议。


从不同的来源补全关键字					<span class="Ignore">*</span><span class="String">compl-generic</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">i_CTRL-N</span><span class="Ignore">*</span>
<span class="Special">CTRL-N</span>			在 <span class="Type">'complete'</span> 选项给出的地方搜索下一个以光标前面的关键
			字开始的单词。找到的关键字名插入在光标的前面。

							<span class="Ignore">*</span><span class="String">i_CTRL-P</span><span class="Ignore">*</span>
<span class="Special">CTRL-P</span>			在 <span class="Type">'complete'</span> 选项给出的地方搜索上一个以光标前面的关键
			字开始的单词。找到的关键字名插入在光标的前面。

	<span class="Special">CTRL-N</span>		正向搜索下一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-P</span>		反向搜索前一个匹配的关键字。替换上一次匹配的关键字。

	<span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 或
	<span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span>	继续使用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-N</span> 或 <span class="Special">CTRL-X</span> <span class="Special">CTRL-P</span> 会复制上次本类
			型补全在其它上下文里扩展的单词之后紧跟的单词，直到见到
			两个 <span class="Special">CTRL-X</span> 为止。


寻 找 补 全 的 函 数					<span class="Ignore">*</span><span class="String">complete-functions</span><span class="Ignore">*</span>

这里指 <span class="Type">'completefunc'</span> 和 <span class="Type">'omnifunc'</span>。

函数被调用两次，使用不同的方式:
- 首先，调用函数以寻找补全文本的开始位置。
- 然后，调用函数以寻找实际的匹配。

第一次调用时，参数是:
   a:findstart  1
   a:base	空

函数必须返回补全开始位置的列数，这个数字必须在零到光标所在列 &quot;col('.')&quot; 之间。
过程应该检查光标之前的字符，并包含那些可能成为补全项一部分的字符。该列到光标列
之间的文本将来会被匹配结果替换。

特殊返回值:
   -1 如果补全无法进行，撤销补全且报错。
   -2 安静的撤销，留在补全模式。
   -3 安静的撤销，退出补全模式。

第二次调用时，参数是:
   a:findstart  0
   a:base	补全必须匹配的文本；即第一次调用定位的文本 (可以为空)

函数必须返回匹配单词的列表。这些匹配通常包含 &quot;a:base&quot; 文本。如果没有匹配，返回
空列表。

要知道关于匹配词的信息，返回包含匹配列表的一个字典。字典包含以下项目：
	words		包含匹配单词的列表 (必需)。
	refresh		用于控制函数重新启动的字符串 (可选)。
			目前唯一支持的值是 &quot;always&quot;。效果是每次前导文本改变时
			都会调用函数。
忽略其他项目。

要在补全结束之后有所行动，参见 <span class="Ignore">|</span><span class="Identifier">CompleteDone</span><span class="Ignore">|</span> 自动命令事件。

例如，函数可以这么做:<span class="Ignore"> &gt;</span>
<span class="Comment">	let matches = ... 单词列表 ...</span>
<span class="Comment">	return {'words': matches, 'refresh': 'always'}</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span class="String">complete-items</span><span class="Ignore">*</span>
每个列表项可以是字符串或者字典类型。如果是字符串，直接用作补全文本。如果是字
典，可以包含以下各项:
	word		需要插入的文本，必需
	abbr		&quot;word&quot; 的缩写；如果非空，菜单里使用它而不是 &quot;word&quot;
	menu		用于弹出菜单的补充文本，在 &quot;word&quot; 或 &quot;abbr&quot; 之后显示
	info		关于补全项的更多信息，能够在预览窗口显示
	kind		代表补全类型的单个字母
	icase		如果非零，比较项目是否等同时忽略大小写；如果省略就假定
			为零，这时可以同时加入只有大小写有差异的匹配项
	dup		如果非零，那么即使和此匹配包含相同单词的匹配项已经存在
			也无妨。
	empty		如果非零，匹配项即使是空字符串也会加入

除了 &quot;icase&quot;、&quot;dup&quot; 和 &quot;empty&quot; 以外，其它各项必须是字符串。如果有一项不合要
求，报错，而列表的其余项目也不再使用。你可以在返回列表中混用字符串和字典项目。

&quot;menu&quot; 项目用于弹出菜单且可能被截短，所以它应该尽量简短。&quot;info&quot; 项目可以稍长。
如果在 <span class="Type">'completeopt'</span> 中包含 &quot;preview&quot;，预览窗口会显示该项信息。关闭弹出菜单
后， &quot;info&quot; 项目将保留显示，这对录入函数参数很有用。用单个空格设置 &quot;info&quot; 可以
清除预览窗口现存的文本。预览窗口的大小缺省是三行，但在 <span class="Type">'previewheight'</span> 为 1 或
2 时使用其值。

&quot;kind&quot; 项目用单一字母表示补全类型。用它可以指定补全的不同显示方式 (不同颜色或
者图标)。目前，可用如下类型:
	v	变量
	f	函数或方法
	m	结构或类成员
	t	typedef
	d	#define 或宏

如果搜索匹配耗时较长，可以调用 <span class="Ignore">|</span><span class="Identifier">complete_add()</span><span class="Ignore">|</span> 向总列表中增加每个匹配。不要在
返回的列表里包含这些匹配！搜索匹配的同时，时不时地调用 <span class="Ignore">|</span><span class="Identifier">complete_check()</span><span class="Ignore">|</span> 来使
得用户仍然可以按键。如果该函数返回非零，搜索停止。

							<span class="Ignore">*</span><span class="String">E839</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E840</span><span class="Ignore">*</span>
该函数可以移动光标，结束后光标会恢复。
该函数不允许移动到其他窗口，也不允许删除文本。

一个补全月份名的示例:<span class="Ignore"> &gt;</span>
<span class="Comment">	fun! CompleteMonths(findstart, base)</span>
<span class="Comment">	  if a:findstart</span>
<span class="Comment">	    &quot; 定位单词的开始处</span>
<span class="Comment">	    let line = getline('.')</span>
<span class="Comment">	    let start = col('.') - 1</span>
<span class="Comment">	    while start &gt; 0 &amp;&amp; line[start - 1] =~ '\a'</span>
<span class="Comment">	      let start -= 1</span>
<span class="Comment">	    endwhile</span>
<span class="Comment">	    return start</span>
<span class="Comment">	  else</span>
<span class="Comment">	    &quot; 寻找匹配 &quot;a:base&quot; 的月份</span>
<span class="Comment">	    let res = []</span>
<span class="Comment">	    for m in split(&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;)</span>
<span class="Comment">	      if m =~ '^' . a:base</span>
<span class="Comment">		call add(res, m)</span>
<span class="Comment">	      endif</span>
<span class="Comment">	    endfor</span>
<span class="Comment">	    return res</span>
<span class="Comment">	  endif</span>
<span class="Comment">	endfun</span>
<span class="Comment">	set completefunc=CompleteMonths</span>
<span class="Ignore">&lt;</span>
功能同上，但是现在假设搜索比较慢:<span class="Ignore"> &gt;</span>
<span class="Comment">	fun! CompleteMonths(findstart, base)</span>
<span class="Comment">	  if a:findstart</span>
<span class="Comment">	    &quot; 定位单词的开始处</span>
<span class="Comment">	    let line = getline('.')</span>
<span class="Comment">	    let start = col('.') - 1</span>
<span class="Comment">	    while start &gt; 0 &amp;&amp; line[start - 1] =~ '\a'</span>
<span class="Comment">	      let start -= 1</span>
<span class="Comment">	    endwhile</span>
<span class="Comment">	    return start</span>
<span class="Comment">	  else</span>
<span class="Comment">	    &quot; 寻找匹配 &quot;a:base&quot; 的月份</span>
<span class="Comment">	    for m in split(&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;)</span>
<span class="Comment">	      if m =~ '^' . a:base</span>
<span class="Comment">		call complete_add(m)</span>
<span class="Comment">	      endif</span>
<span class="Comment">	      sleep 300m	&quot; simulate searching for next match</span>
<span class="Comment">	      if complete_check()</span>
<span class="Comment">		break</span>
<span class="Comment">	      endif</span>
<span class="Comment">	    endfor</span>
<span class="Comment">	    return []</span>
<span class="Comment">	  endif</span>
<span class="Comment">	endfun</span>
<span class="Comment">	set completefunc=CompleteMonths</span>
<span class="Ignore">&lt;</span>

插 入 补 全 弹 出 菜 单					<span class="Ignore">*</span><span class="String">ins-completion-menu</span><span class="Ignore">*</span>
							<span class="Ignore">*</span><span class="String">popupmenu-completion</span><span class="Ignore">*</span>
Vim 可以用更简单的弹出菜单来显示匹配。

当下面条件符合时使用弹出菜单:
- <span class="Type">'completeopt'</span> 选项包含 &quot;menu&quot; 或 &quot;menuone&quot;。
- 显示终端至少支持 8 色。
- 至少有两条匹配项。如果使用 &quot;menuone&quot;，一条匹配也可以。

选项 <span class="Type">'pumheight'</span> 用于设置最大高度。默认值是使用全部有效空间。

有三个状态:
1. 插入了完整的匹配，例如在 <span class="Special">CTRL-N</span> 或 <span class="Special">CTRL-P</span> 之后。
2. 用光标键选择其它匹配项。此时不插入该匹配项，只在弹出菜单中高亮选中的条目。
3. 只插入了部分匹配文本，并且已经输入字符或者使用了退格键，这时匹配项列表根据
   光标前的内容进行调整。

开始时你通常处于状态一并插入第一个匹配。如果 <span class="Type">'completeopt'</span> 包含了 &quot;longest&quot; 而
且有多个匹配项，那么开始于状态三。

如果选择其它匹配项，例如键入 <span class="Special">CTRL-N</span> 或 <span class="Special">CTRL-P</span>，就进入了状态一。这不会改变匹配
项列表。

如果退回到原文，就会处于状态三。要立即进入该状态，可以使用快捷键映射方法，该映
射在补全开始后立即使用 <span class="Special">CTRL-P</span>:<span class="Ignore"> &gt;</span>
<span class="Comment">	:imap &lt;F7&gt; &lt;C-N&gt;&lt;C-P&gt;</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span class="String">popupmenu-keys</span><span class="Ignore">*</span>
状态一下，这些键有特别的含义:
<span class="Special">&lt;BS&gt;</span> 和 <span class="Special">CTRL-H</span>    删除一个字符，查找光标前单词的匹配项。这会减少列表中匹配项的
		  数目，常常到只有一个项目，然后切换到状态二。
其它非特殊字符:
		  停止补全，不改变匹配，然后插入输入的字符。

状态二和状态三下，这些键有特别的含义:
<span class="Special">&lt;BS&gt;</span> 和 <span class="Special">CTRL-H</span>    删除一个字符，并查找光标前变短的单词的匹配项。这可能会发现更
		  多的匹配项。
<span class="Special">CTRL-L</span>		  从当前匹配项中增加一个字符，可能会减少匹配项的数量。
任何可显示的非空白字符:
		  加入该字符，减少匹配项的数量。

全部三个状态中，可以使用这些键:
<span class="Special">CTRL-Y</span>		  是 (Yes): 接受当前选择的匹配项并停止补全。
<span class="Special">CTRL-E</span>		  结束 (End) 补全，回退到选择匹配前原有的内容 (原先输入的或者
		  最长的公共字符串)。
<span class="Special">&lt;PageUp&gt;</span>	  反向若干项选择一个匹配项，但不插入。
<span class="Special">&lt;PageDown&gt;</span>	  正向若干项选择一个匹配项，但不插入。
<span class="Special">&lt;Up&gt;</span>		  选择前一个匹配，同 <span class="Special">CTRL-P</span>，但不插入。
<span class="Special">&lt;Down&gt;</span>		  选择下一个匹配，同 <span class="Special">CTRL-N</span>，但不插入。
<span class="Special">&lt;Space&gt;</span> 或 <span class="Special">&lt;Tab&gt;</span>  停止补全，不改变匹配，插入键入的该字符

<span class="Special">&lt;Enter&gt;</span> 键的行为取决于你现在所处的状态:
状态一:		  使用现有的文本，然后插入换行符。
状态二:		  插入当前选择项。
状态三:		  使用现有的文本，然后插入换行符。

换句话说: 如果你只使用光标键在匹配项列表中选择其它条目，按 <span class="Special">&lt;Enter&gt;</span> 键将插入该
匹配。如果键入其它字符，按 <span class="Special">&lt;Enter&gt;</span> 键将插入换行符。


下面的高亮组能够改变菜单颜色:
Pmenu		普通项 <span class="Ignore">|</span><span class="Identifier">hl-Pmenu</span><span class="Ignore">|</span>
PmenuSel	选中项 <span class="Ignore">|</span><span class="Identifier">hl-PmenuSel</span><span class="Ignore">|</span>
PmenuSbar	滚动条 <span class="Ignore">|</span><span class="Identifier">hl-PmenuSbar</span><span class="Ignore">|</span>
PmenuThumb	滚动条拇指 (thumb) <span class="Ignore">|</span><span class="Identifier">hl-PmenuThumb</span><span class="Ignore">|</span>

显示弹出窗口时，没有专门的映射。但你可以使用插入模式映射并检查 <span class="Ignore">|</span><span class="Identifier">pumvisible()</span><span class="Ignore">|</span>
函数的返回值以进行不同的处理。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:inoremap &lt;Down&gt; &lt;C-R&gt;=pumvisible() ? &quot;\&lt;lt&gt;C-N&gt;&quot; : &quot;\&lt;lt&gt;Down&gt;&quot;&lt;CR&gt;</span>

映射中用 <span class="Special">&lt;expr&gt;</span> 可以在键入某字符或者满足某些条件时弹出菜单。例如，键入 '.':<span class="Ignore"> &gt;</span>
<span class="Comment">	inoremap &lt;expr&gt; . MayComplete()</span>
<span class="Comment">	func MayComplete()</span>
<span class="Comment">	    if (can complete)</span>
<span class="Comment">	      return &quot;.\&lt;C-X&gt;\&lt;C-O&gt;&quot;</span>
<span class="Comment">	    endif</span>
<span class="Comment">	    return '.'</span>
<span class="Comment">	endfunc</span>

详见 <span class="Ignore">|</span><span class="Identifier">:map-&lt;expr&gt;</span><span class="Ignore">|</span>。


特 定 文 件 类 型 全 能 补 全 的 补 充 说 明        <span class="Ignore">*</span><span class="String">compl-omni-filetypes</span><span class="Ignore">*</span>

文件类型 <span class="Special">{filetype}</span> 使用的是 <span class="Type">'runtimepath'</span> 的 autoload/<span class="Special">{filetype}</span>complete.vim
文件。比如对于 &quot;java&quot;，就是文件 autoload/javacomplete.vim。


<span class="Statement">C							</span><span class="Ignore">*</span><span class="String">ft-c-omni</span><span class="Ignore">*</span>

C 代码补全需要标签文件。你应该使用 Exuberant ctags 软件，因为它会加入补全所需
要的额外信息。你可以在这里找到它:  <span class="String"><a href="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</a></span> 推荐使用 5.6
或以后版本。

对于 5.5.4 版本，你应该打上增加 &quot;typename:&quot; 字段的补丁:
	<span class="String">ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch</span>
可以在这里找到 MS-Windows 上已经编译好的可执行版本:
	<span class="String"><a href="http://georgevreilly.com/vim/ctags.html">http://georgevreilly.com/vim/ctags.html</a></span>

如果你想补全系统函数，可以用 ctags 生成包含所有系统头文件的标签文件:<span class="Ignore"> &gt;</span>
<span class="Comment">	% ctags -R -f ~/.vim/systags /usr/include /usr/local/include</span>
在 vimrc 文件中，把这个标签文件增加到 <span class="Type">'tags'</span> 选项中:<span class="Ignore"> &gt;</span>
<span class="Comment">	set tags+=~/.vim/systags</span>

如果在不包含 &quot;.&quot; 或 &quot;=&quot; 的名字后面用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span>，会直接从标签文件中补全。这
适用于任何标识符，包括函数名。如果你想补全标签文件没有的局部变量名，用 <span class="Special">CTRL-P</span>
代替。

如果在包含 &quot;.&quot; 或 &quot;=&quot; 的名字后面用 <span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span>，Vim 会试图识别变量类型并指出
它所含的成员。这意味着只会列出该变量的有效成员。

如果成员名字已经完整，<span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span> 会为复合类型加上 &quot;.&quot; 或 &quot;-&gt;&quot;。

Vim 没有包含 C 编译器，它只能识别使用明确格式的声明。预处理器指令可能会引起混
淆。如果在多个位置里定义了同样的结构名，所有可能的结构成员都会被包括。


<span class="Statement">CSS							</span><span class="Ignore">*</span><span class="String">ft-css-omni</span><span class="Ignore">*</span>

遵循 CSS 2.1 标准来补全属性和相应的值。


<span class="Statement">HTML							</span><span class="Ignore">*</span><span class="String">ft-html-omni</span><span class="Ignore">*</span>
<span class="Statement">XHTML							</span><span class="Ignore">*</span><span class="String">ft-xhtml-omni</span><span class="Ignore">*</span>

<span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span> 能够补全 (X)HTML 文件的各种元素。它是为了支持编写 XHTML 1.0
Strict 文件而设计的，但也可用于其它 HTML 版本。特性:

- &quot;&lt;&quot; 之后，根据上下文补全标签名 (在标签内部，不给出 div 标签建议)；'/&gt;' 表明
  空标签
- 在标签中，补全合适的属性 (不包括标签的 width 属性)；同时显示属性类型；'*' 表
  明必需的属性
- 如果属性只有有限的几个可能值，用它们来补全
- 补全实体 (entity) 名
- 根据 <span class="Special">&lt;style&gt;</span> 标签和包含的 CSS 文件里提取的数据，补全 &quot;class&quot; 和 &quot;id&quot; 属性值
- 对 &quot;style&quot; 属性值或在 &quot;style&quot; 标签内部补全时，切换到 <span class="Ignore">|</span><span class="Identifier">ft-css-omni</span><span class="Ignore">|</span> 补全
- 对事件属性值或在 &quot;script&quot; 标签内部补全时，切换到 <span class="Ignore">|</span><span class="Identifier">ft-javascript-omni</span><span class="Ignore">|</span> 补全
- &quot;&lt;/&quot; 之后，<span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span> 会关闭最近打开的标签

备注: 如果是第一次使用，补全菜单的显示会有少许延迟--这点时间用于数据文件载入。
备注: 补全可能会在错误格式的文档中失效。在这种情况下，请尝试运行 <span class="Ignore">|</span><span class="Identifier">:make</span><span class="Ignore">|</span> 命令
检查格式问题。


HTML 类型						<span class="Ignore">*</span><span class="String">html-flavor</span><span class="Ignore">*</span>

默认的 HTML 补全机制依赖于文件类型: HTML 文件使用 HTML 4.01 Transitional 标准
(<span class="Type">'filetype'</span> 是 <span class="Type">'html'</span>)，XHTML 使用 XHTML 1.0 Strict 标准 (<span class="Type">'filetype'</span> 是
<span class="Type">'xhtml'</span>)。

如果在任何标签的外部进行补全，你可以选择 DOCTYPE，然后载入合适的数据文件，并用
于后面所有的补全操作。

关于数据文件格式更多的信息见 <span class="Ignore">|</span><span class="Identifier">xml-omni-datafile</span><span class="Ignore">|</span>。vim 的线上站点 (<span class="Ignore">|</span><span class="Identifier">www</span><span class="Ignore">|</span>) 可以
找到一些数据文件。

注意 b:html_omni_flavor 可以指向任何使用 XML 数据的文件。这就使混合 PHP
(<span class="Ignore">|</span><span class="Identifier">ft-php-omni</span><span class="Ignore">|</span>) 和任何 XML 方言的补全成为可能 (假设你有相应的数据文件)。如果该
变量没有设置，使用 XHTML 1.0 Strict 标准。


<span class="Statement">JAVASCRIPT					       </span><span class="Ignore">*</span><span class="String">ft-javascript-omni</span><span class="Ignore">*</span>

补全绝大部分 JavaScript 语言和 DOM 元素。

补全:

- 变量
- 函数名；显示函数参数
- 函数参数
- 变量属性，试图检测变量类型
- 根据上下文补全 DOM 对象和属性
- 语言中的关键字

补全机制可以用于单独的 JavaScript 文件 (&amp;ft==javascript)、(X)HTML 的 <span class="Special">&lt;script&gt;</span>
标签内部和事件的属性值 (包含对外部文件的扫描)。

DOM 兼容性

当前 (2006 年初) 有两种主要浏览器 - MS Internet Explorer 和 Mozilla Firefox。
这两个软件市场占有率达到 90% 以上。理论上，W3C 组织 (<span class="String"><a href="http://www.w3c.org">http://www.w3c.org</a></span>) 建立
标准，但是这些标准并没有完全遵守和实现。

		<span class="PreProc">IE	FF	W3C  全能补全</span><span class="Ignore"> ~</span>
		<span class="PreProc">+/-	+/-	+    +		    </span><span class="Ignore"> ~</span>
		<span class="PreProc">+	+	-    +		    </span><span class="Ignore"> ~</span>
		<span class="PreProc">+	-	-    -		    </span><span class="Ignore"> ~</span>
		<span class="PreProc">-	+	-    -		    </span><span class="Ignore"> ~</span>

不管浏览器的实现进度如何，补全插件总是把标准定义的元素放入建议列表。两个主要浏
览器都实现但标准没有覆盖的元素也作为建议。而其它的元素则不出现于建议列表。


<span class="Statement">PHP							</span><span class="Ignore">*</span><span class="String">ft-php-omni</span><span class="Ignore">*</span>

PHP 代码的补全需要标签文件才能对外部文件的数据和类进行补全。应该使用 Exuberant
ctags 5.5.4 版本或更新的版本。在这里可以找到它: <span class="String"><a href="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</a></span>

脚本对以下项目进行补全:

- $ 变量名之后
  - 如果变量声明为对象，加上 &quot;-&gt;&quot;，如果标签文件有效，显示类名
  - 在 &quot;-&gt;&quot; 之后，只补全给定类中的函数和变量名。为了查找类的位置和内容，需要标
    签文件。因为 PHP 不是强类型的语言，用户可以使用 @var 标签来声明类:<span class="Ignore"> &gt;</span>

<span class="Comment">	/* @var $myVar myClass */</span>
<span class="Comment">	$myVar-&gt;</span>
<span class="Ignore">&lt;</span>
    不过，要找到 myClass 的内容，仍然需要标签文件。

- 带有附加信息的函数名:
  - 如果是内建函数，列出可能的参数，在 | 之后列出函数返回的数据类型
  - 如果是用户函数，列出参数和函数定义所在的文件名 (如果不是当前文件)

- 常量名
- 在 &quot;new&quot; 声明之后的类名


注意: 如果第一次调用补全功能，Vim 会把所有需要的数据载入内存。这可能需要几秒
钟。下次补全时，就几乎感觉不到延迟了。

脚本检测光标是否在 &lt;?php ?&gt; 标签内。如果不是，会自动切换到 HTML/CSS/JavaScript
补全。注意: 和原始 HTML 文件不同，标签补全 (也仅对标签补全而言) 和上下文无关。


<span class="Statement">RUBY							</span><span class="Ignore">*</span><span class="String">ft-ruby-omni</span><span class="Ignore">*</span>

Ruby 代码的补全需要 Vim 编译时带 <span class="Ignore">|</span><span class="Identifier">+ruby</span><span class="Ignore">|</span> 特性。

Ruby 补全会因需分析你的缓冲区以提供补全列表。它会从 <span class="Type">'require'</span> 载入的和当前缓冲
区定义的模块里提取补全。

<span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span> 提供的补全是上下文相关的:

	  <span class="PreProc">上 下 文			  提 供 的 补 全</span><span class="Ignore"> ~</span>

 1. 不在类定义中		     类名、常量和全局变量

 2. 类定义中			     这个类所定义的方法或常量

 3. '.'、'::' 或者 ':' 之后	     被解除参照的对象所适用的方法

 4. ':' 或者 ':foo' 之后	     符号名 (<span class="Type">'foo'</span> 起始的那些)

备注:
 - Vim 会载入/执行程序代码，以便提供补全。这可能会导致部分代码被执行。这一点也
   许值得关注。缺省行为不再打开这一功能。如果需要此特性，加上<span class="Ignore"> &gt;</span>
<span class="Comment">     let g:rubycomplete_buffer_loading = 1</span>
<span class="Ignore">&lt;</span>- 在第 1 点中，Vim 可以解析整个缓冲区以获得用作补全结果的类名列表。默认关闭此
   功能。要使其生效，在 vimrc 里加入<span class="Ignore"> &gt;</span>
<span class="Comment">     let g:rubycomplete_classes_in_global = 1</span>
<span class="Ignore">&lt;</span>- 在第 2 点中，不支持匿名类。
 - 在第 3 点中，Vim 会试图判断对象所支持的方法。
 - Vim 可以检测和载入 Rails 环境并用于 rails 项目的文件。默认关闭此特性。要使
   其生效，在 vimrc 里加入<span class="Ignore"> &gt;</span>
<span class="Comment">     let g:rubycomplete_rails = 1</span>
<span class="Ignore">&lt;</span>

<span class="Statement">SYNTAX							</span><span class="Ignore">*</span><span class="String">ft-syntax-omni</span><span class="Ignore">*</span>

Vim 能够对将近 500 种语言进行语法高亮。高亮支持的一部分是需要知道构成语言的关
键字。许多文件类型已经有专门的补全脚本，而对其它的文件类型而言，syntaxcomplete
脚本可以提供基本的补全。实现的方法是用 Vim 知道如何色彩高亮的那些文本来构造全
能补全列表。它适用于任何文件类型，并可以提供基本但和语言相关的补全机制。

要打开语法打开补全:<span class="Ignore"> &gt;</span>
<span class="Comment">    setlocal omnifunc=syntaxcomplete#Complete</span>

你可以把下列语句放到 <span class="Ignore">|</span><span class="Identifier">.vimrc</span><span class="Ignore">|</span> 中 (要在任何 &quot;:filetype&quot; 命令之后)，使其自动生
效:<span class="Ignore"> &gt;</span>
<span class="Comment">    if has(&quot;autocmd&quot;) &amp;&amp; exists(&quot;+omnifunc&quot;)</span>
<span class="Comment">	autocmd Filetype *</span>
<span class="Comment">		    \	if &amp;omnifunc == &quot;&quot; |</span>
<span class="Comment">		    \		setlocal omnifunc=syntaxcomplete#Complete |</span>
<span class="Comment">		    \	endif</span>
<span class="Comment">    endif</span>

只有在针对特定文件类型的插件不存在的情况下，上述语句才对脚本设置补全操作。

每个文件类型可能有很多语法项目。此插件允许你定制从列表里包含或排除哪些语法组。
让我们看看 PHP 文件类型如何处理。

如果你正在编辑一个 index.php 文件，运行如下命令:<span class="Ignore"> &gt;</span>
<span class="Comment">    syntax list</span>

首先你将看到有许多不同的语法组。PHP 语言可以包含来自不同语言的元素，比如
HTML、 JavaScript 和许多其它语言。这种情况下，syntax 插件只包含由文件类型
&quot;php&quot; 开头的语法组。例如，缺省 PHP 包含这些语法组: phpEnvVar、phpIntVar、
phpFunctions。

如果希望包括非本文件类型指定的其他语法项目，可用正规表达式语法
(autoload\syntaxcomplete.vim 的 13.0 版本加入) 来加入项目。编辑 PHP 文件时查看
&quot;:syntax list&quot; 的输出，我可以看到如下一些项目:<span class="Ignore"> &gt;</span>
<span class="Comment">    htmlArg,htmlTag,htmlTagName,javaScriptStatement,javaScriptGlobalObjects</span>

要在编辑 PHP 文件时时使用 Javascript 和 HTML 关键字语法高亮组，可以指定三个正
规表达式，每种语言分别一个。也可以简单限制包含组为特写值，而无需正规表达式:<span class="Ignore"> &gt;</span>
<span class="Comment">    let g:omni_syntax_group_include_php = 'php\w\+,javaScript\w\+,html\w\+'</span>
<span class="Comment">    let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'</span>
<span class="Ignore">&lt;</span>
这个变量的基本形式是:<span class="Ignore"> &gt;</span>
<span class="Comment">    let g:omni_syntax_group_include_{filetype} = '逗号,分隔的,列表'</span>

PHP 语言可以进行语法高亮的项目非常多，而这些项目在全能补全列表里都会出现。

有些人可能觉得这个列表不实用或者只对某些项感兴趣。(如有必要) 有两种方法可以裁
剪这个列表。如果不想显示特定语法组，有两种不同的方法来标识这些组。第一个具体列
出这些语法组的名字。第二个使用正规表达式来指定所有想要的语法组。在 vimrc 中增
加两者之一即可:<span class="Ignore"> &gt;</span>
<span class="Comment">    let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'</span>
<span class="Comment">    let g:omni_syntax_group_exclude_php = 'php\w*Constant'</span>

该列表可以加入多个语法组，以逗号分隔。这个变量的基本形式是:<span class="Ignore"> &gt;</span>
<span class="Comment">    let g:omni_syntax_group_exclude_{filetype} = '逗号,分隔的,列表'</span>

可以建立任意多个这些变量，只要变量名尾部的文件类型不同就行了。

此插件使用 isKeyword 选项来决定用于语法项目的单词边界。例如，Scheme 语言的补全
应该包含 &quot;-&quot;，call-with-output-file。取决于你的文件类型，此方法未必能提供你期
待的单词。设置 g:omni_syntax_use_iskeyword 选项为 0 会强制语法插件在单词字符上
断开。在 vimrc 可以加如下行进行控制:<span class="Ignore"> &gt;</span>
<span class="Comment">    let g:omni_syntax_use_iskeyword = 0</span>

为了插件开发者着想，本插件提供了公共函数 OmniSyntaxList。本函数可用于提供语法
项目的列表。编辑 SQL 文件时 (:e syntax.sql)，可以用 &quot;:syntax list&quot; 命令看到各
种组和语法项目。示例:<span class="Ignore"> &gt;</span>
<span class="Comment">    syntax list</span>

返回的数据类似如此:<span class="Ignore"> &gt;</span>
<span class="Comment">    sqlOperator    xxx some prior all like and any escape exists in is not</span>
<span class="Comment">                       or intersect minus between distinct</span>
<span class="Comment">                       links to Operator</span>
<span class="Comment">    sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier</span>
<span class="Comment">                       date money long tinyint unsigned xml text smalldate</span>
<span class="Comment">                       double datetime nchar smallint numeric time bit char</span>
<span class="Comment">                       varbinary binary smallmoney</span>
<span class="Comment">                       image float integer timestamp real decimal</span>

这里列出两个语法组: sqlOperator 和 sqlType。要得到语法项目的列表，可用几种不同
的方式调用 OminiSyntaxList。要得到不分组的所有语法项目:<span class="Ignore"> &gt;</span>
<span class="Comment">    echo OmniSyntaxList( [] )</span>

要得到 sqlOperator 语法组的所有语法项目:<span class="Ignore"> &gt;</span>
<span class="Comment">    echo OmniSyntaxList( ['sqlOperator'] )</span>

要得到 sqlOperator 和 sqlType 两个组的所有语法项目:<span class="Ignore"> &gt;</span>
<span class="Comment">    echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )</span>

也可用正规表达式:<span class="Ignore"> &gt;</span>
<span class="Comment">    echo OmniSyntaxList( ['sql\w\+'] )</span>

在插件中，通常可以把输出结果赋给一个列表:<span class="Ignore"> &gt;</span>
<span class="Comment">    let myKeywords = []</span>
<span class="Comment">    let myKeywords = OmniSyntaxList( ['sqlKeyword'] )</span>



<span class="Statement">SQL							</span><span class="Ignore">*</span><span class="String">ft-sql-omni</span><span class="Ignore">*</span>

SQL 语言的补全包括语句、函数和关键字。还可以动态地补全表、过程、视图和列的列
表，此时数据直接从数据库里提取。详细的指令和教程见 <span class="Ignore">|</span><span class="Identifier">omni-sql-completion</span><span class="Ignore">|</span>。

SQL 补全插件可以和其它补全插件一起使用。例如，PHP 文件类型有它自己的补全插件。
因为 PHP 常用来生成访问数据库的动态网站，也可以同时打开 SQL 补全插件。这样就可
以同时补全 PHP 代码和 SQL 代码。


<span class="Statement">XML							</span><span class="Ignore">*</span><span class="String">ft-xml-omni</span><span class="Ignore">*</span>

Vim 7 为 XML 文件中提供上下文相关的补全机制。它依赖于特殊的数据文件
<span class="Ignore">|</span><span class="Identifier">xml-omni-datafile</span><span class="Ignore">|</span> 和两个命令: <span class="Ignore">|</span><span class="Identifier">:XMLns</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:XMLent</span><span class="Ignore">|</span>。特性如下:

- &quot;&lt;&quot; 之后，根据上下文补全标签名
- 标签内部补全合适的属性
- 如果属性只有有限的几个可能值，用它们来补全
- 补全实体 (entity) 名 (<span class="Ignore">|</span><span class="Identifier">xml-omni-datafile</span><span class="Ignore">|</span> 里的定义加上当前文件 &quot;&lt;!ENTITY&quot; 的
  声明)
- &quot;&lt;/&quot; 之后，<span class="Special">CTRL-X</span> <span class="Special">CTRL-O</span> 会关闭最后打开的标签

XML 数据文件的格式					<span class="Ignore">*</span><span class="String">xml-omni-datafile</span><span class="Ignore">*</span>

XML 数据文件保存在 <span class="Type">'runtimepath'</span> 下的 &quot;autoload/xml&quot; 目录中。Vim 发布在
&quot;$VIMRUNTIME/autoload/xml&quot; 目录下提供了示例数据文件。这些文件名有特别含义，命
令里使用会使用这些名字。文件名应该唯一，否则以后会产生冲突。例如，xhtml10s.vim
代表 XHTML 1.0 Strict 标准的数据文件。

每个文件包含一个名字形如 g:xmldata_xhtml10s 的变量。它由两个部分组成:

1. &quot;g:xmldata_&quot;  通用前缀，所有数据文件都是如此
2. &quot;xhtml10s&quot;    文件名，描述 XML 的方言；会用作 <span class="Ignore">|</span><span class="Identifier">:XMLns</span><span class="Ignore">|</span> 命令的参数

第二部分必须和文件名完全一样。

该变量为字典 <span class="Ignore">|</span><span class="Identifier">Dictionary</span><span class="Ignore">|</span> 类型。键是标签名，而值是两个元素的 <span class="Ignore">|</span><span class="Identifier">List</span><span class="Ignore">|</span>。列表中第
一个元素也是列表，包含可能的子元素名称，第二个元素是字典 <span class="Ignore">|</span><span class="Identifier">Dictionary</span><span class="Ignore">|</span>，键是属
性名，而值是属性的可能值。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">    let g:xmldata_crippled = {</span>
<span class="Comment">    \ &quot;vimxmlentities&quot;: [&quot;amp&quot;, &quot;lt&quot;, &quot;gt&quot;, &quot;apos&quot;, &quot;quot&quot;],</span>
<span class="Comment">    \ 'vimxmlroot': ['tag1'],</span>
<span class="Comment">    \ 'tag1':</span>
<span class="Comment">    \ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],</span>
<span class="Comment">    \ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],</span>
<span class="Comment">    \ 'childoftag1a':</span>
<span class="Comment">    \ [ [], {'attrofchild': ['attrofchild']}],</span>
<span class="Comment">    \ 'childoftag1b':</span>
<span class="Comment">    \ [ ['childoftag1a'], {'attrofchild': []}],</span>
<span class="Comment">    \ &quot;vimxmltaginfo&quot;: {</span>
<span class="Comment">    \ 'tag1': ['Menu info', 'Long information visible in preview window']},</span>
<span class="Comment">    \ 'vimxmlattrinfo': {</span>
<span class="Comment">    \ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}</span>

该例应放到 &quot;autoload/xml/crippled.vim&quot; 文件中。可用于编写下述文件:<span class="Ignore"> &gt;</span>

<span class="Comment">    &lt;tag1 attroftag1b=&quot;valueofattr1&quot;&gt;</span>
<span class="Comment">        &lt;childoftag1a attrofchild&gt;</span>
<span class="Comment">                &amp;amp; &amp;lt;</span>
<span class="Comment">        &lt;/childoftag1a&gt;</span>
<span class="Comment">        &lt;childoftag1b attrofchild=&quot;5&quot;&gt;</span>
<span class="Comment">            &lt;childoftag1a&gt;</span>
<span class="Comment">                &amp;gt; &amp;apos; &amp;quot;</span>
<span class="Comment">            &lt;/childoftag1a&gt;</span>
<span class="Comment">        &lt;/childoftag1b&gt;</span>
<span class="Comment">    &lt;/tag1&gt;</span>

从该例中，我们可以看到四种特殊元素:

1. &quot;vimxmlentities&quot; - 特殊键，包含此 XML 方言的所有实体的列表。
2. 如果这个包含属性可能值的列表只有一个元素，而该元素和属性名一样，那么该属性
   被看作逻辑值，插入时使用 <span class="Type">'attrname'</span> 而不是 'attrname=&quot;'。
3. &quot;vimxmltaginfo&quot; - 特殊键，包含键为标签名、值为两元素列表的字典。值列表包含
   附加的菜单信息和长描述。
4. &quot;vimxmlattrinfo&quot; - 特殊键，包含键为属性名、值为两元素列表的字典。值列表包含
   附加的菜单信息和长描述。

注意: 数据文件里的标签名_必须_不能包含命名空间的描述。示例见 xsl.vim。
注意: 所有的数据和函数都作为全局变量/函数可以在任何地方访问，所以它们可以用于
个人编辑用的函数。


DTD -&gt; Vim							<span class="Ignore">*</span><span class="String">dtd2vim</span><span class="Ignore">*</span>

<span class="Ignore">|</span><span class="Identifier">www</span><span class="Ignore">|</span> 上有个脚本 <span class="Ignore">|</span><span class="Identifier">dtd2vim</span><span class="Ignore">|</span>，能够解析 DTD 并为 Vim XML 全能补全建立 XML 数据文
件。

    dtd2vim: <span class="String"><a href="http://www.vim.org/scripts/script.php?script_id=1462">http://www.vim.org/scripts/script.php?script_id=1462</a></span>

查看文件开始部分的详细用例。
该脚本需要 Perl 和:

    perlSGML: <span class="String"><a href="http://savannah.nongnu.org/projects/perlsgml">http://savannah.nongnu.org/projects/perlsgml</a></span>


命令

:XMLns <span class="Special">{name}</span> [<span class="Special">{namespace}</span>]					<span class="Ignore">*</span><span class="String">:XMLns</span><span class="Ignore">*</span>

Vim 需要知道要使用的数据文件和命名空间。<span class="Ignore">|</span><span class="Identifier">:XMLns</span><span class="Ignore">|</span> 命令可以载入数据文件并把数据
连接到合适的命名空间。第一个 (必需的) 参数是数据名 (xhtml10s、xsl)。第二个参数
是命名空间编码 (h，xsl)。如果不使用第二个参数，那么将使用默认值--不声明命名空
间。例如在 .xsl 文件中使用 XML 补全:<span class="Ignore"> &gt;</span>

<span class="Comment">	:XMLns xhtml10s</span>
<span class="Comment">	:XMLns xsl xsl</span>


:XMLent <span class="Special">{name}</span>							<span class="Ignore">*</span><span class="String">:XMLent</span><span class="Ignore">*</span>

缺省，根据默认命名空间的数据文件补全实体 (entity) 。如果没有默认命名空间，应该
用 XMLent 命令:<span class="Ignore"> &gt;</span>

<span class="Comment">	:XMLent xhtml10s</span>

用法

在下述情况下 (在前一部分的声明之后，| 代表当前光标位置):<span class="Ignore"> &gt;</span>

<span class="Comment">	&lt;|</span>

补全合适的 XHTML 标签。而:<span class="Ignore"> &gt;</span>

<span class="Comment">	&lt;xsl:|</span>

补全合适的 XSL 标签。


由 <span class="Ignore">|</span><span class="Identifier">autoload</span><span class="Ignore">|</span> 机制提供的 xmlcomplete.vim 脚本定义了函数
xmlcomplete#GetLastOpenTag()，在 XML 文件中，这个函数可用于取得最后打开的标签
名 (下例必须先定义 b:unaryTagsStack):<span class="Ignore"> &gt;</span>

<span class="Comment">	:echo xmlcomplete#GetLastOpenTag(&quot;b:unaryTagsStack&quot;)</span>





<span class="PreProc">==============================================================================</span>
8. 插入模式命令						<span class="Ignore">*</span><span class="String">inserting</span><span class="Ignore">*</span>

下列命令可以用来在缓冲区里插入新的文本。它们都可以撤销，也可以通过  &quot;.&quot; 命令重
复。

							<span class="Ignore">*</span><span class="String">a</span><span class="Ignore">*</span>
a			在光标后附加文本 <span class="Special">[count]</span> 次。如果光标在空行的第一列，
			启动插入模式。但在置位了 <span class="Type">'virtualedit'</span> 以后就不是！

							<span class="Ignore">*</span><span class="String">A</span><span class="Ignore">*</span>
A			在行尾附加文本 <span class="Special">[count]</span> 次。

<span class="Special">&lt;insert&gt;</span>	或				<span class="Ignore">*</span><span class="String">i</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">insert</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">&lt;Insert&gt;</span><span class="Ignore">*</span>
i			在光标前插入文本 <span class="Special">[count]</span> 次。在插入模式里使用 <span class="Special">CTRL-O</span>
			的时候，<span class="Ignore">|</span><span class="Identifier">i_CTRL-O</span><span class="Ignore">|</span> 不支持计数。

							<span class="Ignore">*</span><span class="String">I</span><span class="Ignore">*</span>
I			在本行第一个非空白字符之前插入文本 <span class="Special">[count]</span> 次。
			如果 <span class="Type">'cpoptions'</span> 里有 'H' 标志位而本行只有空白，在最后
			一个空白前插入。

							<span class="Ignore">*</span><span class="String">gI</span><span class="Ignore">*</span>
gI			在第一列插入文本 <span class="Special">[count]</span> 次。<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">gi</span><span class="Ignore">*</span>
gi			在当前缓冲区最近一次插入模式停止的位置继续插入文本。
			该位置记在 <span class="Ignore">|</span><span class="Identifier">'^</span><span class="Ignore">|</span> 位置标记里。如果标记在行末之后，和
			&quot;`^i&quot; 有所差异。
			该位置在插入/删除行时会自动修正。但_不_在插入/删除字符
			时被修正。
			使用 <span class="Ignore">|</span><span class="Identifier">:keepjumps</span><span class="Ignore">|</span> 命令修饰符时，不改变 <span class="Ignore">|</span><span class="Identifier">'^</span><span class="Ignore">|</span> 位置标记。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">o</span><span class="Ignore">*</span>
o			在光标下方开启新行，并插入文本，重复 <span class="Special">[count]</span> 次。<span class="Special">{Vi:</span>
			<span class="Special">清空 [count] 个屏幕行}</span>
			如果 <span class="Type">'cpoptions'</span> 里有 '#' 标志位，忽略计数。

							<span class="Ignore">*</span><span class="String">O</span><span class="Ignore">*</span>
O			在光标上方开启新行，并插入文本，重复 <span class="Special">[count]</span> 次。<span class="Special">{Vi:</span>
			<span class="Special">清空 [count] 个屏幕行}</span>
			如果 <span class="Type">'cpoptions'</span> 里有 '#' 标志位，忽略计数。

这些命令用以开始插入文本。你可以用 <span class="Special">&lt;Esc&gt;</span> 退出插入模式。关于插入模式里的其它特
殊字符，见 <span class="Ignore">|</span><span class="Identifier">mode-ins-repl</span><span class="Ignore">|</span>。<span class="Special">[count]</span> 的效果只有在退出插入模式以后才会发生。

如果打开 <span class="Type">'autoindent'</span>，新行的缩进从上一行得到。打开 <span class="Type">'smartindent'</span> 或 <span class="Type">'cindent'</span>
时，行的缩进根据 C 程序的要求自动调整。

<span class="Type">'textwidth'</span> 可以设置一行的最大宽度。如果一行过长，在添加字符时会自动添加换行
符。


<span class="PreProc">==============================================================================</span>
9. Ex 插入命令						<span class="Ignore">*</span><span class="String">inserting-ex</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:a</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:append</span><span class="Ignore">*</span>
:<span class="Special">{range}</span>a[ppend][!]	在指定行下方添加若干行。如果没有给出 <span class="Special">{range}</span>，文本会在
			当前行之后插入。
			加入 [!] 切换此命令执行时的 <span class="Type">'autoindent'</span>。

							<span class="Ignore">*</span><span class="String">:i</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:in</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:insert</span><span class="Ignore">*</span>
:<span class="Special">{range}</span>i[nsert][!]	在指定行上方添加若干行。如果没有给出 <span class="Special">{range}</span>，文本会在
			当前行之前插入。
			加入 [!] 切换此命令执行时的 <span class="Type">'autoindent'</span>。

这两个命令会继续要求行，直到你输入了只包含 &quot;.&quot; 的一行。小心反斜杠开始的行，见
<span class="Ignore">|</span><span class="Identifier">line-continuation</span><span class="Ignore">|</span>。

Ex 模式 (见 <span class="Ignore">|</span><span class="Identifier">-e</span><span class="Ignore">|</span>) 下，行尾的反斜杠可用来插入 NUL 字符。所以要使一行以反斜杠结
尾，用两个反斜杠。也就是说仅在行尾情况下，反斜杠数目减半。

注意: 这些命令不能和 <span class="Ignore">|</span><span class="Identifier">:global</span><span class="Ignore">|</span> 或 <span class="Ignore">|</span><span class="Identifier">:vglobal</span><span class="Ignore">|</span> 一起使用。&quot;:append&quot; 和 &quot;:insert&quot;
在 &quot;:if&quot; 和 &quot;:endif&quot;、&quot;:for&quot; 和 &quot;:endfor&quot; 还有 &quot;:while&quot; 和 &quot;:endwhile&quot; 之间不
能很好的工作。

							<span class="Ignore">*</span><span class="String">:start</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:startinsert</span><span class="Ignore">*</span>
:star[tinsert][!]	在执行完本命令后，启动插入模式。和普通模式下输入 &quot;i&quot;
			类似。如果包含 !，和 &quot;A&quot; 类似，附加到行后。否则，就从
			光标当前位置开始插入。
			注意 在函数或者脚本里使用本命令时，插入只会在函数和脚
			本结束的时候才会开始。
			此命令不能在 <span class="Ignore">|</span><span class="Identifier">:normal</span><span class="Ignore">|</span> 里使用。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:stopi</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:stopinsert</span><span class="Ignore">*</span>
:stopi[nsert]		尽快停止插入模式。和在插入模式时输入 <span class="Special">&lt;Esc&gt;</span> 类似。可以
			用在自动命令里。示例:<span class="Ignore"> &gt;</span>
<span class="Comment">				:au BufEnter scratch stopinsert</span>
<span class="Ignore">&lt;</span>
					<span class="Ignore">*</span><span class="String">replacing-ex</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:startreplace</span><span class="Ignore">*</span>
:startr[eplace][!]	在执行完本命令后，启动替换模式。和普通模式下输入 &quot;R&quot;
			类似。如果包含 !，和 &quot;$R&quot; 类似 (也就是，从行尾开始替换
			模式)。否则，从光标当前位置开始替换。
			注意 在函数或者脚本里使用本命令时，替换只会在函数和脚
			本结束的时候才会开始。
			<span class="Special">{Vi 无此功能}</span>

							<span class="Ignore">*</span><span class="String">:startgreplace</span><span class="Ignore">*</span>
:startg[replace][!]	和 <span class="Ignore">|</span><span class="Identifier">:startreplace</span><span class="Ignore">|</span> 完全类似，用虚拟替换模式，和使用
			<span class="Ignore">|</span><span class="Identifier">gR</span><span class="Ignore">|</span> 类似。
			<span class="Special">{Vi 无此功能}</span>

<span class="PreProc">==============================================================================</span>
10. 插入文件						<span class="Ignore">*</span><span class="String">inserting-file</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:r</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:re</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:read</span><span class="Ignore">*</span>
:r[ead] <span class="Special">[++opt]</span> <span class="Special">[name]</span>
			在光标下方插入文件 <span class="Special">[name]</span> (缺省: 当前文件)。
			<span class="Ignore">|</span><span class="Identifier">++opt</span><span class="Ignore">|</span> 说明 <span class="Special">[++opt]</span> 可能的取值。

:<span class="Special">{range}</span>r[ead] <span class="Special">[++opt]</span> <span class="Special">[name]</span>
			在指定行下方插入文件 <span class="Special">[name]</span> (缺省: 当前文件)。
			<span class="Ignore">|</span><span class="Identifier">++opt</span><span class="Ignore">|</span> 说明 <span class="Special">[++opt]</span> 可能的取值。

							<span class="Ignore">*</span><span class="String">:r!</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:read!</span><span class="Ignore">*</span>
:<span class="Special">[range]</span>r[ead] <span class="Special">[++opt]</span> !<span class="Special">{cmd}</span>
			执行 <span class="Special">{cmd}</span> 并把它的标准输出插入到光标下方。临时文件会
			建立来保存命令输出的结果，并被读到缓冲区里。
			<span class="Type">'shellredir'</span> 用来保存命令的输出结果，它可以设置是否包
			含标准错误的输出。<span class="Special">{cmd}</span> 的执行和 &quot;:!<span class="Special">{cmd}</span>&quot; 类似，任何
			的 '!' 会被替换成以前的命令 <span class="Ignore">|</span><span class="Identifier">:!</span><span class="Ignore">|</span>。
			<span class="Ignore">|</span><span class="Identifier">++opt</span><span class="Ignore">|</span> 说明 <span class="Special">[++opt]</span> 可能的取值。

这些命令插入文件的内容，或者命令的输出结果到缓冲区里。两者都可以撤销。但不能用
&quot;.&quot; 命令重复。它们是基于行工作的，插入从光标所在行或指定行的下方开始。要在第一
行之上插入文本，使用命令 &quot;:0r <span class="Special">{name}</span>&quot;。

在 &quot;:read&quot; 命令之后，光标留在第一个新行的第一个非空白处。和 Ex 模式不一样。那
里光标留在最后一个新行上 (对不起，那是为了和 Vi 兼容)。

如果文件名字通过 &quot;:r&quot; 给出，它成为轮换文件。这可以用来，比如说，你想编辑那个文
件的时候: &quot;:e! #&quot;。该特性可以通过删除 <span class="Type">'cpoptions'</span> 选项里的 'a' 标志位来关闭。

<span class="Special">[++opt]</span> 参数里，有一个是 &quot;:read&quot; 专用的: ++edit 参数。当 &quot;:read&quot; 命令就像编辑
文件一样把文件读入到缓冲区时，这个参数很有用。在空缓冲区上使用如下命令:<span class="Ignore"> &gt;</span>
<span class="Comment">	:read ++edit filename</span>
效果是 <span class="Type">'fileformat'</span>、<span class="Type">'fileencoding'</span>、<span class="Type">'bomb'</span> 等选项根据 &quot;filename&quot; 的检测进行设
置。注意 会留下一行空行，你也许想把它删掉。

							<span class="Ignore">*</span><span class="String">file-read</span><span class="Ignore">*</span>
<span class="Type">'fileformat'</span> 选项设置文件的 <span class="Special">&lt;EOL&gt;</span> 风格:
<span class="PreProc">'fileformat'    字符		   名称			</span><span class="Ignore">	~</span>
  &quot;dos&quot;		<span class="Special">&lt;CR&gt;&lt;NL&gt;</span> 或 <span class="Special">&lt;NL&gt;</span>   DOS 格式
  &quot;unix&quot;	<span class="Special">&lt;NL&gt;</span>		   Unix 格式
  &quot;mac&quot;		<span class="Special">&lt;CR&gt;</span>		   Mac 格式
以前使用 <span class="Type">'textmode'</span>。现在已经废弃了。

如果 <span class="Type">'fileformat'</span> 为 &quot;dos&quot;，在 <span class="Special">&lt;NL&gt;</span> 之前的 <span class="Special">&lt;CR&gt;</span> 被忽略，而在文件尾部的 <span class="Special">CTRL-Z</span>
被忽略。

如果 <span class="Type">'fileformat'</span> 为 &quot;mac&quot;，文件里的 <span class="Special">&lt;NL&gt;</span> 被内部表示为 <span class="Special">&lt;CR&gt;</span>。这是为了避免和用
来表示 <span class="Special">&lt;NUL&gt;</span> 的 <span class="Special">&lt;NL&gt;</span> 引起混淆。见 <span class="Ignore">|</span><span class="Identifier">CR-used-for-NL</span><span class="Ignore">|</span>。

如果 <span class="Type">'fileformats'</span> 选项不为空，Vim 试图识别 <span class="Special">&lt;EOL&gt;</span> 的类型 (见 <span class="Ignore">|</span><span class="Identifier">file-formats</span><span class="Ignore">|</span>)。
不过，<span class="Type">'fileformat'</span> 选项的值不会被改变，检测到的格式只会在读入文件时使用。
<span class="Type">'fileencodings'</span> 与此情形类似。

在非 MS-DOS、Win32 和 OS/2 系统上，消息 &quot;[dos format]&quot; 会在读入 DOS 格式的文件
时给出，以提醒你发生了不寻常的事情。
在 Macintosh、MS-DOS、Win32 和 OS/2 系统上，消息 &quot;[unix format]&quot; 会在读入 Unix
格式的文件时给出。
在非 Macintosh 的系统上，消息 &quot;[Mac format]&quot; 会在读入 Mac 格式的文件时给出。

关于如何使用 &quot;:r !&quot; 的一个例子:<span class="Ignore"> &gt;</span>
<span class="Comment">	:r !uuencode binfile binfile</span>
该命令读入 &quot;binfile&quot;，用 uuencode 进行编码，并读入当前缓冲区。可以用于编辑包含
附带的二进制的文件的 e-mail。

							<span class="Ignore">*</span><span class="String">read-messages</span><span class="Ignore">*</span>
在读入文件时，Vim 会显示消息，显示读入文件的相关信息。以下的表格给出一些项目的
解释。其它的项目都不言自明。使用长格式还是短格式取决于 <span class="Type">'shortmess'</span> 选项的设
置。

	<span class="PreProc">长		短		含义</span><span class="Ignore"> ~</span>
	[readonly]	<span class="Special">{RO}</span>		文件被写保护
	[fifo/socket]			使用流
	[fifo]				使用 fifo 流
	[socket]			使用套接字 (socket) 流
	[CR missing]			使用 &quot;dos&quot; <span class="Type">'fileformat'</span> 读入文件的时候
					出现没有前导的 CR 的 NL
	[NL found]			使用 &quot;mac&quot; <span class="Type">'fileformat'</span> 读入文件的时候
					出现 NL (可能是 &quot;unix&quot; 格式)
	[long lines split]		至少一行以上被分割
	[NOT converted]			期待从 <span class="Type">'fileencoding'</span> 到 <span class="Type">'encoding'</span> 的
					转换但是做不到
	[converted]			从 <span class="Type">'fileencoding'</span> 到 <span class="Type">'encoding'</span> 的转换
					完成
	[crypted]			文件被解密
	[READ ERRORS]			不是文件所有部分都被成功读入


 vim&#0058;tw=78:ts=8:ft=help:norl:
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
