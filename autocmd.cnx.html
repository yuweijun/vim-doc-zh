<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/github.com/yuweijun/yuweijun.github.io/vim-zh/autocmd.cnx.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="molokai">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #d0d0d0; background-color: #121212; }
body { font-family: monospace; color: #d0d0d0; background-color: #121212; }
* { font-size: 1em; }
.String { color: #afaf87; }
.Type { color: #5fd7ff; }
.PreProc { color: #87ff00; }
.Identifier { color: #ff8700; }
.Comment { color: #5f5f5f; }
.Special { color: #5fd7ff; }
.Ignore { color: #808080; background-color: #080808; padding-bottom: 1px; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span class="String">autocmd.txt</span><span class="Ignore">*</span>   For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年7月


		  VIM 参考手册    by Bram Moolenaar
				译者: Willis
				<span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>


自动命令						<span class="Ignore">*</span><span class="String">autocommand</span><span class="Ignore">*</span>

一个基本的介绍可以在用户手册的 <span class="Ignore">|</span><span class="Identifier">40.3</span><span class="Ignore">|</span> 章节找到。

1.  简介			<span class="Ignore">|</span><span class="Identifier">autocmd-intro</span><span class="Ignore">|</span>
2.  定义自动命令		<span class="Ignore">|</span><span class="Identifier">autocmd-define</span><span class="Ignore">|</span>
3.  删除自动命令	 	<span class="Ignore">|</span><span class="Identifier">autocmd-remove</span><span class="Ignore">|</span>
4.  列出自动命令		<span class="Ignore">|</span><span class="Identifier">autocmd-list</span><span class="Ignore">|</span>
5.  事件			<span class="Ignore">|</span><span class="Identifier">autocmd-events</span><span class="Ignore">|</span>
6.  模式			<span class="Ignore">|</span><span class="Identifier">autocmd-patterns</span><span class="Ignore">|</span>
7.  局部于缓冲区的自动命令	<span class="Ignore">|</span><span class="Identifier">autocmd-buflocal</span><span class="Ignore">|</span>
8.  组				<span class="Ignore">|</span><span class="Identifier">autocmd-groups</span><span class="Ignore">|</span>
9.  执行自动命令		<span class="Ignore">|</span><span class="Identifier">autocmd-execute</span><span class="Ignore">|</span>
10. 自动命令的使用		<span class="Ignore">|</span><span class="Identifier">autocmd-use</span><span class="Ignore">|</span>
11. 屏蔽自动命令		<span class="Ignore">|</span><span class="Identifier">autocmd-disable</span><span class="Ignore">|</span>

<span class="Special">{Vi 没有任何以上的命令}</span>
{仅当编译时加入 <span class="Ignore">|</span><span class="Identifier">+autocmd</span><span class="Ignore">|</span> 特性才有效}

<span class="PreProc">==============================================================================</span>
1. 简介							<span class="Ignore">*</span><span class="String">autocmd-intro</span><span class="Ignore">*</span>

在文件读写，缓冲区或窗口进出，甚至 Vim 退出等时刻，你都可以指定要自动执行的命
令。例如，你可以创建一个自动命令，对匹配 *.c 的文件自动置位 <span class="Type">'cindent'</span> 选项。你
还可以用自动命令来实现诸如编辑压缩文件 (见 <span class="Ignore">|</span><span class="Identifier">gzip-example</span><span class="Ignore">|</span>) 等的高级特性。一般
来说，自动命令在 .vimrc 或 .exrc 文件里设置。

					<span class="Ignore">*</span><span class="String">E203</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E204</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E143</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E855</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E937</span><span class="Ignore">*</span>
警告: 自动命令功能强大，甚至会导致意想不到的副作用。小心你的文本不要遭到破坏。
- 最好能先在一个能够牺牲的副本上进行测试。
  例如: 如果你使用自动命令在文件开始编辑时进行解压，应确保写回时能正确执行压缩
  的自动命令。
- 准备好中途出现的错误 (例如，磁盘没有空间)。Vim 通常能够撤消缓冲区里的改动，
  但文件的其他方面改动需要你手动清理 (例如，压缩被解压的文件)。
- 如果 BufRead* 等事件允许你编辑一个压缩文件，FileRead* 等事件应该完成同样的操
  作 (这使得在一些特殊情况下内容可以恢复)。如果可能，尽量用相同的自动命令处理
  File* 和 Buf* 事件。

<span class="PreProc">==============================================================================</span>
2. 定义自动命令						<span class="Ignore">*</span><span class="String">autocmd-define</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:au</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:autocmd</span><span class="Ignore">*</span>
:au[tocmd] <span class="Special">[group]</span> <span class="Special">{event}</span> <span class="Special">{pat}</span> <span class="Special">[nested]</span> <span class="Special">{cmd}</span>
			把 <span class="Special">{cmd}</span> 加到 Vim 在匹配 <span class="Special">{pat}</span> 模式的文件执行 <span class="Special">{event}</span>
			事件时自动执行的命令列表。见 <span class="Ignore">|</span><span class="Identifier">autocmd-patterns</span><span class="Ignore">|</span>。
			Vim 总把 <span class="Special">{cmd}</span> 加到已有的自动命令之后，这样保证自动命
			令的执行顺序与其定义的顺序相同。
			关于 <span class="Special">[nested]</span>，参见 <span class="Ignore">|</span><span class="Identifier">autocmd-nested</span><span class="Ignore">|</span>。

特殊模式 <span class="Special">&lt;buffer&gt;</span> 或 &lt;buffer=<span class="Special">N</span>&gt; 定义局部于缓冲区的自动命令。见
<span class="Ignore">|</span><span class="Identifier">autocmd-buflocal</span><span class="Ignore">|</span>。

注意: 要在 &quot;:autocmd&quot; 命令之后紧跟其他命令， '|' 必须在 <span class="Special">{cmd}</span> 之前。可以这
样:<span class="Ignore"> &gt;</span>
<span class="Comment">	:augroup mine | au! BufRead | augroup END</span>
但下列命令会把 &quot;augroup&quot; 视为所定义命令的一部分:<span class="Ignore"> &gt;</span>
<span class="Comment">	:augroup mine | au BufRead * set tw=70 | augroup END</span>


注意 &quot;:autocmd&quot; 的参数里的特殊字符 (例如，&quot;%&quot;、&quot;<span class="Special">&lt;cword&gt;</span>&quot;) 在定义时不会被扩展，
而是在事件发生并执行 <span class="Special">{cmd}</span> 的时候才进行。唯一的例外是 &quot;<span class="Special">&lt;sfile&gt;</span>&quot; 在定义时扩展。
例如:
<span class="Ignore">&gt;</span>
<span class="Comment">	:au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</span>

这里 Vim 把 <span class="Special">&lt;sfile&gt;</span> 扩展为该行所在的文件名。

即使已经执行过，:autocmd 仍会把同一命令加入自动命令列表。如果你的 .vimrc 被执
行两次，自动命令就会出现两次。要避免这个问题，在一个组里定义自动命令，这样方便
清除之前的命令:<span class="Ignore"> &gt;</span>

<span class="Comment">	augroup vimrc</span>
<span class="Comment">	  autocmd!	&quot; 清除 vimcrc 组全部的的自动命令</span>
<span class="Comment">	  au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</span>
<span class="Comment">	augroup END</span>

如果你不想删除所有的自动命令，可以用变量来确保 Vim 只定义自动命令一次:<span class="Ignore"> &gt;</span>

<span class="Comment">	:if !exists(&quot;autocommands_loaded&quot;)</span>
<span class="Comment">	:  let autocommands_loaded = 1</span>
<span class="Comment">	:  au ...</span>
<span class="Comment">	:endif</span>

如果没有给定 <span class="Special">{group}</span> 参数，Vim 使用当前组 (由 &quot;:augroup&quot; 定义)；不然，Vim 使用
<span class="Special">{group}</span> 定义的组。注意 该 <span class="Special">[group]</span> 必须事先定义。定义新组不能用 &quot;:au group ...&quot;
而应该用 &quot;:augroup&quot;。

测试自动命令时，你也许会发现 <span class="Type">'verbose'</span> 选项很有用:<span class="Ignore"> &gt;</span>
<span class="Comment">	:set verbose=9</span>
这个设置使得 Vim 在执行自动命令时回显之。

在脚本里定义自动命令时，可以调用局部于脚本的函数或者使用局部于脚本的映射。在事
件激活并执行相应命令时，该命令在定义脚本的上下文内执行。如果命令里用到
<span class="Ignore">|</span><span class="Identifier">&lt;SID&gt;</span><span class="Ignore">|</span>，这一点很重要。

执行命令时，某个命令的消息覆盖前一个的。这和手动执行命令不同。通常，屏幕不会滚
动，所以也不会有按-回车的提示。但当一个命令输出两条消息时，这仍会发生。

<span class="PreProc">==============================================================================</span>
3. 删除自动命令						<span class="Ignore">*</span><span class="String">autocmd-remove</span><span class="Ignore">*</span>

:au[tocmd]! <span class="Special">[group]</span> <span class="Special">{event}</span> <span class="Special">{pat}</span> <span class="Special">[nested]</span> <span class="Special">{cmd}</span>
			删除所有和 <span class="Special">{event}</span> 事件和 <span class="Special">{pat}</span> 模式相关联的自动命
			令，然后加入命令 <span class="Special">{cmd}</span>。关于 <span class="Special">[nested]</span>，参见
			<span class="Ignore">|</span><span class="Identifier">autocmd-nested</span><span class="Ignore">|</span>。

:au[tocmd]! <span class="Special">[group]</span> <span class="Special">{event}</span> <span class="Special">{pat}</span>
			删除所有和 <span class="Special">{event}</span> 事件和 <span class="Special">{pat}</span> 模式相关联的自动命
			令。

:au[tocmd]! <span class="Special">[group]</span> * <span class="Special">{pat}</span>
			删除所有和 <span class="Special">{pat}</span> 模式相关联的自动命令。

:au[tocmd]! <span class="Special">[group]</span> <span class="Special">{event}</span>
			删除所有和 <span class="Special">{event}</span> 事件相关联的自动命令。
			警告: 没有给出组时，不要轻易用本命令对 BufRead 和其它
			常用事件进行操作，可能会对插件、语法高亮等产生破坏。

:au[tocmd]! <span class="Special">[group]</span>	删除所有的自动命令。
			警告: 没有给出组时，不要轻易用本命令，会对插件、语法高
			亮等产生破坏。

如果没有给出 <span class="Special">{group}</span> 参数，Vim 使用当前组 (由 &quot;:augroup&quot; 定义)；不然，Vim 使用
<span class="Special">{group}</span> 定义的组。

<span class="PreProc">==============================================================================</span>
4. 列出自动命令						<span class="Ignore">*</span><span class="String">autocmd-list</span><span class="Ignore">*</span>

:au[tocmd] <span class="Special">[group]</span> <span class="Special">{event}</span> <span class="Special">{pat}</span>
			显示所有和 <span class="Special">{event}</span> 事件和 <span class="Special">{pat}</span> 模式相关联的自动命
			令。

:au[tocmd] <span class="Special">[group]</span> * <span class="Special">{pat}</span>
			显示所有和 <span class="Special">{pat}</span> 模式相关联的自动命令。

:au[tocmd] <span class="Special">[group]</span> <span class="Special">{event}</span>
			显示所有和 <span class="Special">{event}</span> 事件相关联的自动命令。

:au[tocmd] <span class="Special">[group]</span>	显示所有自动命令。

如果给出 <span class="Special">{group}</span> 参数，Vim 只列出 <span class="Special">[group]</span> 里的自动命令；不然，Vim 列出_所有_组
里的自动命令。注意 此处该参数的行为和定义与删除自动命令时的不同。

要列出局部于缓冲区的自动命令，使用如下形式的模式 <span class="Special">&lt;buffer&gt;</span> 或 &lt;buffer=<span class="Special">N</span>&gt;。见
<span class="Ignore">|</span><span class="Identifier">autocmd-buflocal</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:autocmd-verbose</span><span class="Ignore">*</span>
如果 <span class="Type">'verbose'</span> 非空，列出自动命令同时显示该自动命令最近修改的位置。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">    :verbose autocmd BufEnter</span>
<span class="Comment">    FileExplorer  BufEnter</span>
<span class="Comment">	*	  call s:LocalBrowse(expand(&quot;&lt;amatch&gt;&quot;))</span>
<span class="Comment">	    Last set from /usr/share/vim/vim-7.0/plugin/NetrwPlugin.vim</span>
<span class="Ignore">&lt;</span>
详见 <span class="Ignore">|</span><span class="Identifier">:verbose-cmd</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
5. 事件						<span class="Ignore">*</span><span class="String">autocmd-events</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E215</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E216</span><span class="Ignore">*</span>

你可以指定逗号分隔的事件名列表。此列表中不能有空格。该命令应用于列表里的所有事
件。

_文件读入_时，有四类可能的事件:
	BufNewFile			开始编辑一个还不存在的文件
	BufReadPre	BufReadPost	开始编辑一个已经存在的文件
	FilterReadPre	FilterReadPost	读取过滤程序输出的暂存文件
	FileReadPre	FileReadPost	任何别的文件读入
Vim 读入文件时，只用这四类中的一类。&quot;Pre&quot; 和 &quot;Post&quot; 事件被双双激活，分别在文件
读取的前后。

注意 *ReadPre 和所有的过滤事件的自动命令不能更换当前缓冲区 (如果你这么做，会得
到错误信息)。可用来防止文件被读入错误的缓冲区。

注意 执行完 BufReadPost 和 BufNewFile 自动命令_之后_复位 <span class="Type">'modified'</span> 标志位，但
如果自动命令已经置位了 <span class="Type">'modified'</span> 选项除外。

你可以使用 <span class="Type">'eventignore'</span> 选项来忽略若干甚至全部事件。
					<span class="Ignore">*</span><span class="String">autocommand-events</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">{event}</span><span class="Ignore">*</span>
Vim 识别以下事件，事件名的大小写被忽略 (例如，你可以使用 &quot;BUFread&quot; 或者
&quot;bufread&quot; 来取代 &quot;BufRead&quot;)。

这里首先提供功能的总览并提供简短说明。然后，按字母顺序列出它们的详细解释
<span class="Ignore">|</span><span class="Identifier">autocmd-events-abc</span><span class="Ignore">|</span>。

<span class="PreProc">名字			激活条件</span><span class="Ignore"> ~</span>

	读入
<span class="Ignore">|</span><span class="Identifier">BufNewFile</span><span class="Ignore">|</span>		开始编辑尚不存在的文件
<span class="Ignore">|</span><span class="Identifier">BufReadPre</span><span class="Ignore">|</span>		开始编辑新缓冲区，读入文件前
<span class="Ignore">|</span><span class="Identifier">BufRead</span><span class="Ignore">|</span>		开始编辑新缓冲区，读入文件后
<span class="Ignore">|</span><span class="Identifier">BufReadPost</span><span class="Ignore">|</span>		开始编辑新缓冲区，读入文件后
<span class="Ignore">|</span><span class="Identifier">BufReadCmd</span><span class="Ignore">|</span>		开始编辑新缓冲区前 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">FileReadPre</span><span class="Ignore">|</span>		用 &quot;:read&quot; 命令读入文件前
<span class="Ignore">|</span><span class="Identifier">FileReadPost</span><span class="Ignore">|</span>		用 &quot;:read&quot; 命令读入文件后
<span class="Ignore">|</span><span class="Identifier">FileReadCmd</span><span class="Ignore">|</span>		用 &quot;:read&quot; 命令读入文件前 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">FilterReadPre</span><span class="Ignore">|</span>		用过滤命令读入文件前
<span class="Ignore">|</span><span class="Identifier">FilterReadPost</span><span class="Ignore">|</span>	用过滤命令读入文件后

<span class="Ignore">|</span><span class="Identifier">StdinReadPre</span><span class="Ignore">|</span>		从标准输入读入缓冲区前
<span class="Ignore">|</span><span class="Identifier">StdinReadPost</span><span class="Ignore">|</span>		从标准输入读入缓冲区后

	写回
<span class="Ignore">|</span><span class="Identifier">BufWrite</span><span class="Ignore">|</span>		开始把整个缓冲区写回到文件
<span class="Ignore">|</span><span class="Identifier">BufWritePre</span><span class="Ignore">|</span>		开始把整个缓冲区写回到文件
<span class="Ignore">|</span><span class="Identifier">BufWritePost</span><span class="Ignore">|</span>		把整个缓冲区写回到文件后
<span class="Ignore">|</span><span class="Identifier">BufWriteCmd</span><span class="Ignore">|</span>		把整个缓冲区写回到文件前 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">FileWritePre</span><span class="Ignore">|</span>		开始把缓冲区部分内容写回到文件
<span class="Ignore">|</span><span class="Identifier">FileWritePost</span><span class="Ignore">|</span>		把缓冲区部分内容写回到文件后
<span class="Ignore">|</span><span class="Identifier">FileWriteCmd</span><span class="Ignore">|</span>		把缓冲区部分内容写回到文件前 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">FileAppendPre</span><span class="Ignore">|</span>		开始附加到文件
<span class="Ignore">|</span><span class="Identifier">FileAppendPost</span><span class="Ignore">|</span>	附加到文件后
<span class="Ignore">|</span><span class="Identifier">FileAppendCmd</span><span class="Ignore">|</span>		附加到文件前 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">FilterWritePre</span><span class="Ignore">|</span>	开始为过滤命令或 diff 写到文件
<span class="Ignore">|</span><span class="Identifier">FilterWritePost</span><span class="Ignore">|</span>	为过滤命令或 diff 写到文件后

	缓冲区
<span class="Ignore">|</span><span class="Identifier">BufAdd</span><span class="Ignore">|</span>		刚把缓冲区附加到缓冲区列表后
<span class="Ignore">|</span><span class="Identifier">BufCreate</span><span class="Ignore">|</span>		刚把缓冲区附加到缓冲区列表后
<span class="Ignore">|</span><span class="Identifier">BufDelete</span><span class="Ignore">|</span>		从缓冲区列表删除缓冲区前
<span class="Ignore">|</span><span class="Identifier">BufWipeout</span><span class="Ignore">|</span>		从缓冲区列表完全删除缓冲区前

<span class="Ignore">|</span><span class="Identifier">BufFilePre</span><span class="Ignore">|</span>		改变当前缓冲区名字前
<span class="Ignore">|</span><span class="Identifier">BufFilePost</span><span class="Ignore">|</span>		改变当前缓冲区名字后

<span class="Ignore">|</span><span class="Identifier">BufEnter</span><span class="Ignore">|</span>		进入缓冲区后
<span class="Ignore">|</span><span class="Identifier">BufLeave</span><span class="Ignore">|</span>		转到其它缓冲区前
<span class="Ignore">|</span><span class="Identifier">BufWinEnter</span><span class="Ignore">|</span>		在窗口显示缓冲区前
<span class="Ignore">|</span><span class="Identifier">BufWinLeave</span><span class="Ignore">|</span>		从窗口删除缓冲区前

<span class="Ignore">|</span><span class="Identifier">BufUnload</span><span class="Ignore">|</span>		卸载缓冲区前
<span class="Ignore">|</span><span class="Identifier">BufHidden</span><span class="Ignore">|</span>		刚把缓冲区变为隐藏后
<span class="Ignore">|</span><span class="Identifier">BufNew</span><span class="Ignore">|</span>		刚建立新缓冲区后

<span class="Ignore">|</span><span class="Identifier">SwapExists</span><span class="Ignore">|</span>		检测到交换文件已经存在

	选项
<span class="Ignore">|</span><span class="Identifier">FileType</span><span class="Ignore">|</span>		设置 <span class="Type">'filetype'</span> 选项时
<span class="Ignore">|</span><span class="Identifier">Syntax</span><span class="Ignore">|</span>		设置 <span class="Type">'syntax'</span> 选项时
<span class="Ignore">|</span><span class="Identifier">EncodingChanged</span><span class="Ignore">|</span>	<span class="Type">'encoding'</span> 选项改变后
<span class="Ignore">|</span><span class="Identifier">TermChanged</span><span class="Ignore">|</span>		<span class="Type">'term'</span> 的值改变后
<span class="Ignore">|</span><span class="Identifier">OptionSet</span><span class="Ignore">|</span>		设置任何选项后

	启动和退出
<span class="Ignore">|</span><span class="Identifier">VimEnter</span><span class="Ignore">|</span>		完成所有的初始化步骤后
<span class="Ignore">|</span><span class="Identifier">GUIEnter</span><span class="Ignore">|</span>		成功启动 GUI 后
<span class="Ignore">|</span><span class="Identifier">GUIFailed</span><span class="Ignore">|</span>		启动 GUI 失败之后
<span class="Ignore">|</span><span class="Identifier">TermResponse</span><span class="Ignore">|</span>		收到 <span class="Ignore">|</span><span class="Identifier">t_RV</span><span class="Ignore">|</span> 的终端应答后

<span class="Ignore">|</span><span class="Identifier">QuitPre</span><span class="Ignore">|</span>		用 <span class="Ignore">`</span><span class="Comment">:quit</span><span class="Ignore">`</span> 时，决定是否退出之前
<span class="Ignore">|</span><span class="Identifier">VimLeavePre</span><span class="Ignore">|</span>		退出 Vim 前，在写入 viminfo 文件之前
<span class="Ignore">|</span><span class="Identifier">VimLeave</span><span class="Ignore">|</span>		退出 Vim 前，在写入 viminfo 文件之后

	杂项
<span class="Ignore">|</span><span class="Identifier">FileChangedShell</span><span class="Ignore">|</span>	Vim 注意到文件在编辑开始后被改变
<span class="Ignore">|</span><span class="Identifier">FileChangedShellPost</span><span class="Ignore">|</span>	对在编辑开始后被改变的文件的处理完成后
<span class="Ignore">|</span><span class="Identifier">FileChangedRO</span><span class="Ignore">|</span>		对只读文件进行第一次修改前

<span class="Ignore">|</span><span class="Identifier">ShellCmdPost</span><span class="Ignore">|</span>		执行外壳命令后
<span class="Ignore">|</span><span class="Identifier">ShellFilterPost</span><span class="Ignore">|</span>	用外壳命令执行完过滤后

<span class="Ignore">|</span><span class="Identifier">CmdUndefined</span><span class="Ignore">|</span>		调用没有定义的用户命令
<span class="Ignore">|</span><span class="Identifier">FuncUndefined</span><span class="Ignore">|</span>		调用没有定义的用户函数
<span class="Ignore">|</span><span class="Identifier">SpellFileMissing</span><span class="Ignore">|</span>	使用不存在的拼写文件
<span class="Ignore">|</span><span class="Identifier">SourcePre</span><span class="Ignore">|</span>		执行 Vim 脚本之前
<span class="Ignore">|</span><span class="Identifier">SourceCmd</span><span class="Ignore">|</span>		执行 Vim 脚本之前 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

<span class="Ignore">|</span><span class="Identifier">VimResized</span><span class="Ignore">|</span>		Vim 窗口大小改变后
<span class="Ignore">|</span><span class="Identifier">FocusGained</span><span class="Ignore">|</span>		Vim 得到输入焦点
<span class="Ignore">|</span><span class="Identifier">FocusLost</span><span class="Ignore">|</span>		Vim 失去输入焦点
<span class="Ignore">|</span><span class="Identifier">CursorHold</span><span class="Ignore">|</span>		用户有一段时间没有按键
<span class="Ignore">|</span><span class="Identifier">CursorHoldI</span><span class="Ignore">|</span>		在插入模式下，用户有一段时间没有按键
<span class="Ignore">|</span><span class="Identifier">CursorMoved</span><span class="Ignore">|</span>		普通模式下移动了光标
<span class="Ignore">|</span><span class="Identifier">CursorMovedI</span><span class="Ignore">|</span>		插入模式下移动了光标

<span class="Ignore">|</span><span class="Identifier">WinNew</span><span class="Ignore">|</span>		创建新窗口后
<span class="Ignore">|</span><span class="Identifier">TabNew</span><span class="Ignore">|</span>		创建新标签页后
<span class="Ignore">|</span><span class="Identifier">TabClosed</span><span class="Ignore">|</span>		关闭标签页后
<span class="Ignore">|</span><span class="Identifier">WinEnter</span><span class="Ignore">|</span>		进入其它窗口后
<span class="Ignore">|</span><span class="Identifier">WinLeave</span><span class="Ignore">|</span>		离开窗口前
<span class="Ignore">|</span><span class="Identifier">TabEnter</span><span class="Ignore">|</span>		进入其它标签页后
<span class="Ignore">|</span><span class="Identifier">TabLeave</span><span class="Ignore">|</span>		离开标签页前
<span class="Ignore">|</span><span class="Identifier">CmdwinEnter</span><span class="Ignore">|</span>		进入命令行窗口后
<span class="Ignore">|</span><span class="Identifier">CmdwinLeave</span><span class="Ignore">|</span>		离开命令行窗口前

<span class="Ignore">|</span><span class="Identifier">InsertEnter</span><span class="Ignore">|</span>		开始插入模式前
<span class="Ignore">|</span><span class="Identifier">InsertChange</span><span class="Ignore">|</span>		在插入或替换模式下输入 <span class="Special">&lt;Insert&gt;</span> 时
<span class="Ignore">|</span><span class="Identifier">InsertLeave</span><span class="Ignore">|</span>		离开插入模式时
<span class="Ignore">|</span><span class="Identifier">InsertCharPre</span><span class="Ignore">|</span>		插入模式输入每个字符前

<span class="Ignore">|</span><span class="Identifier">TextChanged</span><span class="Ignore">|</span>		普通模式中对文本进行改变后
<span class="Ignore">|</span><span class="Identifier">TextChangedI</span><span class="Ignore">|</span>		插入模式中对文本进行改变后

<span class="Ignore">|</span><span class="Identifier">ColorScheme</span><span class="Ignore">|</span>		载入色彩方案后

<span class="Ignore">|</span><span class="Identifier">RemoteReply</span><span class="Ignore">|</span>		得到了 Vim 服务器的应答

<span class="Ignore">|</span><span class="Identifier">QuickFixCmdPre</span><span class="Ignore">|</span>	执行 quickfix 命令前
<span class="Ignore">|</span><span class="Identifier">QuickFixCmdPost</span><span class="Ignore">|</span>	执行 quickfix 命令后

<span class="Ignore">|</span><span class="Identifier">SessionLoadPost</span><span class="Ignore">|</span>	载入会话文件后

<span class="Ignore">|</span><span class="Identifier">MenuPopup</span><span class="Ignore">|</span>		刚要显示弹出菜单前
<span class="Ignore">|</span><span class="Identifier">CompleteDone</span><span class="Ignore">|</span>		插入模式补全结束之后

<span class="Ignore">|</span><span class="Identifier">User</span><span class="Ignore">|</span>			和 &quot;:doautocmd&quot; 一起使用


自动命令事件按字母顺序排列的列表			<span class="Ignore">*</span><span class="String">autocmd-events-abc</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">BufCreate</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">BufAdd</span><span class="Ignore">*</span>
BufAdd 或 BufCreate		缓冲区列表加入缓冲区后。可以是刚建立的新缓冲区
				或者是已有的缓冲区。
				也在缓冲区列表的某个缓冲区换名之后发生。
				BufCreate 的名称有其历史原因。
				注意: 执行此自动命令时，当前缓冲区 &quot;%&quot; 可能会
				和被建立的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
							<span class="Ignore">*</span><span class="String">BufDelete</span><span class="Ignore">*</span>
BufDelete			缓冲区列表删除缓冲区前。可能先调用 BufUnload
				事件 (如果该缓冲区已经载入的话)。
				也在缓冲区列表的某个缓冲区换名之前发生。
				注意: 执行此自动命令时，当前缓冲区 &quot;%&quot; 可能会
				和被删除的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 及 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
				此处不可切换到其它缓冲区，否则会引起问题。
							<span class="Ignore">*</span><span class="String">BufEnter</span><span class="Ignore">*</span>
BufEnter			进入缓冲区后。可用来设定有关文件类型的选项。也
				在开始编辑缓冲区时执行，它发生在 BufReadPost
				自动命令之后。
							<span class="Ignore">*</span><span class="String">BufFilePost</span><span class="Ignore">*</span>
BufFilePost			&quot;:file&quot; 或 &quot;:saveas&quot; 命令改变当前缓冲区的名字
				后。
							<span class="Ignore">*</span><span class="String">BufFilePre</span><span class="Ignore">*</span>
BufFilePre			&quot;:file&quot; 或 &quot;:saveas&quot; 命令改变当前缓冲区的名字
				前。
							<span class="Ignore">*</span><span class="String">BufHidden</span><span class="Ignore">*</span>
BufHidden			缓冲区刚被隐藏后。也就是说，没有窗口显示该缓冲
				区，但是它没有被卸载或者删除。&quot;:qa&quot; 或者 &quot;:q&quot;
				退出 Vim 时不会激活该事件。
				注意: 执行此自动命令时，当前缓冲区 &quot;%&quot; 可能会
				和被隐藏的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
							<span class="Ignore">*</span><span class="String">BufLeave</span><span class="Ignore">*</span>
BufLeave			转到别的缓冲区前、或离开/关闭当前窗口并且新的
				当前窗口编辑的不是相同的缓冲区前，
				&quot;:qa&quot; 或 &quot;:q&quot; 退出 Vim 时不会激活此事件。
							<span class="Ignore">*</span><span class="String">BufNew</span><span class="Ignore">*</span>
BufNew				刚建立新缓冲区或给缓冲区换名后。缓冲区被加到缓
				冲区列表时，同时会激活 BufAdd 事件。
				注意: 执行此自动命令时，当前缓冲区 &quot;%&quot; 可能会
				和被建立的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
							<span class="Ignore">*</span><span class="String">BufNewFile</span><span class="Ignore">*</span>
BufNewFile			开始编辑尚未存在的文件时。可用来读入骨架文件。
						<span class="Ignore">*</span><span class="String">BufRead</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">BufReadPost</span><span class="Ignore">*</span>
BufRead 或 BufReadPost		开始编辑新的缓冲区并把文件读入缓冲区后，执行模
				式行之前。模式行之后的事件，见 <span class="Ignore">|</span><span class="Identifier">BufWinEnter</span><span class="Ignore">|</span>。
				_不_适用于 &quot;:r file&quot;，也不适用于文件还不存在的
				情况。但在成功修复文件之后会激活该事件。
				也在 &quot;:filetype detect&quot; 执行时，激活
				filetypedetect 自动命令组中的本事件。还有，写
				回未命名缓冲区时如使缓冲区取得名字，也会激活。
							<span class="Ignore">*</span><span class="String">BufReadCmd</span><span class="Ignore">*</span>
BufReadCmd			开始编辑新的缓冲区前。应执行把文件读入缓冲区的
				操作。<span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>
						<span class="Ignore">*</span><span class="String">BufReadPre</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E200</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E201</span><span class="Ignore">*</span>
BufReadPre			开始编辑新的缓冲区并把文件读入缓冲区前。如果文
				件还不存在，不会有此事件。
							<span class="Ignore">*</span><span class="String">BufUnload</span><span class="Ignore">*</span>
BufUnload			缓冲区卸载前。此时，缓冲区里的文本将要被释放。
				可在 BufWritePost 后和 BufDelete 前发生。 Vim
				即将退出时，每个载入的缓冲区也会收到该事件。
				注意: 执行此自动命令时，当前缓冲区 &quot;%&quot; 可能会
				和被卸载的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
				此处不可切换到其它缓冲区或窗口，否则会引起问
				题。
				退出时如果 v:dying 至少为 2，不触发此事件。
							<span class="Ignore">*</span><span class="String">BufWinEnter</span><span class="Ignore">*</span>
BufWinEnter			窗口显示缓冲区后。可以是新缓冲区载入 (处理完模
				式行之后) 或者隐藏缓冲区在窗口开始显示 (从而不
				再隐藏)。
				不带参数的 <span class="Ignore">|</span><span class="Identifier">:split</span><span class="Ignore">|</span> 不激活此事件，因为你继续编
				辑的是同一个缓冲区，&quot;:split&quot; 已在某窗口打开的
				文件也是如此，同样因为它重用已有的缓冲区。但用
				当前缓冲区名来 &quot;:split&quot; 却会激活本事件，因为此
				时该缓冲区被重新载入。
							<span class="Ignore">*</span><span class="String">BufWinLeave</span><span class="Ignore">*</span>
BufWinLeave			窗口删除缓冲区前。除非它在别的窗口仍然可见。
				系统退出时也会激活。在 BufUnload 或 BufHidden
				之前激活。
				注意: 当此自动命令被执行时，当前缓冲区 &quot;%&quot; 可
				能会和被卸载的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
				退出时如果 v:dying 至少为 2，不触发此事件。
							<span class="Ignore">*</span><span class="String">BufWipeout</span><span class="Ignore">*</span>
BufWipeout			完全删除缓冲区前。可能先调用 BufUnload 和
				BufDelete 事件 (如果缓冲区已经载入并且在缓冲区
				列表之中的话)。
				也在不在缓冲区列表的某个缓冲区换名之前发生。
				注意: 执行此自动命令时，当前缓冲区 &quot;%&quot; 可能会
				和被删除的缓冲区 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 不同。
				此处不可切换到其它缓冲区，否则会引起问题。
						<span class="Ignore">*</span><span class="String">BufWrite</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">BufWritePre</span><span class="Ignore">*</span>
BufWrite 或 BufWritePre		把整个缓冲区写回到文件前。
							<span class="Ignore">*</span><span class="String">BufWriteCmd</span><span class="Ignore">*</span>
BufWriteCmd			把整个缓冲区写回到文件前。应执行把文件写回的操
				作并在成功后复位 <span class="Type">'modified'</span> 标志，除非 <span class="Type">'cpo'</span>
				里包含了 '+' 并且写到另一个文件里 <span class="Ignore">|</span><span class="Identifier">cpo-+</span><span class="Ignore">|</span>。它
				不应改动缓冲区的内容。
				此操作复位 <span class="Type">'modified'</span> 时，调整撤销信息，把之前
				的撤销状态标记为 <span class="Type">'modified'</span>，这和 <span class="Ignore">|</span><span class="Identifier">:write</span><span class="Ignore">|</span> 的
				行为一致。
				<span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">BufWritePost</span><span class="Ignore">*</span>
BufWritePost			把整个缓冲区写回到文件后 (应该撤销 BufWritePre
				的相关命令)。
							<span class="Ignore">*</span><span class="String">CmdUndefined</span><span class="Ignore">*</span>
CmdUndefined			调用未定义的用户命令时。可以用来实现在实际调用
				时才提供动态定义的命令。模式匹配的是命令的名
				字。 <span class="Special">&lt;amatch&gt;</span> 和 <span class="Special">&lt;afile&gt;</span> 都被设为该命令的名
				字。
				注意: 在命令未定义前，自动补全不能工作。一个替
				代方法是总是定义好用户命令，使之调用自动载入函
				数。见 <span class="Ignore">|</span><span class="Identifier">autoload</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">CmdwinEnter</span><span class="Ignore">*</span>
CmdwinEnter			进入命令行窗口后。可用来对此特殊类型的窗口进行
				设置。激活此事件，而_不是_ BufEnter 和
				WinEnter 事件。
				<span class="Special">&lt;afile&gt;</span> 设为单个字符，指示命令行的类型。
				<span class="Ignore">|</span><span class="Identifier">cmdwin-char</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">CmdwinLeave</span><span class="Ignore">*</span>
CmdwinLeave			退出命令行窗口前。可用来清除任何 CmdwinEnter
				所做的全局设置。激活此事件，而_不是_ BufEnter
				和 WinEnter 事件。
				<span class="Special">&lt;afile&gt;</span> 设为单个字符，指示命令行的类型。
				<span class="Ignore">|</span><span class="Identifier">cmdwin-char</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">ColorScheme</span><span class="Ignore">*</span>
ColorScheme			载入色彩方案后。<span class="Ignore">|</span><span class="Identifier">:colorscheme</span><span class="Ignore">|</span>
				模式匹配的是色彩方案名。<span class="Special">&lt;afile&gt;</span> 可获得设置该选
				项时的实际文件名。<span class="Special">&lt;amatch&gt;</span> 为新色彩方案名。


							<span class="Ignore">*</span><span class="String">CompleteDone</span><span class="Ignore">*</span>
CompleteDone			插入模式补全结束之后。不管补会是否成功完成或是
				被放弃都会激活本事件。<span class="Ignore">|</span><span class="Identifier">ins-completion</span><span class="Ignore">|</span>
				<span class="Ignore">|</span><span class="Identifier">v:completed_item</span><span class="Ignore">|</span> 变量包含补全项目的信息。
							<span class="Ignore">*</span><span class="String">CursorHold</span><span class="Ignore">*</span>
CursorHold			用户在 <span class="Type">'updatetime'</span> 指定的时间里没有按键时。如
				果用户还没有按键，该事件不会再次激活 (就是说，
				如果你离开 Vim 去煮杯咖啡，该事件不会每
				<span class="Type">'updateime'</span> 毫秒就发生一次。:)
				<span class="Ignore">|</span><span class="Identifier">CursorHold-example</span><span class="Ignore">|</span> 提供了预览标签的范例。
				该事件只有在普通模式才会激活。等待输入命令参数
				或操作符之后的动作命令时，该事件不会发生。
				记录时，不激活 CursorHold 事件。<span class="Ignore">|</span><span class="Identifier">q</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">&lt;CursorHold&gt;</span><span class="Ignore">*</span>
				在内部实现里，<span class="Special">&lt;CursorHold&gt;</span> 键用来激活此自动命
				令。此字符在 <span class="Ignore">|</span><span class="Identifier">getchar()</span><span class="Ignore">|</span> 表达式映射中可见。

				注意: 该事件的处理不能使用交互的命令，不会有
				按 - 回车 (hit-enter) 的提示。
				注意: 将来设定时间可能有别的选项。
				提示: 要强制更新状态行，用:<span class="Ignore"> &gt;</span>
<span class="Comment">					:let &amp;ro = &amp;ro</span>
<span class="Ignore">&lt;</span>				{仅在 Amiga、Unix、Win32、MSDOS 和所有的 GUI
				版本上有效}
							<span class="Ignore">*</span><span class="String">CursorHoldI</span><span class="Ignore">*</span>
CursorHoldI			类似于 CursorHold，但用于插入模式。
				等待其它键时不激活。譬如在 <span class="Special">CTRL-V</span> 之后。也不适
				用于 <span class="Special">CTRL-X</span> 模式 <span class="Ignore">|</span><span class="Identifier">insert_expand</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">CursorMoved</span><span class="Ignore">*</span>
CursorMoved			在普通或可视模式下移动光标后。也用于光标行的文
				本被改变时，例如，使用 &quot;x&quot;、&quot;rx&quot; 或 &quot;p&quot;。
				如果有预输入或在等待操作符中，不激活之。
				示例可见 <span class="Ignore">|</span><span class="Identifier">match-parens</span><span class="Ignore">|</span>。
				小心: 本事件发生非常频繁，不要做任何用户意想不
				到或需时很久的事情。
							<span class="Ignore">*</span><span class="String">CursorMovedI</span><span class="Ignore">*</span>
CursorMovedI			在插入模式下移动光标后。但有弹出菜单时不激活。
				其余细节和 CursorMoved 相同。
							<span class="Ignore">*</span><span class="String">EncodingChanged</span><span class="Ignore">*</span>
EncodingChanged			改变 <span class="Type">'encoding'</span> 选项后激活。可用于设定字体。
							<span class="Ignore">*</span><span class="String">FileAppendCmd</span><span class="Ignore">*</span>
FileAppendCmd			附加到文件前。应执行附加到文件的操作。用 '[ 和
				'] 位置标记来定位行范围。<span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">FileAppendPost</span><span class="Ignore">*</span>
FileAppendPost			附加到文件后。
							<span class="Ignore">*</span><span class="String">FileAppendPre</span><span class="Ignore">*</span>
FileAppendPre			附加到文件前。用 '[ 和 '] 位置标记来定位行范
				围。
							<span class="Ignore">*</span><span class="String">FileChangedRO</span><span class="Ignore">*</span>
FileChangedRO			刚开始修改只读文件前。可以用来从源文件控制系统
				里更新文件。但如果该修改由自动命令产生，该事件
				不会发生。
				该事件在缓冲区的第一次修改或者 <span class="Type">'readonly'</span> 置位
				后的第一次修改时激活，就在文本刚刚要被修改前发
				生。
				警告: 如果在自动命令里移动了光标，此修改的效果
				无法预测。
							<span class="Ignore">*</span><span class="String">E788</span><span class="Ignore">*</span>
				这里不能切换到别的缓冲区。你可以重新载入本缓冲
				区，但不能用来编辑别的文件。
							<span class="Ignore">*</span><span class="String">E881</span><span class="Ignore">*</span>
				如果行数改变，撤销的保存可能会失败，相关改动也
				会被放弃。
							<span class="Ignore">*</span><span class="String">FileChangedShell</span><span class="Ignore">*</span>
FileChangedShell		Vim 注意到文件的修改时间不同于编辑开始的时间或
				者文件属性或文件大小发生改变时。<span class="Ignore">|</span><span class="Identifier">timestamp</span><span class="Ignore">|</span>
				该事件最有可能在执行外壳命令后发生，也可以在执
				行 <span class="Ignore">|</span><span class="Identifier">:checktime</span><span class="Ignore">|</span> 命令或 gvim 重新获得输入焦点后
				发生。
				该自动命令对每个发生改变的文件进行，但不包括置
				位了 <span class="Type">'autoread'</span> 且 (译者注: 似乎应为或) 没发生
				改变而的缓冲区。如果指定了 FileChangedShell 自
				动命令，不会给出相应的警告消息和提示。
				<span class="Ignore">|</span><span class="Identifier">v:fcs_reason</span><span class="Ignore">|</span> 变量被设置，以指示发生了什么
				事，而 <span class="Ignore">|</span><span class="Identifier">v:fcs_choice</span><span class="Ignore">|</span> 则可用来告知 Vim 下一步
				该做什么。
				注意: 当此自动命令执行时，当前缓冲区 &quot;%&quot; 可能
				和 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 指定的被改变的缓冲区不同。
				注意: 执行的命令必须不能修改当前缓冲区，跳转到
				别的缓冲区，或者删除任何一个缓冲区。
				<span class="Ignore">*</span><span class="String">E246</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E811</span><span class="Ignore">*</span>
				注意: 该事件不会嵌套而引起无限循环。这意味着，
				FileChangedShell 事件所执行的命令不会引起别的
				FileChangedShell 事件。
							<span class="Ignore">*</span><span class="String">FileChangedShellPost</span><span class="Ignore">*</span>
FileChangedShellPost		对外部改变的文件的处理完成后。可用于更新状态
				行。
							<span class="Ignore">*</span><span class="String">FileEncoding</span><span class="Ignore">*</span>
FileEncoding			已废弃。仍可用并等价于 <span class="Ignore">|</span><span class="Identifier">EncodingChanged</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">FileReadCmd</span><span class="Ignore">*</span>
FileReadCmd			&quot;:read&quot; 命令读入文件前。应执行把文件读入缓冲区
				的操作。<span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">FileReadPost</span><span class="Ignore">*</span>
FileReadPost			&quot;:read&quot; 命令读入文件后。
				注意 Vim 设置 '[' 和 ']' 位置标记为读入的首行
				和末行。它们可以用来操作刚读入的行范围。
							<span class="Ignore">*</span><span class="String">FileReadPre</span><span class="Ignore">*</span>
FileReadPre			&quot;:read&quot; 命令读入文件前。
							<span class="Ignore">*</span><span class="String">FileType</span><span class="Ignore">*</span>
FileType			设置 <span class="Type">'filetype'</span> 选项时。模式匹配的是文件类型。
				<span class="Special">&lt;afile&gt;</span> 可以用来取得设置该选项的文件名，而
				<span class="Special">&lt;amatch&gt;</span> 则是 <span class="Type">'filetype'</span> 的新值。参见
				<span class="Ignore">|</span><span class="Identifier">filetypes</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">FileWriteCmd</span><span class="Ignore">*</span>
FileWriteCmd			写入文件前，但不包括写入整个缓冲区。应执行写入
				文件的操作。不应改动缓冲区的内容。用 '[ 和 ']
				位置标记来定位行范围。
				<span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">FileWritePost</span><span class="Ignore">*</span>
FileWritePost			写入文件后，但不包括写入整个缓冲区。
							<span class="Ignore">*</span><span class="String">FileWritePre</span><span class="Ignore">*</span>
FileWritePre			写入文件前，但不包括写入整个缓冲区。用 '[ 和
				'] 位置标记来定位行范围。
							<span class="Ignore">*</span><span class="String">FilterReadPost</span><span class="Ignore">*</span>
FilterReadPost			过滤命令读入文件后。Vim 用当前缓冲区的名字来匹
				配模式，正如 FilterReadPre 那样。
				如果 <span class="Type">'shelltemp'</span> 关闭，不激活此事件。
							<span class="Ignore">*</span><span class="String">FilterReadPre</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E135</span><span class="Ignore">*</span>
FilterReadPre			过滤命令读入文件前。Vim 用当前缓冲区的名字来匹
				配模式，而不是过滤命令输出的临时文件名字。
				如果 <span class="Type">'shelltemp'</span> 关闭，不激活此事件。
							<span class="Ignore">*</span><span class="String">FilterWritePost</span><span class="Ignore">*</span>
FilterWritePost			过滤命令写入文件或产生 diff 文件后。Vim 用当前
				缓冲区的名字来匹配模式，正如 FilterWritePre 那
				样。
				如果 <span class="Type">'shelltemp'</span> 关闭，不激活此事件。
							<span class="Ignore">*</span><span class="String">FilterWritePre</span><span class="Ignore">*</span>
FilterWritePre			过滤程序写入文件或产生 diff 文件前。Vim 用当前
				缓冲区的名字来匹配模式，而不是过滤命令输出的临
				时文件名字。
				如果 <span class="Type">'shelltemp'</span> 关闭，不激活此事件。
							<span class="Ignore">*</span><span class="String">FocusGained</span><span class="Ignore">*</span>
FocusGained			Vim 取得输入焦点时。只有 GUI 和少数几个控制台
				版本能检测该事件。
							<span class="Ignore">*</span><span class="String">FocusLost</span><span class="Ignore">*</span>
FocusLost			Vim 失去输入焦点时。只有 GUI 和少数几个控制台
				版本能检测该事件。也有可能在弹出对话框时发生。
							<span class="Ignore">*</span><span class="String">FuncUndefined</span><span class="Ignore">*</span>
FuncUndefined			调用未定义的用户函数时。可以用来实现在实际调用
				时才提供动态定义的函数。模式匹配的是函数的名
				字。 <span class="Special">&lt;amatch&gt;</span> 和 <span class="Special">&lt;afile&gt;</span> 都被设为该函数的名
				字。
				注意: 写 Vim 脚本时，最好采用自动调入函数。
				见 <span class="Ignore">|</span><span class="Identifier">autoload-functions</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">GUIEnter</span><span class="Ignore">*</span>
GUIEnter			成功启动 GUI 并打开窗口后。用 gvim 的时候，
				它在 VimEnter 之前发生。在 .gvimrc 里可用它来
				定位窗口:<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd GUIEnter * winpos 100 50</span>
<span class="Ignore">&lt;</span>							<span class="Ignore">*</span><span class="String">GUIFailed</span><span class="Ignore">*</span>
GUIFailed			启动 GUI 失败后。如果可能，Vim 会继续在终端模
				式下运行 (仅当在 Unix 相容系统上连接 X 服务器
				失败后)。如果此时你想退出 Vim&#0058;<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd GUIFailed * qall</span>
<span class="Ignore">&lt;</span>							<span class="Ignore">*</span><span class="String">InsertChange</span><span class="Ignore">*</span>
InsertChange			在插入或替换模式下输入 <span class="Special">&lt;Insert&gt;</span> 时。
				<span class="Ignore">|</span><span class="Identifier">v:insertmode</span><span class="Ignore">|</span> 变量指明新模式。
				小心: 不要移动光标或做任何用户意想不到的事情。
							<span class="Ignore">*</span><span class="String">InsertCharPre</span><span class="Ignore">*</span>
InsertCharPre			插入模式输入每个字符前。
				<span class="Ignore">|</span><span class="Identifier">v:char</span><span class="Ignore">|</span> 变量指向正在输入的字符，事件处理时
				可以改变此变量，从而更改插入的字符。
				如果 <span class="Ignore">|</span><span class="Identifier">v:char</span><span class="Ignore">|</span> 被设为多于一个字符，按本义插入。
				文本锁激活时不能改变文本 <span class="Ignore">|</span><span class="Identifier">textlock</span><span class="Ignore">|</span>。
				<span class="Type">'paste'</span> 置位时不激活本事件。
							<span class="Ignore">*</span><span class="String">InsertEnter</span><span class="Ignore">*</span>
InsertEnter			刚开始插入模式之前。也适用于替换模式和虚拟替换
				模式。<span class="Ignore">|</span><span class="Identifier">v:insertmode</span><span class="Ignore">|</span> 变量指明该模式。
				小心: 不要做任何用户意想不到的事情。
				光标位置事后会恢复。如果不想如此，设置
				<span class="Ignore">|</span><span class="Identifier">v:char</span><span class="Ignore">|</span> 为某个非空的字符串。
							<span class="Ignore">*</span><span class="String">InsertLeave</span><span class="Ignore">*</span>
InsertLeave			离开插入模式时。也用于 <span class="Special">CTRL-O</span> <span class="Ignore">|</span><span class="Identifier">i_CTRL-O</span><span class="Ignore">|</span>，但不
				用于 <span class="Ignore">|</span><span class="Identifier">i_CTRL-C</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">MenuPopup</span><span class="Ignore">*</span>
MenuPopup			刚要显示弹出菜单前 (鼠标右键下)。用于根据光标
				或鼠标指针下的内容调整菜单。
				对应的模式匹配代表模式的单个字符:
					n	普通
					v	可视
					o	操作符等待
					i	插入
					c	命令行
							<span class="Ignore">*</span><span class="String">OptionSet</span><span class="Ignore">*</span>
OptionSet			设置选项时。模式匹配的是长选项名。
				<span class="Ignore">|</span><span class="Identifier">v:option_old</span><span class="Ignore">|</span> 变量给出旧选项值，
				<span class="Ignore">|</span><span class="Identifier">v:option_new</span><span class="Ignore">|</span> 变量给出新设选项值，
				<span class="Ignore">|</span><span class="Identifier">v:option_type</span><span class="Ignore">|</span> 变量说明是全局还是局部值，
				<span class="Special">&lt;amatch&gt;</span> 指出选项是否被置位。

				启动时不激活此事件，<span class="Type">'key'</span> 选项亦然。其理甚明。

				示例: 检查 <span class="Type">'backupdir'</span> 和 <span class="Type">'undodir'</span> 选项使用的
				目录是否存在，不存在时建立目录。

				注意: 在此自动命令里建议不要复位选项，可能会对
				插件破坏。用 <span class="Ignore">|</span><span class="Identifier">:noa</span><span class="Ignore">|</span> 可避免执行此自动命令。

							<span class="Ignore">*</span><span class="String">QuickFixCmdPre</span><span class="Ignore">*</span>
QuickFixCmdPre			开始执行 quickfix 命令前 (<span class="Ignore">|</span><span class="Identifier">:make</span><span class="Ignore">|</span>、 <span class="Ignore">|</span><span class="Identifier">:lmake</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:grep</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:lgrep</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:grepadd</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:lgrepadd</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:vimgrep</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:lvimgrep</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:vimgrepadd</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:lvimgrepadd</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cscope</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cfile</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:cgetfile</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:caddfile</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:lfile</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:lgetfile</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:laddfile</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:helpgrep</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:lhelpgrep</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cexpr</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cgetexpr</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:caddexpr</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cbuffer</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cgetbuffer</span><span class="Ignore">|</span>、
				<span class="Ignore">|</span><span class="Identifier">:caddbuffer</span><span class="Ignore">|</span>)。
				对应的模式匹配执行的命令。如果使用 <span class="Ignore">|</span><span class="Identifier">:grep</span><span class="Ignore">|</span> 但
				<span class="Type">'grepprg'</span> 设为 &quot;internal&quot;，仍然匹配 &quot;grep&quot;。
				该命令不能用于设置 <span class="Type">'makeprg'</span> 和 <span class="Type">'grepprg'</span> 变
				量。
				如果该命令出错，不执行 quickfix 命令。
							<span class="Ignore">*</span><span class="String">QuickFixCmdPost</span><span class="Ignore">*</span>
QuickFixCmdPost			类似于 QuickFixCmdPre，但在执行 quickfix 命令
				后，跳转到第一个位置之前。<span class="Ignore">|</span><span class="Identifier">:cfile</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:lfile</span><span class="Ignore">|</span>
				等命令则在读入错误文件后，跳转到第一个位置之前
				执行。
				见 <span class="Ignore">|</span><span class="Identifier">QuickFixCmdPost-example</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">QuitPre</span><span class="Ignore">*</span>
QuitPre				<span class="Ignore">`</span><span class="Comment">:quit</span><span class="Ignore">`</span>、<span class="Ignore">`</span><span class="Comment">:wq</span><span class="Ignore">`</span> 或 <span class="Ignore">`</span><span class="Comment">:qall</span><span class="Ignore">`</span> 调用时，在决定是否
				关闭当前窗口或退出 Vim 之前。可用于在当前窗口
				是最后一个普通窗口时关闭辅助的窗口。
							<span class="Ignore">*</span><span class="String">RemoteReply</span><span class="Ignore">*</span>
RemoteReply			Vim 作为服务器时收到应答时 <span class="Ignore">|</span><span class="Identifier">server2client()</span><span class="Ignore">|</span>。
				模式匹配的是 <span class="Special">{serverid}</span>。 <span class="Special">&lt;amatch&gt;</span> 是发出应答
				的机器的 <span class="Special">{serverid}</span>，而 <span class="Special">&lt;afile&gt;</span> 是实际的应答字
				符串。
				注意 即使定义了自动命令，还是要用
				<span class="Ignore">|</span><span class="Identifier">remote_read()</span><span class="Ignore">|</span> 来取走应答。
							<span class="Ignore">*</span><span class="String">SessionLoadPost</span><span class="Ignore">*</span>
SessionLoadPost			载入 <span class="Ignore">|</span><span class="Identifier">:mksession</span><span class="Ignore">|</span> 命令建立的会话文件后。
							<span class="Ignore">*</span><span class="String">ShellCmdPost</span><span class="Ignore">*</span>
ShellCmdPost			执行用 <span class="Ignore">|</span><span class="Identifier">:!cmd</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:shell</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:make</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:grep</span><span class="Ignore">|</span>
				指定的外壳命令后。可用于检查任何文件的改变。
							<span class="Ignore">*</span><span class="String">ShellFilterPost</span><span class="Ignore">*</span>
ShellFilterPost			执行用 &quot;:<span class="Special">{range}</span>!cmd&quot;、&quot;:w !cmd&quot; 或 &quot;:r !cmd&quot;
				指定的外壳命令后。可用于检查任何文件的改变。
							<span class="Ignore">*</span><span class="String">SourcePre</span><span class="Ignore">*</span>
SourcePre			执行 Vim 脚本前。<span class="Ignore">|</span><span class="Identifier">:source</span><span class="Ignore">|</span> <span class="Special">&lt;afile&gt;</span> 是待执行的
				文件名。
							<span class="Ignore">*</span><span class="String">SourceCmd</span><span class="Ignore">*</span>
SourceCmd			执行 Vim 脚本时。<span class="Ignore">|</span><span class="Identifier">:source</span><span class="Ignore">|</span> <span class="Special">&lt;afile&gt;</span> 是待执行的
				文件名。自动命令应实现执行该文件的操作。
				<span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>
							<span class="Ignore">*</span><span class="String">SpellFileMissing</span><span class="Ignore">*</span>
SpellFileMissing		试图载入拼写检查文件，但找不到该文件时。模式匹
				配的是语言名。 <span class="Special">&lt;amatch&gt;</span> 指定语言，和
				<span class="Type">'encoding'</span> 也有关。见
				<span class="Ignore">|</span><span class="Identifier">spell-SpellFileMissing</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">StdinReadPost</span><span class="Ignore">*</span>
StdinReadPost			从标准输入读取输入到缓冲区后，执行模式行前。仅
				用于 Vim 启动时使用了 &quot;-&quot; 参数时发生 <span class="Ignore">|</span><span class="Identifier">--</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">StdinReadPre</span><span class="Ignore">*</span>
StdinReadPre			从标准输入读取输入到缓冲区前。仅用于 Vim 启动
				时使用了 &quot;-&quot; 参数时发生 <span class="Ignore">|</span><span class="Identifier">--</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">SwapExists</span><span class="Ignore">*</span>
SwapExists			开始编辑文件时检测到交换文件已存在。只有此时，
				可以选择处理此情形的方法，也在此时，Vim 可能会
				询问用户应该如何做。
				<span class="Ignore">|</span><span class="Identifier">v:swapname</span><span class="Ignore">|</span> 变量保存找到的交换文件名。<span class="Special">&lt;afile&gt;</span>
				则是待编辑的文件。<span class="Ignore">|</span><span class="Identifier">v:swapcommand</span><span class="Ignore">|</span> 可以包含该文
				件打开后执行的命令。
				此事件的命令应该设置 <span class="Ignore">|</span><span class="Identifier">v:swapchoice</span><span class="Ignore">|</span> 变量为包含
				单字符的字符串，指示 Vim 下一步应该做什么:
					'o'	以只读方式打开
					'e'	仍然编辑文件
					'r'	恢复
					'd'	删除交换文件
					'q'	退出，不编辑文件
					'a'	中止，就像按了 <span class="Special">CTRL-C</span> 一样
				如果设为空串，则询问用户，就像没有 SwapExists
				自动命令那样。
							<span class="Ignore">*</span><span class="String">E812</span><span class="Ignore">*</span>
				此处不允许切换到其它缓冲区、为缓冲区换名或者更
				改目录。
							<span class="Ignore">*</span><span class="String">Syntax</span><span class="Ignore">*</span>
Syntax				设置 <span class="Type">'syntax'</span> 选项时。模式匹配的是语法名。
				<span class="Special">&lt;afile&gt;</span> 可以用来取得设置该选项的文件名，而
				<span class="Special">&lt;amatch&gt;</span> 则是 <span class="Type">'syntax'</span> 的新值。参见
				<span class="Ignore">|</span><span class="Identifier">:syn-on</span><span class="Ignore">|</span>。
							<span class="Ignore">*</span><span class="String">TabClosed</span><span class="Ignore">*</span>
TabClosed			关闭标签页后。
							<span class="Ignore">*</span><span class="String">TabEnter</span><span class="Ignore">*</span>
TabEnter			刚进入标签页后。<span class="Ignore">|</span><span class="Identifier">tab-page</span><span class="Ignore">|</span>
				在激活 WinEnter 事件之后和 BufEnter 事件之前发
				生。
							<span class="Ignore">*</span><span class="String">TabLeave</span><span class="Ignore">*</span>
TabLeave			刚要离开标签页前。<span class="Ignore">|</span><span class="Identifier">tab-page</span><span class="Ignore">|</span>
				WinLeave 事件在此之前已经激活。
							<span class="Ignore">*</span><span class="String">TabNew</span><span class="Ignore">*</span>
TabNew				创建标签页时。<span class="Ignore">|</span><span class="Identifier">tab-page</span><span class="Ignore">|</span>
				在此前，WinEnter 事件首先激活，TabEnter 其次。
							<span class="Ignore">*</span><span class="String">TermChanged</span><span class="Ignore">*</span>
TermChanged			<span class="Type">'term'</span> 的值发生改变后。可用来重新读入语法文
				件，更新色彩、字体和其他终端相关的设置。对所
				有已载入的缓冲区执行。
							<span class="Ignore">*</span><span class="String">TermResponse</span><span class="Ignore">*</span>
TermResponse			收到终端对 <span class="Ignore">|</span><span class="Identifier">t_RV</span><span class="Ignore">|</span> 的应答后。
				可用 <span class="Ignore">|</span><span class="Identifier">v:termresponse</span><span class="Ignore">|</span> 的值判别终端版本。
                                注意 本事件可能在另一事件执行半途中激发，特别
                                是在文件 I/O，shell 命令等耗时的操作进行时尤有
                                可能。
							<span class="Ignore">*</span><span class="String">TextChanged</span><span class="Ignore">*</span>
TextChanged			普通模式修改当前缓冲区文本之后。即
				<span class="Ignore">|</span><span class="Identifier">b:changedtick</span><span class="Ignore">|</span>  改变之时。
				有预输入或有操作符等待时不激活。
				小心: 本事件发生非常频繁，不要做任何用户意想不
				到或需时很久的事情。
							<span class="Ignore">*</span><span class="String">TextChangedI</span><span class="Ignore">*</span>
TextChangedI			插入模式修改当前缓冲区文本之后。
				弹出菜单可见时不激活。其他事项同 TextChanged。
							<span class="Ignore">*</span><span class="String">User</span><span class="Ignore">*</span>
User				不会自动执行。只有用 &quot;:doautocmd&quot; 执行自动命令
				时才会调用。
							<span class="Ignore">*</span><span class="String">UserGettingBored</span><span class="Ignore">*</span>
UserGettingBored		用户按同一个键 42 遍的时候。开玩笑的！
							<span class="Ignore">*</span><span class="String">VimEnter</span><span class="Ignore">*</span>
VimEnter			做完所有启动任务后，包括载入 .vimrc 文件，执行
				&quot;-c cmd&quot; 参数，创建所有的窗口并在其中载入所有
				缓冲区。
				在此事件激活之前，置位 <span class="Ignore">|</span><span class="Identifier">v:vim_did_enter</span><span class="Ignore">|</span> 变
				量，所以你可以做:<span class="Ignore"> &gt;</span>
<span class="Comment">				   if v:vim_did_enter</span>
<span class="Comment">				     call s:init()</span>
<span class="Comment">				   else</span>
<span class="Comment">				     au VimEnter * call s:init()</span>
<span class="Comment">				   endif</span>
<span class="Comment">							*VimLeave*</span>
VimLeave			退出 Vim 前，刚写入 .viminfo 文件之后。和
				VimLeavePre 一样，只执行一次。
				要检测非正常的退出，使用 <span class="Ignore">|</span><span class="Identifier">v:dying</span><span class="Ignore">|</span>。
				退出时如果 v:dying 至少为 2，不触发此事件。
							<span class="Ignore">*</span><span class="String">VimLeavePre</span><span class="Ignore">*</span>
VimLeavePre			退出 Vim 时刚写入 .viminfo 文件之前。如果匹配
				退出时当前缓冲区的名字匹配才会激活。只执行一
				次。通常指定 &quot;*&quot; 模式。<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd VimLeavePre * call CleanupStuff()</span>
<span class="Ignore">&lt;</span>				要检测非正常的退出，使用 <span class="Ignore">|</span><span class="Identifier">v:dying</span><span class="Ignore">|</span>。
				退出时如果 v:dying 至少为 2，不触发此事件。
							<span class="Ignore">*</span><span class="String">VimResized</span><span class="Ignore">*</span>
VimResized			在 Vim 窗口的大小改变后，因而 <span class="Type">'lines'</span> 和/或
				<span class="Type">'columns'</span> 也已随之改变。不过，启动时不用。
							<span class="Ignore">*</span><span class="String">WinEnter</span><span class="Ignore">*</span>
WinEnter			进入别的窗口后。不包括 Vim 启动时的第一个窗
				口。
				可用来设定窗口的高度。
				如果该窗口显示缓冲区，Vim 在 WinEnter 自动命令
				之后执行 BufEnter 自动命令。
				注意: &quot;:split fname&quot; 时，WinEnter 事件在分割之
				后但载入 &quot;fname&quot; 文件之前发生。
							<span class="Ignore">*</span><span class="String">WinLeave</span><span class="Ignore">*</span>
WinLeave			离开某窗口前。如果将要进入的窗口要显示的是别的
				缓冲区，Vim 在 WinLeave 自动命令前先执行
				BufLeave 自动命令 (但不包括 &quot;:new&quot;)。
				&quot;:qa&quot; 或 &quot;:q&quot; 退出 Vim 时不会激活此事件。
							<span class="Ignore">*</span><span class="String">WinNew</span><span class="Ignore">*</span>
WinNew				创建新窗口时。不用于 Vim 启动时的首个窗口。在
				WinEnter 事件之前激活。

<span class="PreProc">==============================================================================</span>
6. 模式						<span class="Ignore">*</span><span class="String">autocmd-patterns</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">{pat}</span><span class="Ignore">*</span>

<span class="Special">{pat}</span> 参数可以是逗号分隔的列表，相当于对每个模式分别给出该命令。因而:<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd BufRead *.txt,*.info set et</span>
等价于:<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd BufRead *.txt set et</span>
<span class="Comment">	:autocmd BufRead *.info set et</span>

文件模式 <span class="Special">{pat}</span> 用以下两种方式之一匹配文件名:
1. 如果模式里没有 '/'，只匹配文件名的尾部 (不包括它之前的目录路径)。
2. 如果模式里有 '/'，既匹配短本件名 (你输入的)，也匹配完整文件名 (扩展为完整路
   径并进行完符号链接的解析以后)。

特殊模式 <span class="Special">&lt;buffer&gt;</span> 或 &lt;buffer=<span class="Special">N</span>&gt; 用于局部于缓冲区的自动命令
<span class="Ignore">|</span><span class="Identifier">autocmd-buflocal</span><span class="Ignore">|</span>。该模式不是用来匹配缓冲区的名字的。

例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd BufRead *.txt		set et</span>
为所有的文本文件置位 <span class="Type">'et'</span> 选项。<span class="Ignore"> &gt;</span>

<span class="Comment">	:autocmd BufRead /vim/src/*.c	set cindent</span>
为所有 /vim/src 目录下的 C 文件置位 <span class="Type">'cindent'</span> 选项。<span class="Ignore"> &gt;</span>

<span class="Comment">	:autocmd BufRead /tmp/*.c	set ts=5</span>
如果你有一个从 &quot;/tmp/test.c&quot; 到 &quot;/home/nobody/src/test.c&quot; 的链接并且开始编辑
&quot;/tmp/test.c&quot;，该自动命令会匹配。

注意: 要匹配部分路径而不从根目录开始指定，第一个字符用 '*'。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd BufRead */doc/*.txt	set tw=78</span>
该自动命令会在例如 &quot;/tmp/doc/xx.txt&quot; 和 &quot;/usr/home/piet/doc/yy.txt&quot; 上执行。目
录的层次此处无关紧要。


模式匹配的是通配符扩展后的文件名。这样:<span class="Ignore"> &gt;</span>
<span class="Comment">	:e $ROOTDIR/main.$EXT</span>
的参数会在匹配自动命令模式前先被扩展成:<span class="Ignore"> &gt;</span>
<span class="Comment">	/usr/root/main.py</span>
小心 FileReadCmd 这样的事件使用的 <span class="Special">&lt;amatch&gt;</span> 的值未必如你所料。


模式里可以指定环境变量:<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab</span>
而 ~ 也可以指定主目录 (如果定义了 $HOME):<span class="Ignore"> &gt;</span>
<span class="Comment">	:autocmd BufWritePost ~/.vimrc   so ~/.vimrc</span>
<span class="Comment">	:autocmd BufRead ~archive/*      set readonly</span>
在自动命令的定义时扩展环境变量，而不是在执行时进行。这和命令的处理不同！

							<span class="Ignore">*</span><span class="String">file-pattern</span><span class="Ignore">*</span>
这里，模式的解释和文件名里的模式大致相同:
	*	匹配任何字符序列
	?	匹配任何单个字符；特别的是，也包括路径分隔符
	\?	匹配 '?'
	.	匹配 '.'
	~	匹配 '~'
	,	分隔模式
	\,	匹配 ','
	{ }	类似于 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span> 里的 \( \)
	,	在 { } 里: 类似于 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span> 里的 \|
	\}	本义的 }
	\{	本义的 {
	\\\{n,m\}  类似于 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span> 里的 \<span class="Special">{n,m}</span>
	\	类似于 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span> 里的特殊含义
	<span class="Special">[ch]</span>	匹配 'c' 或 'h'
	<span class="Special">[^ch]</span>   匹配除了 'c' 和 'h' 的任何字符

注意 在任何系统上，'/' 字符都被用作路径分隔符 (即使 MS-DOS 和 OS/2 也是如此)。
如此做是因为反斜杠在模式里很难使用，而且也为了自动命令能在不同系统间可以相互移
植。

可以使用普通模式的项目，但请见上述的特定转译，可能和你的预期有所落差。

							<span class="Ignore">*</span><span class="String">autocmd-changes</span><span class="Ignore">*</span>
模式的匹配是在事件激活时进行的。即使某个自动命令改变了缓冲区名字甚至删除了缓冲
区，也不会改变执行的是哪个自动命令。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">	au BufEnter *.foo  bdel</span>
<span class="Comment">	au BufEnter *.foo  set modified</span>

会删除当前缓冲区，并置位取代当前缓冲区的新缓冲区的 <span class="Type">'modified'</span> 标志。Vim 不管
&quot;*.foo&quot; 此时已经不匹配该缓冲区名字。&quot;*.foo&quot; 在该事件被激活时匹配当时的缓冲区名
字。

不过，局部于缓冲区的自动命令在用 <span class="Ignore">|</span><span class="Identifier">:bwipe</span><span class="Ignore">|</span> 彻底删除的缓冲区上不会执行。如果 用
<span class="Ignore">|</span><span class="Identifier">:bdel</span><span class="Ignore">|</span> 删除缓冲区，该缓冲区其实还是存在的 (它只是不被列出)，因而这些自动命令
还会执行。

<span class="PreProc">==============================================================================</span>
7. 局部于缓冲区的自动命令	<span class="Ignore">*</span><span class="String">autocmd-buflocal</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">autocmd-buffer-local</span><span class="Ignore">*</span>
					<span class="Ignore">*</span><span class="String">&lt;buffer=N&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">&lt;buffer=abuf&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E680</span><span class="Ignore">*</span>

局部于缓冲区的自动命令和特定缓冲区相联系。它们可用于没有名字或者名字不匹配特定
模式的缓冲区。但这也意味着必须为每个缓冲区显式地加入这些自动命令。

局部于缓冲区的自动命令不用模式，而用如下的形式:
	<span class="Special">&lt;buffer&gt;</span>	当前缓冲区
	&lt;buffer=99&gt;	缓冲区号 99
	&lt;buffer=abuf&gt;	用 <span class="Special">&lt;abuf&gt;</span> (只当执行自动命令时适用) <span class="Ignore">|</span><span class="Identifier">&lt;abuf&gt;</span><span class="Ignore">|</span>

示例:<span class="Ignore"> &gt;</span>
<span class="Comment">    :au CursorHold &lt;buffer&gt;  echo 'hold'</span>
<span class="Comment">    :au CursorHold &lt;buffer=33&gt;  echo 'hold'</span>
<span class="Comment">    :au BufNewFile * au CursorHold &lt;buffer=abuf&gt;  echo 'hold'</span>

所有自动命令的命令都可用于局部于缓冲区的自动命令，只要简单地用这些特殊字符串来
替代模式就行了。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">    :au! * &lt;buffer&gt;		     &quot; 删除当前缓冲区的局部于缓冲区的自动命令</span>
<span class="Comment">    :au! * &lt;buffer=33&gt;		     &quot; 删除缓冲区 #33 的局部于缓冲区的自动命令</span>
<span class="Comment">    :bufdo :au! CursorHold &lt;buffer&gt;  &quot; 删除所有缓冲区里给定事件的自动命令</span>
<span class="Comment">    :au * &lt;buffer&gt;		     &quot; 列出当前缓冲区的局部于缓冲区的自动命令</span>
<span class="Ignore">&lt;</span>
注意 如果为当前缓冲区定义自动命令，保存时记住的是它的缓冲区号。这里用的形式是
&quot;&lt;buffer=12&gt;&quot;，其中 12 是当前缓冲区的编号。例如，列出自动命令时你看到的就是这
种形式。

要测试局部于缓冲区的自动命令是否存在，用 <span class="Ignore">|</span><span class="Identifier">exists()</span><span class="Ignore">|</span> 函数:<span class="Ignore"> &gt;</span>
<span class="Comment">    :if exists(&quot;#CursorHold#&lt;buffer=12&gt;&quot;) | ... | endif</span>
<span class="Comment">    :if exists(&quot;#CursorHold#&lt;buffer&gt;&quot;) | ... | endif    &quot; 指定当前缓冲区</span>

如果缓冲区被彻底删除，其局部于缓冲区的自动命令当然也没有了。注意 缓冲区如果被
删除，比如用 &quot;:bdel&quot;，它只是不被列出而已，其自动命令还是存在的。要观察局部于缓
冲区的自动命令的删除情况:<span class="Ignore"> &gt;</span>
<span class="Comment">    :set verbose=6</span>

不能为还不存在的缓冲区定义局部于缓冲区的自动命令。

<span class="PreProc">==============================================================================</span>
8. 组							<span class="Ignore">*</span><span class="String">autocmd-groups</span><span class="Ignore">*</span>

自动命令可以被一起放在一个组里。这可用于删除或者执行一组自动命令。例如，所有有
关语法高亮的自动命令被放在 &quot;highlight&quot; 组里，这样在 GUI 启动时可以一并执行
&quot;:doautoall highlight BufRead&quot;。

如果没有指定特殊的组名，Vim 使用缺省组。缺省组没有名字。你不能单独执行缺省组的
所有自动命令；只有在执行所有组里的自动命令时才会执行它们。

正常情况下，在自动执行自动命令时，Vim 使用所有组的自动命令。组只有在用
&quot;:doautocmd&quot; 或 &quot;:doautoall&quot; 执行自动命令或者在定义或删除自动命令时才用的上。

组名可以包含任何非空白字符。但组名 &quot;end&quot; 保留 (包括大写形式)。

组名是区分大小写的。注意 这和事件名不同！

							<span class="Ignore">*</span><span class="String">:aug</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:augroup</span><span class="Ignore">*</span>
:aug[roup] <span class="Special">{name}</span>		定义其后的 &quot;:autocmd&quot; 命令使用的自动命令组名。
				名字 &quot;end&quot; 或者 &quot;END&quot; 选择缺省组。
				为了避免混淆，此处不要用和已有 <span class="Special">{event}</span> 名重名
				的名字，很可能和你想做的不同。

					<span class="Ignore">*</span><span class="String">:augroup-delete</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E367</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">W19</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E936</span><span class="Ignore">*</span>
:aug[roup]! <span class="Special">{name}</span>		删除自动命令组 <span class="Special">{name}</span>。如果还有自动命令使用该
				组，不要这么做！不然，系统会警告你。而且如果该
				组是当前组，会报错 E936。

要为某个组输入自动命令，使用如下方法:
1. 用 &quot;:augroup <span class="Special">{name}</span>&quot; 选择组。
2. 用 &quot;:au!&quot; 删除所有旧的自动命令。
3. 定义自动命令。
4. 用 &quot;augroup END&quot; 回到缺省组。

例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:augroup uncompress</span>
<span class="Comment">	:  au!</span>
<span class="Comment">	:  au BufEnter *.gz	%!gunzip</span>
<span class="Comment">	:augroup END</span>

这样可以防止自动命令被多次定义 (例如，再次执行 .vimrc 文件)。

<span class="PreProc">==============================================================================</span>
9. 执行自动命令					<span class="Ignore">*</span><span class="String">autocmd-execute</span><span class="Ignore">*</span>

Vim 也可以非自动地执行自动命令。如果你修改了自动命令或者 Vim 执行了不正确的自
动命令 (例如文件模式的匹配不正确)，这也许会有用。

注意 <span class="Type">'eventignore'</span> 选项也适用于此。不会为该选项列出的事件执行任何命令。

					<span class="Ignore">*</span><span class="String">:do</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:doau</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:doautocmd</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E217</span><span class="Ignore">*</span>
:do[autocmd] [<span class="Special">&lt;nomodeline&gt;</span>] <span class="Special">[group]</span> <span class="Special">{event}</span> <span class="Special">[fname]</span>
			应用匹配 <span class="Special">[fname]</span> (缺省是当前文件名) 和针对当前缓冲区的
			<span class="Special">{event}</span> 事件的自动命令。如果当前文件不匹配正确的模式，
			修改完设置，或者想手动执行某一特定的事件的自动命令的时
			候，都可以使用该命令。
			自动命令中也可以使用，这样你可以用基于一个扩展名的自动
			命令来应用于另一个扩展名。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:au BufEnter *.cpp so ~/.vimrc_cpp</span>
<span class="Comment">				:au BufEnter *.cpp doau BufEnter x.c</span>
<span class="Ignore">&lt;</span>			要小心避免死循环，参见 <span class="Ignore">|</span><span class="Identifier">autocmd-nested</span><span class="Ignore">|</span>。

			如果没有给出 <span class="Special">[group]</span> 参数，Vim 执行所有组里的自动命
			令。如果给出 <span class="Special">[group]</span> 参数，Vim 只执行该组里匹配的自动
			命令。注意: 如果你使用未定义的组名，Vim 会报错。

							<span class="Ignore">*</span><span class="String">&lt;nomodeline&gt;</span><span class="Ignore">*</span>
			应用完自动命令后，会执行模式行。其中的设置可以否决自动
			命令里的设置，一如编辑文件时那样。给出 <span class="Special">&lt;nomodeline&gt;</span> 参
			数时，跳过这一步骤。对那些不用于缓冲区载入时的事件，如
			<span class="Ignore">|</span><span class="Identifier">User</span><span class="Ignore">|</span>，这一参数较为有用。
			如果没有匹配的自动命令可执行，也不会处理模式行。

						<span class="Ignore">*</span><span class="String">:doautoa</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:doautoall</span><span class="Ignore">*</span>
:doautoa[ll] [<span class="Special">&lt;nomodeline&gt;</span>] <span class="Special">[group]</span> <span class="Special">{event}</span> <span class="Special">[fname]</span>
			类似于 &quot;:doautocmd&quot;，但对每个已载入的缓冲区应用自动命
			令。注意 <span class="Special">[fname]</span> 用于选择自动命令，而不是其应用的缓冲
			区。
			要小心: 不要用这个命令执行删除缓冲区、切换到别的缓冲区
			或者修改缓冲区内容的自动命令；否则结果不可预测。该命令
			是设计用来执行类似于设置选项、修改高亮等任务的自动命令
			的。

<span class="PreProc">==============================================================================</span>
10. 自动命令的使用					<span class="Ignore">*</span><span class="String">autocmd-use</span><span class="Ignore">*</span>

对于文件的_写入_，有四组可能的事件。Vim 对一个写入命令只会执行其中的一组:

BufWriteCmd	BufWritePre	BufWritePost	写回整个缓冲区
		FilterWritePre	FilterWritePost	写入过滤程序的临时文件
FileAppendCmd	FileAppendPre	FileAppendPost	附加到文件
FileWriteCmd	FileWritePre	FileWritePost	其他的文件写入

如果定义了 &quot;*Cmd&quot; 自动命令，它应该完成相应写入的操作。因而，其他的写入操作不会
进行，其他的事件也不会被激活。 <span class="Ignore">|</span><span class="Identifier">Cmd-event</span><span class="Ignore">|</span>

注意 *WritePost 命令应该撤销 *WritePre 命令对缓冲区所做的任何改动；否则，文件
的写入会有不应该有的修改缓冲区的副作用。

开始执行自动命令前，写入的行所在的缓冲区暂时成为当前缓冲区。除非自动命令修改了
当前缓冲区或者删除了先前的那个当前缓冲区，先前的那个又会重新成为当前的。

*WritePre 和 *AppendPre 自动命令不能删除写入的行所在的那个缓冲区。

'[ 和 '] 位置标记有特殊的位置:
- 在 *ReadPre 事件之前， '[ 标记设为新行将要插入的位置上方的那行。
- 在 *ReadPost 事件之前，'[ 标记设为新读入的内容的第一行，'] 则为其最后一行。
- 开始执行 *WriteCmd、*WritePre 和 *AppendPre 自动命令前，'[ 标记设为要写入的
  内容的第一行，'] 则为其最后一行。
小心: '[ 和 '] 指定的位置在使用修改缓冲区的命令时会改变。

在期待文件名的命令里，你可以使用 &quot;<span class="Special">&lt;afile&gt;</span>&quot; 指定被读入的文件名 <span class="Ignore">|</span><span class="Identifier">:&lt;afile&gt;</span><span class="Ignore">|</span> (你可
以用 &quot;%&quot; 指定当前文件名)。&quot;<span class="Special">&lt;abuf&gt;</span>&quot; 指定当前有效的缓冲区的缓冲区号。它可以用
于没有名字的缓冲区，但不包括没有缓冲区的文件 (例如，用 &quot;:r file&quot;)。

							<span class="Ignore">*</span><span class="String">gzip-example</span><span class="Ignore">*</span>
读写压缩文件的示例:<span class="Ignore"> &gt;</span>
<span class="Comment">  :augroup gzip</span>
<span class="Comment">  :  autocmd!</span>
<span class="Comment">  :  autocmd BufReadPre,FileReadPre	*.gz set bin</span>
<span class="Comment">  :  autocmd BufReadPost,FileReadPost	*.gz '[,']!gunzip</span>
<span class="Comment">  :  autocmd BufReadPost,FileReadPost	*.gz set nobin</span>
<span class="Comment">  :  autocmd BufReadPost,FileReadPost	*.gz execute &quot;:doautocmd BufReadPost &quot; . expand(&quot;%:r&quot;)</span>
<span class="Comment">  :  autocmd BufWritePost,FileWritePost	*.gz !mv &lt;afile&gt; &lt;afile&gt;:r</span>
<span class="Comment">  :  autocmd BufWritePost,FileWritePost	*.gz !gzip &lt;afile&gt;:r</span>

<span class="Comment">  :  autocmd FileAppendPre		*.gz !gunzip &lt;afile&gt;</span>
<span class="Comment">  :  autocmd FileAppendPre		*.gz !mv &lt;afile&gt;:r &lt;afile&gt;</span>
<span class="Comment">  :  autocmd FileAppendPost		*.gz !mv &lt;afile&gt; &lt;afile&gt;:r</span>
<span class="Comment">  :  autocmd FileAppendPost		*.gz !gzip &lt;afile&gt;:r</span>
<span class="Comment">  :augroup END</span>

我们用 &quot;gzip&quot; 组执行 &quot;:autocmd!&quot;，从而能在脚本文件被执行两次时，删除已经定义的
自动命令。

(&quot;<span class="Special">&lt;afile&gt;</span>:r&quot; 是去掉扩展名的文件名，参见 <span class="Ignore">|</span><span class="Identifier">:_%:</span><span class="Ignore">|</span>)

BufNewFile、BufRead/BufReadPost、BufWritePost、FileAppendPost 和 VimLeave 事件
执行的自动命令不置位或复位缓冲区的修改标志。当你用 BufReadPost 自动命令解压缓
冲区时，你还可以用 &quot;:q&quot; 直接退出。当你在 BufWritePost 里用 &quot;:undo&quot; 撤销
BufWritePre 命令所做的改变时，你也可以用 &quot;:q&quot; (所以，也可以用 &quot;ZZ&quot;)。如果你想
使缓冲区设为修改过的，置位 <span class="Type">'modified'</span> 选项。

要在自动命令里执行普通模式的命令，用 &quot;:normal&quot; 命令。要小心: 如果普通模式命令
没能结束，用户需要键入字符 (例如，&quot;:normal m&quot; 之后需要输入一个位置标记名)。

如果你在缓冲区修改后想使之成为未修改状态，复位 <span class="Type">'modified'</span> 选项。这使得用 &quot;:q&quot;
退出缓冲区 (而不用 &quot;:q!&quot;) 成为可能。

							<span class="Ignore">*</span><span class="String">autocmd-nested</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">E218</span><span class="Ignore">*</span>
自动命令缺省不会嵌套。如果你在自动命令里用 &quot;:e&quot; 或者 &quot;:w&quot;，Vim 不会执行这些命
令相应的 BufRead 和 BufWrite 自动命令。如果你需要这么做，在需要嵌套的命令的定
义里加上 &quot;nested&quot; 标志位。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">  :autocmd FileChangedShell *.c nested e!</span>
为了防止递归循环，嵌套限定为 10 层。

自动命令里可以用 &quot;:au&quot; 命令。甚至可以用来实现自我修改的命令。这适用于只执行一
次的自动命令。

要想为单个命令跳过自动命令，使用 <span class="Ignore">|</span><span class="Identifier">:noautocmd</span><span class="Ignore">|</span> 命令修饰符，或者 <span class="Type">'eventignore'</span>
选项。

注意: 读入文件时 (用 &quot;:read file&quot; 或者过滤命令)，如果文件的最后一行没有换行符
<span class="Special">&lt;EOL&gt;</span>，Vim 记住这一点。下一次写 (用 &quot;:write file&quot; 或者过滤命令) 的时候，如果最
后一行不变_而且_置位了 <span class="Type">'binary'</span>，Vim 不会自己提供 <span class="Special">&lt;EOL&gt;</span>。这使得在刚读入的行上
的过滤命令写入相同的文件时写的内容和读入的完全一致，也使得在刚过滤过的行上的写
入命令写入相同文件时写的和从过滤程序读取的完全相同。例如，另一个写压缩文件的方
法是:<span class="Ignore"> &gt;</span>

<span class="Comment">  :autocmd FileWritePre *.gz   set bin|'[,']!gzip</span>
<span class="Comment">  :autocmd FileWritePost *.gz  undo|set nobin</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">autocommand-pattern</span><span class="Ignore">*</span>
你可以指定逗号分隔的多个模式。以下是一些示例。<span class="Ignore"> &gt;</span>

<span class="Comment">  :autocmd BufRead   *		set tw=79 nocin ic infercase fo=2croq</span>
<span class="Comment">  :autocmd BufRead   .letter	set tw=72 fo=2tcrq</span>
<span class="Comment">  :autocmd BufEnter  .letter	set dict=/usr/lib/dict/words</span>
<span class="Comment">  :autocmd BufLeave  .letter	set dict=</span>
<span class="Comment">  :autocmd BufRead,BufNewFile   *.c,*.h	set tw=0 cin noic</span>
<span class="Comment">  :autocmd BufEnter  *.c,*.h	abbr FOR for (i = 0; i &lt; 3; ++i)&lt;CR&gt;{&lt;CR&gt;}&lt;Esc&gt;O</span>
<span class="Comment">  :autocmd BufLeave  *.c,*.h	unabbr FOR</span>

要指定 makefiles (makefile、Makefile、imakefile、makefile.unix 等等):<span class="Ignore"> &gt;</span>

<span class="Comment">  :autocmd BufEnter  ?akefile*	set include=^s\=include</span>
<span class="Comment">  :autocmd BufLeave  ?akefile*	set include&amp;</span>

要使得 C 程序的编辑从第一个函数开始:<span class="Ignore"> &gt;</span>

<span class="Comment">  :autocmd BufRead   *.c,*.h	1;/^{</span>

上面如果没有 &quot;1;&quot;，搜索会从文件进入的位置开始，而不是文件的开始处。

						<span class="Ignore">*</span><span class="String">skeleton</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">template</span><span class="Ignore">*</span>
要开始编辑新文件时读入一个骨架 (样板) 文件:<span class="Ignore"> &gt;</span>

<span class="Comment">  :autocmd BufNewFile  *.c	0r ~/vim/skeleton.c</span>
<span class="Comment">  :autocmd BufNewFile  *.h	0r ~/vim/skeleton.h</span>
<span class="Comment">  :autocmd BufNewFile  *.java	0r ~/vim/skeleton.java</span>

要在写入一个 *.html 文件时插入当前日期和时间:<span class="Ignore"> &gt;</span>

<span class="Comment">  :autocmd BufWritePre,FileWritePre *.html   ks|call LastMod()|'s</span>
<span class="Comment">  :fun LastMod()</span>
<span class="Comment">  :  if line(&quot;$&quot;) &gt; 20</span>
<span class="Comment">  :    let l = 20</span>
<span class="Comment">  :  else</span>
<span class="Comment">  :    let l = line(&quot;$&quot;)</span>
<span class="Comment">  :  endif</span>
<span class="Comment">  :  exe &quot;1,&quot; . l . &quot;g/Last modified: /s/Last modified: .*/Last modified: &quot; .</span>
<span class="Comment">  :  \ strftime(&quot;%Y %b %d&quot;)</span>
<span class="Comment">  :endfun</span>

要这段代码工作，你需要在文件开始的 20 行里有这行 &quot;Last modified: &lt;date
time&gt;&quot;。 Vim 把 &lt;date time&gt; (包括该行其后的任何内容) 替换为当前的日期和时间。
解释:
	ks		保存当前位置到 's' 标记
	call LastMod()  调用 LastMod() 函数完成工作
	's		光标回到旧的位置
LastMode() 函数先检查文件是否少于 20 行，然后用 &quot;:g&quot; 命令查找包含 &quot;Last
Modified:&quot; 的行。在这些行上执行 &quot;:s&quot; 命令实现从已有的时间到当前时间的替换。
&quot;:execute&quot; 命令使 &quot;:g&quot; 和 &quot;:s&quot; 命令可以使用表达式。日期用 strftime() 函数取
得。它可以用别的参数取得不同格式的日期字符串。

在命令行上输入 :autocmd 的时候，事件和命令名字在可能的情况可以用 <span class="Special">&lt;Tab&gt;</span>，<span class="Special">CTRL-D</span>
等进行自动补全。

Vim 根据你定义的顺序执行所有匹配的自动命令。建议第一个自动命令使用 &quot;*&quot; 作为文
件模式，从而使之适用于所有文件。这意味着你可以在这里设定任何选项的缺省值，如果
有别的匹配的自动命令，可以把这些缺省值覆盖。但如果没有，至少你的缺省设置得到保
证 (如果从另一个能够匹配自动命令的文件进入这个文件)。注意 &quot;*&quot; 也会匹配以 &quot;.&quot;
开始的文件，这一点和 Unix 外壳不同。

						    <span class="Ignore">*</span><span class="String">autocmd-searchpat</span><span class="Ignore">*</span>
自动命令不会改变当前的搜索模式。Vim 在执行自动命令前保存当前的搜索模式，在完成
后恢复之。这意味着自动命令不会影响 <span class="Type">'hlsearch'</span> 选项指定的高亮字符串。自动命令里
你可以正常的使用模式搜索。例如，用 &quot;n&quot; 命令。如果你想要自动命令设置在命令完成
后仍然可用的搜索模式，用 &quot;:let @/ =&quot; 命令。自动命令里不能用 &quot;:nohlsearch&quot; 关闭
高亮部分。不过，在启动 Vim 的时候，可以用 <span class="Type">'viminfo'</span> 选项里的 'h' 标志位关闭搜
索高亮功能。

							<span class="Ignore">*</span><span class="String">Cmd-event</span><span class="Ignore">*</span>
在使用 &quot;*Cmd&quot; 事件之一时，匹配的自动命令应该负责执行文件读取、写入或脚本执行操
作。这可以用以操作特殊的文件，例如在远程文件系统上。
小心: 如果你不正确使用这些事件，造成的效果是你无法读写匹配的文件！确保你小心的
测试过这些自动命令。最好使用的是不会匹配正常文件的模式，例如 &quot;ftp://*&quot;。

定义 BufReadCmd 以后，Vim 很难从崩溃的编辑会话恢复。从原始文件恢复的时候，Vim
只会读取交换文件里不存在的部分。因为这用 BufReadCmd 不可能做到，用 <span class="Ignore">|</span><span class="Identifier">:preserve</span><span class="Ignore">|</span>
可以保证恢复的时候不需要原始的文件。应该只有在文件被修改的时候你才想这么做。

对于文件读写命令，<span class="Ignore">|</span><span class="Identifier">v:cmdarg</span><span class="Ignore">|</span> 变量保存当前有效的 &quot;++enc=&quot; 和 &quot;++ff=&quot; 参数。在读
写文件的命令里应该用到这些参数。用 &quot;!&quot; 后缀时，<span class="Ignore">|</span><span class="Identifier">v:cmdbang</span><span class="Ignore">|</span> 参数为 1，不然其为
0。

示例参见 $VIMRUNTIME/plugin/netrwPlugin.vim。

<span class="PreProc">==============================================================================</span>
11. 屏蔽自动命令					<span class="Ignore">*</span><span class="String">autocmd-disable</span><span class="Ignore">*</span>

要在一段时间里屏蔽自动命令，使用 <span class="Type">'eventignore'</span> 选项。注意 这可能会导致意料不到
的效果。确信在此之后恢复 <span class="Type">'eventignore'</span>，可用带 <span class="Ignore">|</span><span class="Identifier">:finally</span><span class="Ignore">|</span> 的 <span class="Ignore">|</span><span class="Identifier">:try</span><span class="Ignore">|</span> 块。

							<span class="Ignore">*</span><span class="String">:noautocmd</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:noa</span><span class="Ignore">*</span>
要为单个命令屏蔽自动命令，使用 &quot;:noautocmd&quot; 命令修饰符。它会在下一个命令的执行
期间把 <span class="Type">'eventignore'</span> 设为 &quot;all&quot;。例如:<span class="Ignore"> &gt;</span>

<span class="Comment">	:noautocmd w fname.gz</span>

这样，可以写入文件而不激活 gzip 插件定义的自动命令。


 vim&#0058;tw=78:ts=8:ft=help:norl:
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
