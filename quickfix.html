<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>vim中文手册 - quickfix</title>
    <meta name="description" content="vim8.0 中文帮助文档">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="vim.css" type="text/css">
</head>
<body>
    <div class="page-content">
        <article class="wrap">
            <pre class="pre">
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span id="quickfix.txt" class="String anchor">quickfix.txt</span><span class="Ignore">*</span>  For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2017年8月

		  VIM 参考手册    by Bram Moolenaar

		  译者: wandys、Willis	<span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>

本主题曾在用户手册的 <span class="Ignore">|</span><a href="usr_30.html#30.1"><span class="Identifier">30.1</span></a><span class="Ignore">|</span> 节有所介绍。

1. 使用 QuickFix 命令			<span class="Ignore">|</span><a href="quickfix.html#quickfix"><span class="Identifier">quickfix</span></a><span class="Ignore">|</span>
2. 出错窗口				<span class="Ignore">|</span><a href="quickfix.html#quickfix-window"><span class="Identifier">quickfix-window</span></a><span class="Ignore">|</span>
3. 使用多个错误列表			<span class="Ignore">|</span><a href="quickfix.html#quickfix-error-lists"><span class="Identifier">quickfix-error-lists</span></a><span class="Ignore">|</span>
4. 使用 :make				<span class="Ignore">|</span><span class="Identifier">:make_makeprg</span><span class="Ignore">|</span>
5. 使用 :grep				<span class="Ignore">|</span><a href="quickfix.html#grep"><span class="Identifier">grep</span></a><span class="Ignore">|</span>
6. 选择编译器				<span class="Ignore">|</span><a href="quickfix.html#compiler-select"><span class="Identifier">compiler-select</span></a><span class="Ignore">|</span>
7. 错误格式				<span class="Ignore">|</span><a href="quickfix.html#error-file-format"><span class="Identifier">error-file-format</span></a><span class="Ignore">|</span>
8. 目录栈				<span class="Ignore">|</span><a href="quickfix.html#quickfix-directory-stack"><span class="Identifier">quickfix-directory-stack</span></a><span class="Ignore">|</span>
9. 特定错误格式				<span class="Ignore">|</span><a href="quickfix.html#errorformats"><span class="Identifier">errorformats</span></a><span class="Ignore">|</span>

<span class="Special">{Vi 没有这些命令}</span>

如编译时没有指定 <span class="Ignore">|</span><span class="Identifier">+quickfix</span><span class="Ignore">|</span> 则无法使用 quickfix 相关命令。

<span class="PreProc">=============================================================================</span>
1. 使用 QuickFix 命令			<span class="Ignore">*</span><span id="quickfix" class="String anchor">quickfix</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="Quickfix" class="String anchor">Quickfix</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E42" class="String anchor">E42</span><span class="Ignore">*</span>

Vim 有一个特殊的模式用来加快 编辑-编译-编辑 循环。这是受到 Amiga 系统上 Manx
的 Aztec C 编译器的 quickfix 选项的启发。它会将编译器产生的出错信息保存到一个
文件中并用 Vim 跳转到各个错误。无需记住所有的出错信息，你可以检查每一个错误并
对其修正。

Vim 里，quickfix 命令的使用更广泛，它可以找到文件各种位置的列表。例如，
<span class="Ignore">|</span><span class="Identifier">:vimgrep</span><span class="Ignore">|</span> 寻找模式的匹配。在脚本里，用 <span class="Ignore">|</span><a href="#"><span class="Identifier">getqflist()</span></a><span class="Ignore">|</span> 函数可以得到这些位置。这
样你可以比编辑/编译/修正循环做更多的事情！

如果有保存在文件里的出错信息，这样启动 Vim&#0058;<span class="Ignore"> &gt;</span>
<span class="Comment">	vim -q filename</span>

从 Vim 里，一个简便的运行命令并处理输出的方法是使用 <span class="Ignore">|</span><span class="Identifier">:make</span><span class="Ignore">|</span> 命令 (见下)。

你需要设定 <span class="Type">'errorformat'</span>，使其和编译器产生的出错信息格式一致 (见
<span class="Ignore">|</span><a href="quickfix.html#errorformat"><span class="Identifier">errorformat</span></a><span class="Ignore">|</span>)。

						<span class="Ignore">*</span><span id="location-list" class="String anchor">location-list</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E776" class="String anchor">E776</span><span class="Ignore">*</span>
位置列表是一个窗口局部的 quickfix 列表。由 <span class="Ignore">`</span><span class="Comment">:lvimgrep</span><span class="Ignore">`</span>、<span class="Ignore">`</span><span class="Comment">:lgrep</span><span class="Ignore">`</span>、
<span class="Ignore">`</span><span class="Comment">:lhelpgrep</span><span class="Ignore">`</span>、<span class="Ignore">`</span><span class="Comment">:lmake</span><span class="Ignore">`</span> 等命令产生，它们生成位置列表而不是对应的 <span class="Ignore">`</span><span class="Comment">:vimgrep</span><span class="Ignore">`</span>、
<span class="Ignore">`</span><span class="Comment">:grep</span><span class="Ignore">`</span>、 <span class="Ignore">`</span><span class="Comment">:helpgrep</span><span class="Ignore">`</span>、<span class="Ignore">`</span><span class="Comment">:make</span><span class="Ignore">`</span> 生成的 quickfix 列表。
位置列表和窗口相关联，而每个窗口都要单独的位置列表。一个位置列表只能和一个窗口
相关联。位置列表和 quickfix 列表相互独立。

如果包含位置列表的窗口被分割，新窗口得到该位置列表的一个备份。如果一个位置列表
不再被引用，该位置列表被删除。

以下 quickfix 命令可供使用。位置列表命令和 quickfix 命令类似，把 quickfix 命令
里的 'c' 前缀换成 'l' 就行了。

							<span class="Ignore">*</span><span id="E924" class="String anchor">E924</span><span class="Ignore">*</span>
如果 <span class="Ignore">|</span><a href="autocmd.html#autocommand"><span class="Identifier">autocommand</span></a><span class="Ignore">|</span> 关闭当前窗口的同时正在处理位置列表命令，中止该命令。

							<span class="Ignore">*</span><span id="E925" class="String anchor">E925</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E926" class="String anchor">E926</span><span class="Ignore">*</span>
如果 <span class="Ignore">|</span><a href="autocmd.html#autocommand"><span class="Identifier">autocommand</span></a><span class="Ignore">|</span> 改变当前 quickfix 或位置列表的同时正在处理 quickfix 或位置
列表命令，中止该命令。

							<span class="Ignore">*</span><span class="String">:cc</span><span class="Ignore">*</span>
:cc[!] <span class="Special">[nr]</span>		显示错误 <span class="Special">[nr]</span>。如果不指定 <span class="Special">[nr]</span>，将再次显示相同的错误。
			如果不指定 [!]，则以下情况发生时无法跳转到另一个缓冲
			区: 若 <span class="Type">'hidden'</span> 和 <span class="Type">'autowrite'</span> 选项没被设定并且当前缓
			冲区只有一个窗口且被修改。
			当指定 [!] 跳转到另一个缓冲区时，当前缓冲区的修改会丢
			失，除非设定了 <span class="Type">'hidden'</span> 或该缓冲区还有其它窗口。
			当跳转到另一个缓冲区时，会受到 <span class="Type">'switchbuf'</span> 有关设定的
			影响。

							<span class="Ignore">*</span><span class="String">:ll</span><span class="Ignore">*</span>
:ll[!] <span class="Special">[nr]</span>		和 &quot;:cc&quot; 类似，但使用当前窗口的位置列表而不是 quickfix
			列表。

							<span class="Ignore">*</span><span class="String">:cn</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cnext</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E553" class="String anchor">E553</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>cn[ext][!]d	显示含有文件名的列表中的往后第 <span class="Special">[count]</span> 个错误。如果没
			有文件名，则跳转到往后第 <span class="Special">[count]</span> 个错误。有关 [!] 和
			<span class="Type">'switchbuf'</span>，参见 <span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:lne</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lnext</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>lne[xt][!]	和 &quot;:cnext&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

:<span class="Special">[count]</span>cN[ext][!]			<span class="Ignore">*</span><span class="String">:cp</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cprevious</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cN</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cNext</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>cp[revious][!]	显示含有文件名的列表中的往前第 <span class="Special">[count]</span> 个错误。如果没
			有文件名，则跳转到往前第 <span class="Special">[count]</span> 个错误。有关 [!] 和
			<span class="Type">'switchbuf'</span>，参见 <span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

:<span class="Special">[count]</span>lN[ext][!]			<span class="Ignore">*</span><span class="String">:lp</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lprevious</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lN</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lNext</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>lp[revious][!]	和 &quot;:cNext&quot; 与 &quot;:cprevious&quot; 类似，但使用当前窗口的位置
			列表而不是 quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cnf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cnfile</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>cnf[ile][!]	显示含有文件名的列表中往后第 <span class="Special">[count]</span> 个文件中的首个错
			误。如果没有文件名或是列表中没有下一个文件，则跳转到往
			后第 <span class="Special">[count]</span> 个错误。有关 [!] 和 <span class="Type">'switchbuf'</span>，参见
			<span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:lnf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lnfile</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>lnf[ile][!]	和 &quot;:cnfile&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

:<span class="Special">[count]</span>cNf[ile][!]			<span class="Ignore">*</span><span class="String">:cpf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cpfile</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cNf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cNfile</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>cpf[ile][!]	显示含有文件名的列表中往前第 <span class="Special">[count]</span> 个文件中的最后一
			个错误。如果没有文件名或是列表中没有下一个文件，则跳转
			到往前第 <span class="Special">[count]</span> 个错误。有关 [!] 和 <span class="Type">'switchbuf'</span>，参见
			<span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

:<span class="Special">[count]</span>lNf[ile][!]			<span class="Ignore">*</span><span class="String">:lpf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lpfile</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lNf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lNfile</span><span class="Ignore">*</span>
:<span class="Special">[count]</span>lpf[ile][!]	和 &quot;:cNfile&quot; 与 &quot;:cpfile&quot; 类似，但使用当前窗口的位置列
			表而不是 quickfix 列表。

							<span class="Ignore">*</span><span class="String">:crewind</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cr</span><span class="Ignore">*</span>
:cr[ewind][!] <span class="Special">[nr]</span>	显示错误 <span class="Special">[nr]</span>。如果没指定 <span class="Special">[nr]</span>，则显示_首_个错误。参见
			<span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:lrewind</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lr</span><span class="Ignore">*</span>
:lr[ewind][!] <span class="Special">[nr]</span>	和 &quot;:crewind&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cfirst</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cfir</span><span class="Ignore">*</span>
:cfir[st][!] <span class="Special">[nr]</span>	和 &quot;:crewind&quot; 相同。

							<span class="Ignore">*</span><span class="String">:lfirst</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lfir</span><span class="Ignore">*</span>
:lfir[st][!] <span class="Special">[nr]</span>	和 &quot;:lrewind&quot; 相同。

							<span class="Ignore">*</span><span class="String">:clast</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cla</span><span class="Ignore">*</span>
:cla[st][!] <span class="Special">[nr]</span>	显示错误 <span class="Special">[nr]</span>。如果没指定 <span class="Special">[nr]</span>，则显示最后一个错误。参
			见 <span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:llast</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lla</span><span class="Ignore">*</span>
:lla[st][!] <span class="Special">[nr]</span>	和 &quot;:clast&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cq</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cquit</span><span class="Ignore">*</span>
:cq[uit][!]		以错误码退出 Vim。这样编译器就不会再次编译相同文件。
			_警告_: 对文件的所有改动都会丢失！即使没有 [!] 也是如
			此。类似于 &quot;:qall!&quot; <span class="Ignore">|</span><span class="Identifier">:qall</span><span class="Ignore">|</span>，但 Vim 返回非零退出码。

							<span class="Ignore">*</span><span class="String">:cf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cfile</span><span class="Ignore">*</span>
:cf[ile][!] <span class="Special">[errorfile]</span>	读入错误文件并跳转到首个错误。以 -q 选项启动 Vim 时会
			自动这样处理。用这个命令，你就可以在编译的同时继续用
			Vim 编辑。如果你指定错误文件名，那么 <span class="Type">'errorfile'</span> 选择
			将被设定为 <span class="Special">[errorfile]</span>。有关 [!]，参见 <span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。
			如果错误文件的编码和 <span class="Type">'encoding'</span> 选项不同，可用
			<span class="Type">'makeencoding'</span> 选项来指定编码。

							<span class="Ignore">*</span><span class="String">:lf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lfile</span><span class="Ignore">*</span>
:lf[ile][!] <span class="Special">[errorfile]</span>	和 &quot;:cfile&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。
			你不能用 -q 命令行选项设置位置列表。

:cg[etfile] <span class="Special">[errorfile]</span>					<span class="Ignore">*</span><span class="String">:cg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cgetfile</span><span class="Ignore">*</span>
			读入错误文件。和 &quot;:cfile&quot; 类似，只是不跳转到首个错误。
			如果错误文件的编码和 <span class="Type">'encoding'</span> 选项不同，可用
			<span class="Type">'makeencoding'</span> 选项来指定编码。

:lg[etfile] <span class="Special">[errorfile]</span>					<span class="Ignore">*</span><span class="String">:lg</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lgetfile</span><span class="Ignore">*</span>
			和 &quot;:cgetfile&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:caddf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:caddfile</span><span class="Ignore">*</span>
:caddf[ile] <span class="Special">[errorfile]</span>	读入错误文件，把错误文件里的错误加到当前 quickfix 列表
			中。如果 quickfix 列表不存在，建立新的列表。
			如果错误文件的编码和 <span class="Type">'encoding'</span> 选项不同，可用
			<span class="Type">'makeencoding'</span> 选项来指定编码。

							<span class="Ignore">*</span><span class="String">:laddf</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:laddfile</span><span class="Ignore">*</span>
:laddf[ile] <span class="Special">[errorfile]</span>	和 &quot;:caddfile&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

						<span class="Ignore">*</span><span class="String">:cb</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cbuffer</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E681" class="String anchor">E681</span><span class="Ignore">*</span>
:cb[uffer][!] <span class="Special">[bufnr]</span>	从当前缓冲区读入错误列表。如果给出 <span class="Special">{bufnr}</span>，它必须是已
			经载入的缓冲区号。这时使用该缓冲区，而不是当前缓冲区。
			可以指定使用的行范围。否则使用缓冲区的所有行。
			[!] 部分见 <span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span class="String">:lb</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lbuffer</span><span class="Ignore">*</span>
:lb[uffer][!] <span class="Special">[bufnr]</span>	和 &quot;:cbuffer&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

						<span class="Ignore">*</span><span class="String">:cgetb</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cgetbuffer</span><span class="Ignore">*</span>
:cgetb[uffer] <span class="Special">[bufnr]</span>	从当前缓冲区读入错误列表。类似于 &quot;:cbuffer&quot;，只是不跳
			转到首个错误。

						<span class="Ignore">*</span><span class="String">:lgetb</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lgetbuffer</span><span class="Ignore">*</span>
:lgetb[uffer] <span class="Special">[bufnr]</span>	和 &quot;:cgetbuffer&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cad</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:caddbuffer</span><span class="Ignore">*</span>
:cad[dbuffer] <span class="Special">[bufnr]</span>	读入当前缓冲区的错误列表，把这些错误加到当前 quickfix
			列表中。如果 quickfix 列表不存在，建立新的列表。其它部
			分和 &quot;:cbuffer&quot; 相同。

							<span class="Ignore">*</span><span class="String">:laddb</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:laddbuffer</span><span class="Ignore">*</span>
:laddb[uffer] <span class="Special">[bufnr]</span>	和 &quot;:caddbuffer&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cex</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cexpr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E777" class="String anchor">E777</span><span class="Ignore">*</span>
:cex[pr][!] <span class="Special">{expr}</span>	用 <span class="Special">{expr}</span> 的计算结果建立 quickfix 列表并跳转到首个错
			误。
			如果 <span class="Special">{expr}</span> 是字符串，那么字符串里每个换行符结尾的
			行用全局值 <span class="Type">'errorformat'</span> 进行处理，其结果用来产生
			quickfix 列表。
			如果 <span class="Special">{expr}</span> 是列表类型，那么列表里的每个字符串项目被处
			理并加到 quickfix 列表里。列表里的非字符串项目被忽略。
			[!] 部分见 <span class="Ignore">|</span><span class="Identifier">:cc</span><span class="Ignore">|</span>。
			示例:<span class="Ignore"> &gt;</span>
<span class="Comment">				:cexpr system('grep -n xyz *')</span>
<span class="Comment">				:cexpr getline(1, '$')</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">:lex</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lexpr</span><span class="Ignore">*</span>
:lex[pr][!] <span class="Special">{expr}</span>	和 <span class="Ignore">|</span><span class="Identifier">:cexpr</span><span class="Ignore">|</span> 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cgete</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cgetexpr</span><span class="Ignore">*</span>
:cgete[xpr] <span class="Special">{expr}</span>	用 <span class="Special">{expr}</span> 的计算结果建立 quickfix 列表。和 <span class="Ignore">|</span><span class="Identifier">:cexpr</span><span class="Ignore">|</span> 类
			似，只是不跳转到首个错误。

							<span class="Ignore">*</span><span class="String">:lgete</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lgetexpr</span><span class="Ignore">*</span>
:lgete[xpr] <span class="Special">{expr}</span>	和 <span class="Ignore">|</span><span class="Identifier">:cgetexpr</span><span class="Ignore">|</span> 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cadde</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:caddexpr</span><span class="Ignore">*</span>
:cadde[xpr] <span class="Special">{expr}</span>	把 <span class="Special">{expr}</span> 的计算结果行加到当前 quickfix 列表中。如果
			quickfix 列表不存在，建立新的列表。不改变当前的光标位
			置。详情见 <span class="Ignore">|</span><span class="Identifier">:cexpr</span><span class="Ignore">|</span>。
			示例:<span class="Ignore"> &gt;</span>
<span class="Comment">    :g/mypattern/caddexpr expand(&quot;%&quot;) . &quot;:&quot; . line(&quot;.&quot;) .  &quot;:&quot; . getline(&quot;.&quot;)</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">:lad</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:laddexpr</span><span class="Ignore">*</span>
:lad[dexpr] <span class="Special">{expr}</span>	和 &quot;:caddexpr&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:clist</span><span class="Ignore">*</span>
:cl[ist] <span class="Special">[from]</span> [, <span class="Special">[to]</span>]
			显示所有有效的错误 (参见 <span class="Ignore">|</span><a href="quickfix.html#quickfix-valid"><span class="Identifier">quickfix-valid</span></a><span class="Ignore">|</span>)。
			如果 <span class="Special">[from]</span> 和/或 <span class="Special">[to]</span> 被指定，则显示指定范围内的错
			误。负数从最后一个错误向前算起，-1 为最后一个错误。当
			跳转到另一个缓冲区时，会受到 <span class="Type">'switchbuf'</span> 有关设定的影
			响。

:cl[ist] +<span class="Special">{count}</span>	列出当前和下面 <span class="Special">{count}</span> 个有效的错误。类似于 &quot;:clist
			from from+count&quot;，这里 &quot;from&quot; 是当前的错误位置。

:cl[ist]! <span class="Special">[from]</span> [, <span class="Special">[to]</span>]
			显示所有的错误。

:cl[ist]! +<span class="Special">{count}</span>	列出当前和下面 <span class="Special">{count}</span> 个错误行。可用于看见当前行后未
			识别的行。例如，如果 &quot;:clist&quot; 给出:
        <span class="PreProc">8384 testje.java:252: error: cannot find symbol</span><span class="Ignore"> ~</span>
                        然后，用 &quot;:cl! +3&quot; 显示原因:
        <span class="PreProc">8384 testje.java:252: error: cannot find symbol</span><span class="Ignore"> ~</span>
        <span class="PreProc">8385:   ZexitCode = Fmainx();</span><span class="Ignore"> ~</span>
        <span class="PreProc">8386:               ^</span><span class="Ignore"> ~</span>
        <span class="PreProc">8387:   symbol:   method Fmainx()</span><span class="Ignore"> ~</span>

:lli[st] <span class="Special">[from]</span> [, <span class="Special">[to]</span>]				<span class="Ignore">*</span><span class="String">:lli</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:llist</span><span class="Ignore">*</span>
			和 &quot;:clist&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

:lli[st]! <span class="Special">[from]</span> [, <span class="Special">[to]</span>]
			列出当前窗口的位置列表的所有项目。

如果你插入或删除行，大部分错误仍能被正确的找到，因为隐藏标记会被使用。有时，当
标记由于某种原因被删除，&quot;line changed&quot; 信息会显示以警告你出错位置可能有误。如
果你退出并重新运行 Vim，标记会丢失，而出错位置也可能不再正确。

如果 vim 内建 <span class="Ignore">|</span><span class="Identifier">+autocmd</span><span class="Ignore">|</span> 支持，可以在 quickfix 命令 (':make'、':grep' 等) 执行
前后使用两个自动命令。详见 <span class="Ignore">|</span><a href="autocmd.html#QuickFixCmdPre"><span class="Identifier">QuickFixCmdPre</span></a><span class="Ignore">|</span> 和 <span class="Ignore">|</span><a href="autocmd.html#QuickFixCmdPost"><span class="Identifier">QuickFixCmdPost</span></a><span class="Ignore">|</span>。

						<span class="Ignore">*</span><span id="QuickFixCmdPost-example" class="String anchor">QuickFixCmdPost-example</span><span class="Ignore">*</span>
如果 <span class="Type">'encoding'</span> 不同于 locale，错误信息可能和 Vim 使用的编码不同。以下代码可以
进行消息的转换:<span class="Ignore"> &gt;</span>
<span class="Comment">	function QfMakeConv()</span>
<span class="Comment">	   let qflist = getqflist()</span>
<span class="Comment">	   for i in qflist</span>
<span class="Comment">	      let i.text = iconv(i.text, &quot;cp936&quot;, &quot;utf-8&quot;)</span>
<span class="Comment">	   endfor</span>
<span class="Comment">	   call setqflist(qflist)</span>
<span class="Comment">	endfunction</span>

<span class="Comment">	au QuickfixCmdPost make call QfMakeConv()</span>
另一个选项是用 <span class="Type">'makeencoding'</span>。

在 所 有 QUICKFIX 或 位 置 列 表 的 缓 冲 区 中 执 行 一 个 命 令:
							<span class="Ignore">*</span><span class="String">:cdo</span><span class="Ignore">*</span>
:cdo[!] <span class="Special">{cmd}</span>		在 quickfix 列表的每个有效的项目上执行 <span class="Special">{cmd}</span>。
			工作方式相当于:<span class="Ignore"> &gt;</span>
<span class="Comment">				:cfirst</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				:cnext</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				等等</span>
<span class="Ignore">&lt;</span>			如果当前文件不能 <span class="Ignore">|</span><a href="editing.html#abandon"><span class="Identifier">abandon</span></a><span class="Ignore">|</span> 且没给出 [!] 时，命令失败。
			检测到错误时，执行中止。
			最后一个缓冲区 (或错误发生所在的那个) 成为当前缓冲区。
			<span class="Special">{cmd}</span> 可包含 '|' 以连接几个命令。

			只使用 quickfix 列表里的有效的项目。可使用范围来选择项
			目，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:10,$cdo cmd</span>
<span class="Ignore">&lt;</span>			来跳过 1-9 个项目。

			备注: 此命令执行时，把它加到 <span class="Type">'eventignore'</span> 以关闭语法
			自动命令事件。这样显著地提高了缓冲区编辑的速度。
			<span class="Special">{Vi 无此功能}</span> {仅当编译时指定 <span class="Ignore">|</span><span class="Identifier">+listcmds</span><span class="Ignore">|</span> 特性才有效}
			另见 <span class="Ignore">|</span><span class="Identifier">:bufdo</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:tabdo</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:argdo</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:windo</span><span class="Ignore">|</span>、
			<span class="Ignore">|</span><span class="Identifier">:ldo</span><span class="Ignore">|</span>、<span class="Ignore">|</span><span class="Identifier">:cfdo</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">:lfdo</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">:cfdo</span><span class="Ignore">*</span>
:cfdo[!] <span class="Special">{cmd}</span>		在 quickfix 列表的每个文件上执行 <span class="Special">{cmd}</span>。
			工作方式相当于:<span class="Ignore"> &gt;</span>
<span class="Comment">				:cfirst</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				:cnfile</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				等等</span>
<span class="Ignore">&lt;</span>			此外，和 <span class="Ignore">`</span><span class="Comment">:cdo</span><span class="Ignore">`</span> 相同。
			<span class="Special">{Vi 无此功能}</span> {仅当编译时指定 <span class="Ignore">|</span><span class="Identifier">+listcmds</span><span class="Ignore">|</span> 特性才有效}

							<span class="Ignore">*</span><span class="String">:ldo</span><span class="Ignore">*</span>
:ld[o][!] <span class="Special">{cmd}</span>		在当前窗口位置列表的每个有效的项目上执行 <span class="Special">{cmd}</span>。
			工作方式相当于:<span class="Ignore"> &gt;</span>
<span class="Comment">				:lfirst</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				:lnext</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				etc.</span>
<span class="Ignore">&lt;</span>			只使用位置列表里的有效的项目，此外，和 <span class="Ignore">`</span><span class="Comment">:cdo</span><span class="Ignore">`</span> 相同。
			<span class="Special">{Vi 无此功能}</span> {仅当编译时指定 <span class="Ignore">|</span><span class="Identifier">+listcmds</span><span class="Ignore">|</span> 特性才有效}

							<span class="Ignore">*</span><span class="String">:lfdo</span><span class="Ignore">*</span>
:lfdo[!] <span class="Special">{cmd}</span>		在当前窗口位置列表的每个文件上执行 <span class="Special">{cmd}</span>。
			工作方式相当于:<span class="Ignore"> &gt;</span>
<span class="Comment">				:lfirst</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				:lnfile</span>
<span class="Comment">				:{cmd}</span>
<span class="Comment">				etc.</span>
<span class="Ignore">&lt;</span>			此外，和 <span class="Ignore">`</span><span class="Comment">:ldo</span><span class="Ignore">`</span> 相同。
			<span class="Special">{Vi 无此功能}</span> {仅当编译时指定 <span class="Ignore">|</span><span class="Identifier">+listcmds</span><span class="Ignore">|</span> 特性才有效}

<span class="PreProc">=============================================================================</span>
2. 出错窗口					<span class="Ignore">*</span><span id="quickfix-window" class="String anchor">quickfix-window</span><span class="Ignore">*</span>

					    <span class="Ignore">*</span><span class="String">:cope</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:copen</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">w:quickfix_title</span><span class="Ignore">*</span>
:cope[n] <span class="Special">[height]</span>	打开一个窗口显示当前的错误列表。

			如果指定 <span class="Special">[height]</span>，窗口设为指定高度 (如果有空间的话)，
			如果省略 <span class="Special">[height]</span>，窗口为 10 行高。

			如果已有了一个 quickfix 窗口，它将成为当前窗口。不可能
			再打开第二个 quickfix 窗口。如果指定 <span class="Special">[height]</span>，用来调
			整己有的窗口的大小。

			该窗口含有一个特殊的缓冲区，<span class="Type">'buftype'</span> 为 &quot;quickfix&quot;。
			不要修改此选项！该窗口会设置 w:quickfix_title 变量为生
			成 quickfix 列表的命令。可用于通过适当地调整
			<span class="Type">'statusline'</span> 来定制状态行。

							<span class="Ignore">*</span><span class="String">:lop</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lopen</span><span class="Ignore">*</span>
:lop[en] <span class="Special">[height]</span>	打开一个窗口显示当前窗口的位置列表。只有当前窗口有位置
			列表的情况才能用。你可以同时打开多于一个的位置列表窗
			口。除此以外，和 &quot;:copen&quot; 相同。

							<span class="Ignore">*</span><span class="String">:ccl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cclose</span><span class="Ignore">*</span>
:ccl[ose]		关闭 quickfix 窗口。

							<span class="Ignore">*</span><span class="String">:lcl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lclose</span><span class="Ignore">*</span>
:lcl[ose]		关闭显示当前窗口的位置列表的窗口。

							<span class="Ignore">*</span><span class="String">:cw</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cwindow</span><span class="Ignore">*</span>
:cw[indow] <span class="Special">[height]</span>	当存在可以识别的错误时，打开窗口。如果该窗口已经打开且
			没有可识别的错误，则将此窗口关闭。

							<span class="Ignore">*</span><span class="String">:lw</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lwindow</span><span class="Ignore">*</span>
:lw[indow] <span class="Special">[height]</span>	和 &quot;:cwindow&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:cbo</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cbottom</span><span class="Ignore">*</span>
:cbo[ttom]		光标放在 quickfix 窗口的末行并滚动使其可见。可用于异步
			地加入错误。如果有很多更新，不要太频繁调用此命令，以避
			免过多的重画。

							<span class="Ignore">*</span><span class="String">:lbo</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lbottom</span><span class="Ignore">*</span>
:lbo[ttom]		同 &quot;:cbottom&quot;，但使用当前窗口的位置列表。

quickfix 窗口一般会在屏幕的底端。如果有垂直分割，它会在最右边窗口的底端。
要使其获得最大宽度:<span class="Ignore"> &gt;</span>
<span class="Comment">	:botright cwindow</span>
你可以用 <span class="Ignore">|</span><a href="windows.html#window-moving"><span class="Identifier">window-moving</span></a><span class="Ignore">|</span> 命令来移动窗口。
比如，将它移动到顶端: <span class="Special">CTRL-W</span> K
<span class="Type">'winfixheight'</span> 选项会被设定，也就是说窗口会尽可能的保持它原来的高度，而忽略
<span class="Type">'winheight'</span> 和 <span class="Type">'equalalways'</span> 选项。你可以手动改变其高度 (例如，用鼠标拖动它上
方的状态行)。

在 quickfix 窗口中，每一行是一个错误。行号和错误号相等。用 QuickFixLine 高亮来
高亮当前项目。可以按你喜欢的改变，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:hi QuickFixLine ctermbg=Yellow guibg=Yellow</span>

你可以用 &quot;:.cc&quot; 跳转到当前光标处的错误。
按 <span class="Special">&lt;Enter&gt;</span> 键或是双击鼠标有同样的效果。在 quickfix 窗口上方会开一窗口显示含有
错误的文件。如果已有为该文件打开的窗口，则使用该窗口。如果已打开窗口的缓冲区已
被修改，而错误出在另一个文件中，则不能完成向出错处的跳转。你需要首先确定窗口含
有一个可被放弃的缓冲区。
					<span class="Ignore">*</span><span class="String">CTRL-W_&lt;Enter&gt;</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">CTRL-W_&lt;CR&gt;</span><span class="Ignore">*</span>
你可以用 <span class="Special">CTRL-W</span> <span class="Special">&lt;Enter&gt;</span> 来打开新窗口并在那里跳转到错误。

当 quickfix 窗口被填充后，将会触发两个自动命令事件。首先，<span class="Type">'filetype'</span> 选项会被
设为 &quot;qf&quot;，这会触发 FileType 事件。然后 BufReadPost 事件会被触发，缓冲区名为
&quot;quickfix&quot;。这可以用来完成一些在错误列表上的操作。比如:<span class="Ignore"> &gt;</span>
<span class="Comment">	au BufReadPost quickfix  setlocal modifiable</span>
<span class="Comment">		\ | silent exe 'g/^/s//\=line(&quot;.&quot;).&quot; &quot;/'</span>
<span class="Comment">		\ | setlocal nomodifiable</span>
这会在每行开始添加行号。注意 &quot;:s&quot; 命令中 &quot;\=&quot; 的使用，它是为了计算表达式。
同时激活 BufWinEnter 事件，还是用 &quot;quickfix&quot; 作为缓冲区名。

注意: 加入到已有的 quickfix 列表时，不激活自动命令。

备注: 在 quickfix 窗口中作更改对出错列表不起作用。<span class="Type">'modifiable'</span> 选项关闭以免作
出更改。如果你坚持还是要删除或是插入行，文本和错误号的关系就会混乱。如果真的想
这么做，你可以将 quickfix 窗口的内容保存到一个文件中然后用 &quot;:cfile&quot; 命令将其解
析并指定其作为新的错误列表。

						<span class="Ignore">*</span><span id="location-list-window" class="String anchor">location-list-window</span><span class="Ignore">*</span>
位置列表窗口显示位置列表里的项目。如果打开位置列表窗口，它建立在当前窗口之下，
并显示当前窗口的位置列表。位置列表窗口和 quickfix 窗口类似，除了你可以同时打开
多于一个位置列表窗口以外。如果你在这个窗口里使用位置列表命令，使用的是其中显示
的位置列表。

当你从位置列表窗口里选择文件时，采用下面的步骤以寻找编辑该文件的窗口:

1. 如果该位置列表窗口显示的位置列表所属的窗口存在，用该窗口打开文件。
2. 如果上面的步骤失败并且文件已经在另外的窗口里打开，使用那个窗口。
3. 如果上面的步骤失败，使用已经存在且显示的缓冲区没有置位 <span class="Type">'buftype'</span> 的窗口。
4. 如果上面的步骤失败，用新窗口编辑文件。

在所有这些情形下，如果选择窗口的位置列表还没有设置，那么它被设置为位置列表窗口
里显示的位置列表。

<span class="PreProc">=============================================================================</span>
3. 使用多个错误列表					<span class="Ignore">*</span><span id="quickfix-error-lists" class="String anchor">quickfix-error-lists</span><span class="Ignore">*</span>

到目前为止，我们都假定只有一个错误列表。实际上最近使用的 10 个错误列表都会被记
住。当开始一个新的列表时，前面的列表会被自动保存。有两个命令可以用来访问旧的错
误列表。它们会将其中一个已经使用的错误列表指定为当前列表。

						<span class="Ignore">*</span><span class="String">:colder</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:col</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E380" class="String anchor">E380</span><span class="Ignore">*</span>
:col[der] <span class="Special">[count]</span>	到前一个旧的错误列表。如果指定 <span class="Special">[count]</span>，则执行 <span class="Special">[count]</span>
			次。如果已经到达最旧的列表，则报错。

						<span class="Ignore">*</span><span class="String">:lolder</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lol</span><span class="Ignore">*</span>
:lol[der] <span class="Special">[count]</span>	和 <span class="Ignore">`</span><span class="Comment">:colder</span><span class="Ignore">`</span> 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

						<span class="Ignore">*</span><span class="String">:cnewer</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:cnew</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E381" class="String anchor">E381</span><span class="Ignore">*</span>
:cnew[er] <span class="Special">[count]</span>	到下一个新的错误列表。如果指定 <span class="Special">[count]</span>，则执行 <span class="Special">[count]</span>
			次。如果已经到达最新的列表，则报错。

						<span class="Ignore">*</span><span class="String">:lnewer</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lnew</span><span class="Ignore">*</span>
:lnew[er] <span class="Special">[count]</span>	和 <span class="Ignore">`</span><span class="Comment">:cnewer</span><span class="Ignore">`</span> 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

						<span class="Ignore">*</span><span class="String">:chistory</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:chi</span><span class="Ignore">*</span>
:chi[story]		显示错误列表的列表。当前列表以 ”&gt;&quot; 标记。结果类似于:
				  <span class="PreProc">error list 1 of 3; 43 errors</span><span class="Ignore"> ~</span>
				<span class="PreProc">&gt; error list 2 of 3; 0 errors</span><span class="Ignore"> ~</span>
				  <span class="PreProc">error list 3 of 3; 15 errors</span><span class="Ignore"> ~</span>

						<span class="Ignore">*</span><span class="String">:lhistory</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lhi</span><span class="Ignore">*</span>
:lhi[story]		显示位置列表的列表，此外类似于 <span class="Ignore">`</span><span class="Comment">:chistory</span><span class="Ignore">`</span>。

当增加一个新的错误列表时，它会成为当前列表。

如果使用 &quot;:colder&quot; 后又使用 &quot;:make&quot; 或 &quot;:grep&quot; 来增加一个错误列表，那么原来的
一个较新列表会被覆盖。这在使用 &quot;:grep&quot; (见 <span class="Ignore">|</span><a href="quickfix.html#grep"><span class="Identifier">grep</span></a><span class="Ignore">|</span>) 时相当有用。如果你想保留最
近的错误列表，先要使用 &quot;:cnewer 99&quot; 命令。

<span class="PreProc">=============================================================================</span>
4. 使用 :make						<span class="Ignore">*</span><span class="String">:make_makeprg</span><span class="Ignore">*</span>

							<span class="Ignore">*</span><span class="String">:mak</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:make</span><span class="Ignore">*</span>
:mak[e][!] <span class="Special">[arguments]</span>	1. 如果 Vim 编译时带 <span class="Ignore">|</span><span class="Identifier">+autocmd</span><span class="Ignore">|</span>，执行所有相关的
			   <span class="Ignore">|</span><a href="autocmd.html#QuickFixCmdPre"><span class="Identifier">QuickFixCmdPre</span></a><span class="Ignore">|</span> 自动命令。
			2. 如果设定 <span class="Type">'autowrite'</span>，则写入所有修改过的缓冲区。
			3. 根据 <span class="Type">'makeef'</span> 的值产生错误文件。如果 <span class="Type">'makeef'</span> 值不
			   包含 &quot;##&quot; 且此文件已存在，则该文件会被先删除。
			4. <span class="Type">'makeprg'</span> 选项指定的程序 (缺省为 &quot;make&quot;) 被启动，
			   <span class="Special">[arguments]</span> 为其参数。其输出被储存到错误文件名 (如
			   是 Unix，也会在屏幕上显示)。
			5. 错误文件以 <span class="Type">'errorformat'</span> 格式读入。
			6. 如果 Vim 编译时带 <span class="Ignore">|</span><span class="Identifier">+autocmd</span><span class="Ignore">|</span>，执行所有相关的
			   <span class="Ignore">|</span><a href="autocmd.html#QuickFixCmdPost"><span class="Identifier">QuickFixCmdPost</span></a><span class="Ignore">|</span> 自动命令。
			   见下例。
			7. 如果没指定 [!]，则跳转到首个错误。
			8. 错误文件被删除。
			9. 你现在可以用 <span class="Ignore">|</span><span class="Identifier">:cnext</span><span class="Ignore">|</span>，<span class="Ignore">|</span><span class="Identifier">:cprevious</span><span class="Ignore">|</span> 等命令在错误间
			   移动。见上。
			本命令不接受注释，所有的 &quot; 将被视为参数的一部分。
			如果错误文件的编码和 <span class="Type">'encoding'</span> 选项不同，可用
			<span class="Type">'makeencoding'</span> 选项来指定编码。

							<span class="Ignore">*</span><span class="String">:lmak</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lmake</span><span class="Ignore">*</span>
:lmak[e][!] <span class="Special">[arguments]</span>
			和 &quot;:make&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

&quot;:make&quot; 命令执行 <span class="Type">'makeprg'</span> 选项指定的程序。这会通过将命令传递给 <span class="Type">'shell'</span> 指定的
shell 完成。基本就像输入下面的命令一样:

	&quot;:!<span class="Special">{makeprg}</span> <span class="Special">[arguments]</span> <span class="Special">{shellpipe}</span> <span class="Special">{errorfile}</span>&quot;。

<span class="Special">{makeprg}</span> 是 <span class="Type">'makeprg'</span> 选项指定的一个字符串。并非只是 &quot;make&quot;，所有的命令都可被
使用。'%' 和 '#' 会像在命令行中一样被展开。你可以用 &quot;%&lt;&quot; 表示不含扩展名的当前
文件名，用 &quot;#&lt;&quot; 表示不含扩展名的轮换文件名。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :set makeprg=make\ #&lt;.o</span>

<span class="Special">[arguments]</span> 为 &quot;:make&quot; 之后输入的所有字符。
<span class="Special">{shellpipe}</span> 是 <span class="Type">'shellpipe'</span> 选项值。
<span class="Special">{errorfile}</span> 是 <span class="Type">'makeef'</span> 选项值 (## 会被一个唯一字符串取代)。

在设定 <span class="Special">{makeprg}</span> 时，占位符 &quot;$*&quot; 可用来指代 <span class="Special">[arguments]</span>，这样就可以在这些参数
之后加上其它字符。这时，$* 被所有参数取代。比如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}</span>
或更简单些:<span class="Ignore"> &gt;</span>
<span class="Comment">   :let &amp;mp = 'latex \\nonstopmode \\input\{$*}'</span>
&quot;$*&quot; 可被使用多次:<span class="Ignore"> &gt;</span>
<span class="Comment">   :set makeprg=gcc\ -o\ $*\ $*</span>

<span class="Type">'shellpipe'</span> 在 Amiga、MS-DOS 以及 Win32 系统上缺省为 &quot;&gt;&quot;。这就是说编译器的输出
会保存在一个文件中而不在屏幕中直接显示。在 Unix 系统上，会用到 &quot;| tee&quot;。输出在
被保存在文件中的同时也会显示在屏幕上。取决于所使用的 shell，&quot;|&amp; tee&quot; 或是
&quot;2&gt;&amp;1| tee&quot; 为缺省值，这样 stderr 输出也被包括。

如果 <span class="Type">'shellpipe'</span> 为空，<span class="Special">{errorfile}</span> 将被忽略。这对那些自身将输出写入文件的编译
器很有用 (比如，Manx 的 Aztec C)。

<span class="PreProc">用 QuickFixCmdPost 来修正编码</span><span class="Ignore"> ~</span>

<span class="Type">'encoding'</span> 可能不同于编译程序产生的信息的编码，下例说明 Vim 读入错误信息后如何
修正之:<span class="Ignore"> &gt;</span>

<span class="Comment">	function QfMakeConv()</span>
<span class="Comment">	   let qflist = getqflist()</span>
<span class="Comment">	   for i in qflist</span>
<span class="Comment">	      let i.text = iconv(i.text, &quot;cp936&quot;, &quot;utf-8&quot;)</span>
<span class="Comment">	   endfor</span>
<span class="Comment">	   call setqflist(qflist)</span>
<span class="Comment">	endfunction</span>

<span class="Comment">	au QuickfixCmdPost make call QfMakeConv()</span>

(Faque Cheng 提供示例)
另一个选项是用 <span class="Type">'makeencoding'</span>。

<span class="PreProc">==============================================================================</span>
5. 使用 :vimgrep 和 :grep				<span class="Ignore">*</span><span id="grep" class="String anchor">grep</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="lid" class="String anchor">lid</span><span class="Ignore">*</span>

Vim 有两种寻找模式匹配的方式: 内部方式和外部方式。内部 grep 的优点是能适用于所
有系统并且使用强大的 Vim 搜索模式。外部 grep 程序可用于 Vim grep 实现不了你需
要的功能的场合。

内部方法会慢一些，因为文件要先读入内存。优点是:
- 就像编辑文件一样，自动识别换行符和编码。
- 使用 Vim 搜索模式。可以使用多行模式。
- 如果打开了插件: 可以搜索压缩和远程文件。
	<span class="Ignore">|</span><a href="pi_gzip.html#gzip"><span class="Identifier">gzip</span></a><span class="Ignore">|</span> <span class="Ignore">|</span><a href="pi_netrw.html#netrw"><span class="Identifier">netrw</span></a><span class="Ignore">|</span>

要能够这么做，Vim 需要载入每个文件，就像编辑它们那样。如果文件里没有匹配，相应
的缓冲区又会被彻底删除。这里忽略 <span class="Type">'hidden'</span> 选项，以避免搜索许多文件时内存或文件
描述符的溢出。不过如果使用 <span class="Ignore">|</span><span class="Identifier">:hide</span><span class="Ignore">|</span> 命令修饰符，缓冲区保持载入状态。这使得其后
在相同文件里的搜索快得多。

备注 <span class="Ignore">|</span><span class="Identifier">:copen</span><span class="Ignore">|</span> (或对应 <span class="Ignore">|</span><span class="Identifier">:lgrep</span><span class="Ignore">|</span> 的 <span class="Ignore">|</span><span class="Identifier">:lopen</span><span class="Ignore">|</span>) 可用来打开包含链接形式出现的搜索
结果的缓冲区。可用 <span class="Ignore">|</span><span class="Identifier">:silent</span><span class="Ignore">|</span> 命令来抑制缺省的全屏 grep 输出结果。&quot;:grep!&quot; 形式
的 <span class="Ignore">|</span><span class="Identifier">:grep</span><span class="Ignore">|</span> 命令不自动跳转到首个匹配。这些命令可以组合成一个新的命令:<span class="Ignore"> &gt;</span>

<span class="Comment">        command! -nargs=+ NewGrep execute 'silent grep! &lt;args&gt;' | copen 42</span>

5.1 使用 Vim 的内部 grep

					<span class="Ignore">*</span><span class="String">:vim</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:vimgrep</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E682" class="String anchor">E682</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E683" class="String anchor">E683</span><span class="Ignore">*</span>
:vim[grep][!] /<span class="Special">{pattern}</span>/[g][j] <span class="Special">{file}</span> ...
			在文件 <span class="Special">{file}</span> ... 里搜索模式 <span class="Special">{pattern}</span>，并用匹配结果设
			置错误列表。忽略匹配 <span class="Type">'wildignore'</span> 的文件；最后搜索匹配
			<span class="Type">'suffixes'</span> 的文件。
			如果没有 'g' 标志位，每行只加一次。
			如果有 'g'，每个匹配都被加入。

			<span class="Special">{pattern}</span> 是 Vim 的搜索模式。除了用 / 之外，任何非 ID
			字符 (见 |<span class="Type">'isident'</span>) 都可以用来包围该模式，只要在
			<span class="Special">{pattern}</span> 里不出现就行了。
			适用 <span class="Type">'ignorecase'</span>。要否决该设置，在模式里用 <span class="Ignore">|</span><span class="Identifier">/\c</span><span class="Ignore">|</span> 来忽
			略大小写或 <span class="Ignore">|</span><span class="Identifier">/\C</span><span class="Ignore">|</span> 来匹配大小写。
			不使用 <span class="Type">'smartcase'</span>。
			如果 <span class="Special">{pattern}</span> 为空 (例如，指定 //)，使用前次搜索模
			式。<span class="Ignore">|</span><a href="pattern.html#last-pattern"><span class="Identifier">last-pattern</span></a><span class="Ignore">|</span>

			如果命令前面带数字，它定义要寻找的最大匹配数目。这样，
			&quot;:1vimgrep pattern file&quot; 只会找到第一个。这可以用于只
			想检查是否有匹配而在找到后能快速退出的场合。

			如果没有 'j' 标志位，Vim 跳到第一个匹配上。
			如果有 'j'，只更新 quickfix 列表。
			如果有 [!]，放弃当前缓冲区的任何修改。

			大约每过一秒，显示正在搜索的文件名，让你了解当前的进展
			情况。
			例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:vimgrep /an error/ *.c</span>
<span class="Comment">				:vimgrep /\&lt;FileName\&gt;/ *.h include/*</span>
<span class="Comment">				:vimgrep /myfunc/ **/*.c</span>
<span class="Ignore">&lt;</span>			&quot;**&quot; 的使用可见 <span class="Ignore">|</span><a href="editing.html#starstar-wildcard"><span class="Identifier">starstar-wildcard</span></a><span class="Ignore">|</span>。

:vim[grep][!] <span class="Special">{pattern}</span> <span class="Special">{file}</span> ...
			同上，但不用非 ID 的字符包围模式，而只用空白分隔。该模
			式必须以 ID 字符开头。
			例如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:vimgrep Error *.c</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">:lv</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lvimgrep</span><span class="Ignore">*</span>
:lv[imgrep][!] /<span class="Special">{pattern}</span>/[g][j] <span class="Special">{file}</span> ...
:lv[imgrep][!] <span class="Special">{pattern}</span> <span class="Special">{file}</span> ...
			和 &quot;:vimgrep&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

						<span class="Ignore">*</span><span class="String">:vimgrepa</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:vimgrepadd</span><span class="Ignore">*</span>
:vimgrepa[dd][!] /<span class="Special">{pattern}</span>/[g][j] <span class="Special">{file}</span> ...
:vimgrepa[dd][!] <span class="Special">{pattern}</span> <span class="Special">{file}</span> ...
			和 &quot;:vimgrep&quot; 类似，但不是建立新的错误列表，而是附加到
			现有的列表之后。

						<span class="Ignore">*</span><span class="String">:lvimgrepa</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lvimgrepadd</span><span class="Ignore">*</span>
:lvimgrepa[dd][!] /<span class="Special">{pattern}</span>/[g][j] <span class="Special">{file}</span> ...
:lvimgrepa[dd][!] <span class="Special">{pattern}</span> <span class="Special">{file}</span> ...
			和 &quot;:vimgrepadd&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

5.2 外部 grep

Vim 可以和 &quot;grep&quot; 或类似 grep 的程序 (比如 GNU id-utils) 交互，其方式和与编译
器交互方式类似。

[Unix 小常识: Unix 上 &quot;grep&quot; 命令的名字来源于 &quot;:g/re/p&quot;，其中 &quot;re&quot; 是正则表达
式 (Regular Expression) 的意思。]

							    <span class="Ignore">*</span><span class="String">:gr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:grep</span><span class="Ignore">*</span>
:gr[ep][!] <span class="Special">[arguments]</span>	和 &quot;:make&quot; 类似，但以 <span class="Type">'grepprg'</span> 替代 <span class="Type">'makeprg'</span>，以
			<span class="Type">'grepformat'</span> 替代 <span class="Type">'errorformat'</span>。
			如果 <span class="Type">'grepprg'</span> 是 &quot;internal&quot;，这等价于 <span class="Ignore">|</span><span class="Identifier">:vimgrep</span><span class="Ignore">|</span>。
			注意 这时模式必须用分隔字符包围。
			如果错误文件的编码和 <span class="Type">'encoding'</span> 选项不同，可用
			<span class="Type">'makeencoding'</span> 选项来指定编码。

							    <span class="Ignore">*</span><span class="String">:lgr</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lgrep</span><span class="Ignore">*</span>

:lgr[ep][!] <span class="Special">[arguments]</span>	和 &quot;:grep&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

							<span class="Ignore">*</span><span class="String">:grepa</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:grepadd</span><span class="Ignore">*</span>
:grepa[dd][!] <span class="Special">[arguments]</span>
			和 &quot;:grep&quot; 类似，但不另建一个新的错误列表，只是将匹配
			附加到当前列表中。
			比如:<span class="Ignore"> &gt;</span>
<span class="Comment">				:call setqflist([])</span>
<span class="Comment">				:bufdo grepadd! something %</span>
<span class="Ignore">&lt;</span>			第一个命令新建一个空的错误列表。第二个命令对每个列出的
			缓冲区执行 &quot;grepadd&quot;。注意 ! 的使用是避免 &quot;:grepadd&quot;
			跳转到首个错误，<span class="Ignore">|</span><span class="Identifier">:bufdo</span><span class="Ignore">|</span> 不允许这样。
			一个使用参数列表并在没有匹配文件时不报错的例子:<span class="Ignore"> &gt;</span>
<span class="Comment">                                :silent argdo try</span>
<span class="Comment">				  \ | grepadd! something %</span>
<span class="Comment">				  \ | catch /E480:/</span>
<span class="Comment">				  \ | endtry&quot;</span>
<span class="Ignore">&lt;</span>
			如果错误文件的编码和 <span class="Type">'encoding'</span> 选项不同，可用
			<span class="Type">'makeencoding'</span> 选项来指定编码。

							<span class="Ignore">*</span><span class="String">:lgrepa</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:lgrepadd</span><span class="Ignore">*</span>
:lgrepa[dd][!] <span class="Special">[arguments]</span>
			和 &quot;:grepadd&quot; 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

5.3 设定外部 grep

如果你已安装了一个标准的 &quot;grep&quot; 程序，:grep 命令会以缺省方式运行。格式和标准命
令很类似:<span class="Ignore"> &gt;</span>

<span class="Comment">	:grep foo *.c</span>

会对每个 .c 文件搜索字符串 &quot;foo&quot;。:grep 的参数直接传递给 &quot;grep&quot; 程序，这样你就
可以使用 &quot;grep&quot; 支持的任何选项。

缺省状态下，:grep 会以 -n 参数启动 grep (显示文件和行号)。你可以通过设定
<span class="Type">'grepprg'</span> 对此改变。在以下这些情况下你需要设定 <span class="Type">'grepprg'</span>:

a)	你在使用一个不叫 &quot;grep&quot; 的程序。
b)	你需要以绝对路径启动 grep。
c)	你想自动传递某些参数 (比如，忽略大小写)。

&quot;grep&quot; 执行后，Vim 会用 <span class="Type">'grepformat'</span> 选项解析其结果。该选项和 <span class="Type">'errorformat'</span> 的
工作方式相同。如果你的 grep 输出不是标准格式或是你使用具有特定格式的程序，你可
以通过设定 <span class="Type">'errorformat'</span> 来改变缺省值。

解析完结果，Vim 会载入第一个含有匹配的文件并跳转到相应行，与在 <span class="Ignore">|</span><a href="quickfix.html#quickfix"><span class="Identifier">quickfix</span></a><span class="Ignore">|</span> 模式
中跳转到一个编译错误的方式相同。你可以使用 <span class="Ignore">|</span><span class="Identifier">:cnext</span><span class="Ignore">|</span>，<span class="Ignore">|</span><span class="Identifier">:clist</span><span class="Ignore">|</span> 等命令来查看其它
的匹配。

5.4 配合 id-utils 使用 :grep

你可以设定 :grep 来使用 GNU id-utils:<span class="Ignore"> &gt;</span>

<span class="Comment">	:set grepprg=lid\ -Rgrep\ -s</span>
<span class="Comment">	:set grepformat=%f:%l:%m</span>

然后:<span class="Ignore"> &gt;</span>
<span class="Comment">	:grep (regexp)</span>

结果就像你所期望的那样。
(只要你记得首先 mkid :)

5.5 用 :vimgrep 或 :grep 浏览源代码

使用 Vim 保存的错误列表，你可以查找某些函数或是其调用的其它函数。举个例子，如
果你要对 read_file() 函数添加一个参数，可以输入下面的命令:<span class="Ignore"> &gt;</span>

<span class="Comment">	:vimgrep /\&lt;read_file\&gt;/ *.c</span>

你可以用 &quot;:cn&quot; 在一系列匹配中跳转，然后加上所需要的参数。在某个地方，你需要从
上一级函数 msg() 得到这个新的参数，因此也要对它做出修改:<span class="Ignore"> &gt;</span>

<span class="Comment">	:vimgrep /\&lt;msg\&gt;/ *.c</span>

在修改 msg() 函数的同时，你又找到另一个需要从上级函数中获得该参数的函数。你可
以用 &quot;:vimgrep&quot; 命令找到这些函数。当完成一个函数后，你可以用:<span class="Ignore"> &gt;</span>

<span class="Comment">	:colder</span>

来跳转到上一个函数。

这就像浏览一棵树一样，&quot;:vimgrep&quot; 每深入一层，就创建新的分支。&quot;:colder&quot; 跳转到
上一层。你可以混合使用 &quot;:vimgrep&quot; 和 &quot;:colder&quot;，以树型方式来浏览所有的位置。如
果经常这么做，你不需写一个 &quot;todo list&quot; 就能找到所有的位置。

<span class="PreProc">=============================================================================</span>
6. 选择编译器						<span class="Ignore">*</span><span id="compiler-select" class="String anchor">compiler-select</span><span class="Ignore">*</span>

						<span class="Ignore">*</span><span class="String">:comp</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">:compiler</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E666" class="String anchor">E666</span><span class="Ignore">*</span>
:comp[iler][!] <span class="Special">{name}</span>		为 <span class="Special">{name}</span> 编译器设定相关选项。
				当没有 &quot;!&quot; 时设定只作用于当前缓冲区。如果使用
				了 &quot;!&quot; 则修改全局选项的值。
				如果你对于 &quot;file.foo&quot; 使用 &quot;:compiler foo&quot; 然
				后对另外一个缓冲区使用了 &quot;:compiler! bar&quot;，Vim
				会继续对 &quot;file.foo&quot; 文件使用 foo。
				{仅当编译时指定 <span class="Ignore">|</span><span class="Identifier">+eval</span><span class="Ignore">|</span> 特性才有效}

在 &quot;compiler&quot; 目录中的 Vim 插件被用来为选择的编译器设定各种选项。对
<span class="Ignore">`</span><span class="Comment">:compiler</span><span class="Ignore">`</span> 设定局部选项，对 <span class="Ignore">`</span><span class="Comment">:compiler!</span><span class="Ignore">`</span> 设定全局选项。

							<span class="Ignore">*</span><span id="current_compiler" class="String anchor">current_compiler</span><span class="Ignore">*</span>
为了支持老版本的 Vim，这些插件总使用 &quot;current_compiler&quot; 而不是
&quot;b:current_compiler&quot;。这个命令实际上做的是:

- 删除 &quot;current_compiler&quot; 和 &quot;b:current_compiler&quot; 变量。
- 定义 &quot;CompilerSet&quot; 用户命令。对 &quot;!&quot; 使用 &quot;:set&quot;，没有 &quot;!&quot; 使用 &quot;:setlocal&quot;。
- 执行 &quot;:runtime! compiler/<span class="Special">{name}</span>.vim&quot;。插件应该使用 &quot;CompilerSet&quot; 来做各种设
  定并将编译器的名字赋给 &quot;current_compiler&quot;。
- 删除 &quot;CompilerSet&quot; 用户命令。
- 将 &quot;b:current_compiler&quot; 设为 &quot;current_compiler&quot; 的值。
- 没有 &quot;!&quot; 的话 &quot;current_compiler&quot; 的旧值会被恢复。

如要编写编译器插件，请参考 <span class="Ignore">|</span><a href="usr_41.html#write-compiler-plugin"><span class="Identifier">write-compiler-plugin</span></a><span class="Ignore">|</span>。

<span class="Statement">GCC					</span><span class="Ignore">*</span><span id="quickfix-gcc" class="String anchor">quickfix-gcc</span><span class="Ignore">*</span>	<span class="Ignore">*</span><span id="compiler-gcc" class="String anchor">compiler-gcc</span><span class="Ignore">*</span>

GCC 编译器有一个变量可以设置:

g:compiler_gcc_ignore_unmatched_lines
				忽略不匹配 GCC 定义的任何模式的行。如果 make
				运行的命令的输出产生误判 (false positive)。

<span class="Statement">MANX AZTEC C				</span><span class="Ignore">*</span><span id="quickfix-manx" class="String anchor">quickfix-manx</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="compiler-manx" class="String anchor">compiler-manx</span><span class="Ignore">*</span>

要使 Vim 和 Amiga 上的 Manx Aztec C 编译器工作，需要以下步骤:
- 设定 CCEDIT 环境变量:<span class="Ignore"> &gt;</span>
<span class="Comment">	mset &quot;CCEDIT=vim -q&quot;</span>
- 用 -qf 选项编译。如果编译器发现任何错误，Vim 被启动，光标定位在首个错误处。
  错误信息会在最后一行显示。你可以用上面提到的命令跳转到其它的错误，对其修定并
  存盘。
- 如果正常退出 Vim，编译器会再次编译相同文件。如果用 :cq 命令退出，编译器就会
  终止。如果不能修定错误或是需要先编译其它的文件，你可以这样做。

在 Amiga 系统上，QuickFix 模式会有某些限制。编译器只能在错误文件中写入前 25 个
错误 (Manx 的文档没有说明怎样才能写入更多)。如果想查找其它的错误，你需要首先修
定一些错误并退出编译器。重新编译后，剩下的错误 (最多 25 个) 就会找到。

如果 Vim 是在编译器中启动的，:sh 和一些 :! 命令不能工作，因为 Vim 是和编译器在
同一个进程中运行而 stdin (标准输入) 此时不在交互状态。

<span class="Statement">PERL					</span><span class="Ignore">*</span><span id="quickfix-perl" class="String anchor">quickfix-perl</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="compiler-perl" class="String anchor">compiler-perl</span><span class="Ignore">*</span>

Perl 编译器插件并不实际编译，而是调用 Perl 的内部语法检查功能并分析结果来得到
可能的错误，以便你能在 quick-fix 模式中修正。

不管检查的文件里是否有 &quot;no warnings&quot; 或 &quot;$^W = 0&quot;，警告还会产生。要关闭之，设
置 g:perl_compiler_force_warnings 为零值。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	let g:perl_compiler_force_warnings = 0</span>

PYUNIT 编 译 器						<span class="Ignore">*</span><span id="compiler-pyunit" class="String anchor">compiler-pyunit</span><span class="Ignore">*</span>

这其实不是一个编译器，而是一个为 Python 语言而设的单元测试工具。从版本 2.0
起，它就在标准的 Python 发布中。对老版本，你可以在这里获得:
<span class="String"><a href="http://pyunit.sourceforge.net">http://pyunit.sourceforge.net</a></span>。

当你运行测试时，Vim 会解析错误并进入到 quick-fix 模式。

不幸的是，没有一个运行测试的标准方法。
一般都会用使用 alltest.py。我们就知道这么多。
有关 <span class="Type">'makeprg'</span> 选项就可以这样设定:
 setlocal makeprg=./alltests.py &quot; 执行全套测试
 setlocal makeprg=python\ %:S   &quot; 执行单个测试用例

另外，参考 <span class="String"><a href="http://vim.sourceforge.net/tip_view.php?tip_id=280">http://vim.sourceforge.net/tip_view.php?tip_id=280</a></span>。

TEX 编 译 器						<span class="Ignore">*</span><span id="compiler-tex" class="String anchor">compiler-tex</span><span class="Ignore">*</span>

Vim 发布版本中的 Tex 编译器 ($VIMRUNTIME/compiler/tex.vim) 可以处理各种风格的
TeX 格式。如果编译器在当前目录找到文件 &quot;Makefile&quot; 或 &quot;makefile&quot;，它将假定你希
望用 make 来处理 *TeX 文件，而 makefile 已经做好了各种设定。这种情况下编译器会
将 <span class="Type">'errorformat'</span> 设定为 *TeX 的输出格式并将 <span class="Type">'makeprg'</span> 保留原样。如果
&quot;Makefile&quot; 和 &quot;makefile&quot; 都找不到，编译器就不会使用 make。你可以通过定义
b:tex_ignore_makefile 或 g:tex_ignore_makefile 来强制编译器忽略 makefile (Vim
只检查这两个变量存在与否)。

如果编译器选择了不使用 make，它必须选择一个正确的程序来处理你的输入。如果变量
b:tex_flavor 或 g:tex_flavor (依此优先顺序) 存在，它将为 :make (即为所要运行的
命令) 定义 TeX 风格；如果这两个变量都不存在，将会使用缺省的 &quot;latex&quot;。比如，当
编辑以 AMS-TeX 格式编写的 chapter2.tex (被 \input 进入 mypaper.tex 中) 时:<span class="Ignore"> &gt;</span>

<span class="Comment">	:let b:tex_flavor = 'amstex'</span>
<span class="Comment">	:compiler tex</span>
<span class="Ignore">&lt;</span>	[editing...]<span class="Ignore"> &gt;</span>
<span class="Comment">	:make mypaper</span>
<span class="Ignore">&lt;</span>
注意，你必须将所处理文件的文件名作为参数 (为了在编辑被 \input 或 \include 的文
件时能处理正确的文件；我们期待任何可移植的能不用参数就可以替代 % 的解决方案)。
这与 make 指定目标而非源的语法是相悖的，但你可以指定不含扩展名 &quot;.tex&quot; 的文件名
filename，来表示 &quot;make filename.dvi 或 filename.pdf 或 filename.其它_目标_扩展
名&quot;，具体名字视编译器而定。

备注: tex 命令行格式对 MikTeX (Srinath Avadhanula 报告) 和 teTeX (Artem
Chuprina 测试) 都适用。要使 <span class="Ignore">|</span><a href="quickfix.html#errorformat-LaTeX"><span class="Identifier">errorformat-LaTeX</span></a><span class="Ignore">|</span> 对不同 shell 不同 OS 都适用太
过复杂，因此不允许使用其它的 TeX 的选项。如果你的 TeX 不支持
&quot;-interaction=nonstopmode&quot;，请在命令行中用其它的方式表示 \nonstopmode。

<span class="PreProc">=============================================================================</span>
7. 错误格式						<span class="Ignore">*</span><span id="error-file-format" class="String anchor">error-file-format</span><span class="Ignore">*</span>

					<span class="Ignore">*</span><span id="errorformat" class="String anchor">errorformat</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E372" class="String anchor">E372</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E373" class="String anchor">E373</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E374" class="String anchor">E374</span><span class="Ignore">*</span>
						<span class="Ignore">*</span><span id="E375" class="String anchor">E375</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E376" class="String anchor">E376</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E377" class="String anchor">E377</span><span class="Ignore">*</span> <span class="Ignore">*</span><span id="E378" class="String anchor">E378</span><span class="Ignore">*</span>
<span class="Type">'errorformat'</span> 选项指定可识别出的一系列格式。首个匹配的格式会被使用。你可以为编
译器产生的不同信息添加不同格式，或是为多个编译器添加项目。参见 <span class="Ignore">|</span><a href="quickfix.html#efm-entries"><span class="Identifier">efm-entries</span></a><span class="Ignore">|</span>。

<span class="Type">'errorformat'</span> 里的每一项是一个类似 scanf 的格式字符串。首先，你需要了解 scanf
是如何工作的。请查看你的 C 编译器文档。下面你可以看到 Vim 能理解 % 的条目。其
它的无效。

<span class="Type">'errorformat'</span> 中的特殊字符是逗号和反斜杠，参见 <span class="Ignore">|</span><a href="quickfix.html#efm-entries"><span class="Identifier">efm-entries</span></a><span class="Ignore">|</span>。注意按本义出现的
字符 &quot;%&quot; 用 &quot;%%&quot; 来匹配，而不用反斜杠来转义。
记住 <span class="Ignore">`</span><span class="Comment">:make</span><span class="Ignore">`</span> 和 <span class="Ignore">`</span><span class="Comment">:grep</span><span class="Ignore">`</span> 输出中的所有 NUL 字符会被 SOH (0x01) 替换。

备注: 缺省忽略大小写差别。如果要匹配大小写，在模式中加入 &quot;\C&quot;，参见 <span class="Ignore">|</span><span class="Identifier">/\C</span><span class="Ignore">|</span>。

基 本 条 目

	%f		文件名 (期待字符串 (译者注: 以下 &quot;期待&quot; 二字从略))
	%l		行号 (数字)
	%c		列号 (代表错误中字符列的数字，(<span class="Special">&lt;tab&gt;</span> 为一个字符列))
	%v		虚拟列号 (代表错误中屏幕列的数字，(<span class="Special">&lt;tab&gt;</span> 等于 8 个屏幕
			列))
	%t		错误类型 (单个字符)
	%n		错误号 (数字)
	%m		错误信息 (字符串)
	%r		匹配 &quot;余下的&quot; 的单行文件信息 %O/P/Q
	%p		指针行 ('-'、'.'、' ' 或是制表符的序列，用其长度指定列
	%		号)
	%*<span class="Special">{conv}</span>	任何 scanf 免于赋值的转换
	%%		单个 '%' 字符
	%s		搜索文本 (字符串)

&quot;%f&quot; 转换可能依赖于当前 <span class="Type">'isfname'</span> 的设定。&quot;~/&quot; 被扩展为主目录，环境变量也被扩
展。

&quot;%f&quot; 和 &quot;%m&quot; 转换需要识别字符串结尾。通常这是通过匹配后面的字符和项目完成的。
如果后面没有别的项目，该行的其余部分都被匹配。如果 &quot;%f&quot; 后面跟着 '%' 或者反斜
杠，它会寻找 <span class="Type">'isfname'</span> 字符的序列。

在 MS-DOS、MS-Windows 和 OS/2 系统上，&quot;C:&quot; 会加到 &quot;%f&quot; 开头中，即使使用
&quot;%f:&quot;。这就是说 (字母表中的) 单字符文件名将不被识别。

&quot;%p&quot; 转换一般后跟 &quot;^&quot;。这是为了配合编译器产生的这种输出:<span class="Ignore"> &gt;</span>
<span class="Comment">	    ^</span>
或<span class="Ignore"> &gt;</span>
<span class="Comment">   ---------^</span>
以指定错误所在列。这被用在一个多行错误信息中。<span class="Ignore">|</span><a href="quickfix.html#errorformat-javac"><span class="Identifier">errorformat-javac</span></a><span class="Ignore">|</span> 有一个有用
的例子。

&quot;%s&quot; 转换指定用于定位错误行的搜索文本。该文本用作按本义出现的字符串。文本会加
入 &quot;^&quot; 和 &quot;%&quot; 使要定位的错误行完全匹配搜索文本。文本也加入 &quot;\V&quot; 匹配原作为前
缀，使得它 &quot;very nomagic&quot;。&quot;%s&quot; 转换可用于定位错误输出里没有行号的行。&quot;grep&quot;
shell 命令的输出就是如此。
如果此模式存在，不使用行号。

改 变 目 录

下面的大写转换指定特殊的格式字符串的类型。至多只能用其中的一个作为以逗号分隔的
单个格式的前缀。
一些编译器产生含有目录名的信息，这些目录名需要加在 %f 读入文件名的前面 (比如
GNU make)。下面的代码可用于扫描这些目录名；它们将被保存在内部的目录栈中。
								<span class="Ignore">*</span><span id="E379" class="String anchor">E379</span><span class="Ignore">*</span>
	%D		&quot;进入目录&quot; 格式字符串；期待后跟 %f 以找到目录名
	%X		&quot;退出目录&quot; 格式字符串；期待跟在 %f 之后

当定义 &quot;进入目录&quot; 或是 &quot;退出目录&quot; 格式时，&quot;%D&quot; 或是 &quot;%X&quot; 必须在子字符串的开
头。Vim 会跟踪目录的变化并把当前目录添加在带有相对路径的错误文件名前。有关细
节，参见 <span class="Ignore">|</span><a href="quickfix.html#quickfix-directory-stack"><span class="Identifier">quickfix-directory-stack</span></a><span class="Ignore">|</span>。

多 行 信 息					<span class="Ignore">*</span><span id="errorformat-multi-line" class="String anchor">errorformat-multi-line</span><span class="Ignore">*</span>

Vim 可以读入程序输出的多行信息，也就是超过一行的错误字串。有关前缀有:
	%E		多行错误信息开始
	%W		多行警告信息开始
	%I		多行一般信息开始
	%A		多行信息开始 (未指定类型)
	%&gt;		下行再次从当前模式开始寻找 <span class="Ignore">|</span><a href="#"><span class="Identifier">efm-%&gt;</span></a><span class="Ignore">|</span>
	%C		多行信息继续
	%Z		多行信息结束
这些可同 '+' 和 '-' 一起使用，参见下面的 <span class="Ignore">|</span><a href="quickfix.html#efm-ignore"><span class="Identifier">efm-ignore</span></a><span class="Ignore">|</span>。

模式里的 &quot;\n&quot; 不能用于匹配多行消息。

例子: 你的编译器以下面格式输出 (开头的行号并不是实际输出):

     <span class="PreProc">1	Error 275</span><span class="Ignore"> ~</span>
     <span class="PreProc">2	line 42</span><span class="Ignore"> ~</span>
     <span class="PreProc">3	column 3</span><span class="Ignore"> ~</span>
     <span class="PreProc">4	' ' expected after '--'</span><span class="Ignore"> ~</span>

正确的错误格式串应如下:<span class="Ignore"> &gt;</span>
<span class="Comment">   :set efm=%EError\ %n,%Cline\ %l,%Ccolumn\ %c,%Z%m</span>

这样，<span class="Ignore">|</span><span class="Identifier">:clist</span><span class="Ignore">|</span> 产生的出错信息为:

 1:42 col 3 error 275:  ' ' expected after '--'

另一个例子: Python 解释器产生下面的错误信息 (行号不是实际输出):

     1	==============================================================
     2	FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)
     3	--------------------------------------------------------------
     4	Traceback (most recent call last):
     5	  File &quot;unittests/dbfacadeTest.py&quot;, line 89, in testFoo
     6	    self.assertEquals(34, dtid)
     7	  File &quot;/usr/lib/python2.2/unittest.py&quot;, line 286, in
     8	 failUnlessEqual
     9	    raise self.failureException, \
    10	AssertionError: 34 != 33
    11
    12	--------------------------------------------------------------
    13	Ran 27 tests in 0.063s

假使你想让 <span class="Ignore">|</span><span class="Identifier">:clist</span><span class="Ignore">|</span> 输出这样的相关信息:
 5 unittests/dbfacadeTest.py:89:  AssertionError: 34 != 33

错误格式字符串可这样定义:<span class="Ignore"> &gt;</span>
<span class="Comment">  :set efm=%C\ %.%#,%A\ \ File\ \&quot;%f\&quot;\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m</span>

注意 %C 字符串在 %A 前指定: 因为 ' %.%#' 表达式 (表示正则表达式 ' .*') 匹配每
一个以空格开头后接任何字符的行，这样就包括了本来会单独产生错误信息的第 7 行。
错误格式字符串总是一个模式接一个模式的分析，直到找到首个匹配。

							<span class="Ignore">*</span><span class="String">efm-%&gt;</span><span class="Ignore">*</span>
%&gt; 项目可用来避免在 <span class="Type">'errorformat'</span> 较早的位置出现的模式。尤其是那些会匹配所有内
容的模式。例如，如果错误看起来像:

	<span class="PreProc">Error in line 123 of foo.c:</span><span class="Ignore"> ~</span>
	<span class="PreProc">unknown variable &quot;i&quot;</span><span class="Ignore"> ~</span>

可以这样找到它:<span class="Ignore"> &gt;</span>
<span class="Comment">	:set efm=xxx,%E%&gt;Error in line %l of %f:,%Z%m</span>
其中 &quot;xxx&quot; 包含也可以匹配第二行的模式。

重要: 没有关于上次在 errorformat 哪个部分匹配的记忆；错误文件的每行都重新开始
遍历错误格式行。例如，如果:<span class="Ignore"> &gt;</span>
<span class="Comment">  setlocal efm=aa,bb,cc,dd,ee</span>
其中 aa、bb 等是错误格式字符串。错误文件的每行都会依次匹配 aa 模式，然后 bb，
然后 cc 等等。只因为 cc 匹配了上一个错误行并_不_意味着当前行会优先尝试 dd，即
使 cc 和 dd 都是多行错误格式字符串也不例外。

单 独 文 件 名				<span class="Ignore">*</span><span id="errorformat-separate-filename" class="String anchor">errorformat-separate-filename</span><span class="Ignore">*</span>

如果编译器输出只给定一次文件名而其后有多个信息指向这个文件，下面的前缀就很有
用:
	%O		单行文件信息: 过读 (overread，见下) 匹配部分
	%P		单行文件信息: 将文件 %f 入栈
	%Q		单行文件信息: 将最后一个文件名出栈

例子: 编译器产生以下出错日志 (不含开头的行号):

     1	[a1.tt]
     2	(1,17)  error: ';' missing
     3	(21,2)  warning: variable 'z' not defined
     4	(67,3)  error: end of file found before string ended
     5
     6	[a2.tt]
     7
     8	[a3.tt]
     9	NEW compiler v1.1
    10	(2,2)   warning: variable 'x' not defined
    11	(67,3)  warning: 's' already defined

这个文件对每个在 [...] 中包括的文件列出了多个信息。我们可以这样设定格式:<span class="Ignore"> &gt;</span>
<span class="Comment">  :set efm=%+P[%f],(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%-Q</span>

<span class="Ignore">|</span><span class="Identifier">:clist</span><span class="Ignore">|</span> 会正确的显示它们的文件名:

  2 a1.tt:1 col 17 error: ';' missing
  3 a1.tt:21 col 2 warning: variable 'z' not defined
  4 a1.tt:67 col 3 error: end of file found before string ended
  8 a3.tt:2 col 2 warning: variable 'x' not defined
  9 a3.tt:67 col 3 warning: 's' already defined

和其它匹配整行的前缀不同，%P、%Q 和 %O 可以匹配同一行中的多个模式。这样就可以
对像下面这样嵌套的文件解析:
  {&quot;file1&quot; {&quot;file2&quot; error1} error2 {&quot;file3&quot; error3 {&quot;file4&quot; error4 error5}}}
%O 解析不包含需要出入栈的文件名的信息的字符串。更深入的例子，参见
<span class="Ignore">|</span><a href="quickfix.html#errorformat-LaTeX"><span class="Identifier">errorformat-LaTeX</span></a><span class="Ignore">|</span>。
(译者注: overread 有读过度的意思，这里的意思是说对读到的文件名不用太过认真)

忽 略 和 使 用 整 个 信 息				<span class="Ignore">*</span><span id="efm-ignore" class="String anchor">efm-ignore</span><span class="Ignore">*</span>

'+' 和 '-' 可与上面的大写代码结合；这种情况下，它们要在字母的前面，比如 '%+A'
或 '%-G'。
	%-		不在任何输出中包含相匹配的 (多) 行
	%+		在 %m 错误串中包含整个匹配行

%G 只在和 '+' 和 '-' 结合使用时才有用。它解析编译器版本等可被忽略的字符串。
	%-G		忽略此信息
	%+G		通用信息

模 式 匹 配

scanf() 风格的 &quot;%*[]&quot; 记法仍被支持，以和老版本兼容。但你可以在格式化字符串中指
定 Vim 支持的 (几乎) 任何正则表达式。因为元字符本身可能为匹配字符串或文件名的
一部分 (因此内部需要被转义)，要起到元字符的作用，它们的开头要加上一个 '%':
	%\		单个 '\' 字符。注意在 &quot;:set errorformat=&quot; 定义中需要
			用 &quot;%\\&quot; 来转义。
	%.		单个 '.' 字符。
	%#		单个 '*' (注意！) 字符。
	%^		单个 '^' 字符。注意这并不有用，模式总是匹配行首
	%$		单个 '$' 字符。注意这并不有用，模式总是匹配行尾
	%[		单个 '[' 字符 (指定一个 [] 字符范围)。
	%~		单个 '~' 字符。
当在表达式中使用字符类 (参见 <span class="Ignore">|</span><span class="Identifier">/\i</span><span class="Ignore">|</span>) 时，含有 &quot;\+&quot; 数量符的串可以使用 scanf()
的 &quot;%*&quot; 形式代替。比如: &quot;%\\d%\\+&quot; (&quot;\d\+&quot; 或 &quot;任意数字&quot;) 和 &quot;%*\\d&quot; 相同。
重要备注: 子匹配 \(...\) 不能用于格式规格中，因为它被留作内部变换使用。

<span class="Type">'errorformat'</span> 中 的 多 个 选 项			<span class="Ignore">*</span><span id="efm-entries" class="String anchor">efm-entries</span><span class="Ignore">*</span>

为能识别从不同编译器产生的输出，可在 <span class="Type">'errorformat'</span> 中指定多个格式模式，用逗号
将它们分隔 (备注: 逗号后的空格被忽略)。使用第一个完全匹配的模式。如果没有匹
配，则使用最近一次匹配行的匹配部分，然而文件名被删除并且错误信息被设定为整个信
息。如果有模式可以匹配多个编译器产生的输出 (但不是正确的方式)，将它放到一个更
严格的模式的后面。

要在模式中包括逗号，在它前面加一个反斜杠 (如果是在 &quot;:set&quot; 命令中，要加两个)。
要包括反斜杠本身，则使用两个反斜杠 (在 &quot;:set&quot; 命令中使用四个)。&quot;:set&quot; 命令中，
在空格前也要加一个反斜杠。

有 效 匹 配						<span class="Ignore">*</span><span id="quickfix-valid" class="String anchor">quickfix-valid</span><span class="Ignore">*</span>

如果某行不能完全匹配 <span class="Type">'errorformat'</span> 中的项目，则此行被放入到错误信息中并标记为
&quot;无效&quot;。这些行会被 &quot;:cn&quot; 和 &quot;:cp&quot; 命令忽略 (除非没有任何有效行存在)。你可以用
&quot;:cl!&quot; 来显示所有的出错信息。

如果出错格式不含文件名，Vim 不能跳转到正确的文件。你需要手动跳转。

例子

Amiga 上的 Aztec 编译器产生的错误文件格式是:

	filename&gt;linenumber:columnnumber:errortype:errornumber:errormessage

	filename	错误所在文件的文件名
	linenumber	错误所在行号
	columnnumber	错误所在列号
	errortype	错误类型，一般为单个 'E' 或 'W'
	errornumber	错误号 (用于查找手册)
	errormessage	错误描述

可以用这个 <span class="Type">'errorformat'</span> 项目来匹配:
	%f&gt;%l:%c:%t:%n:%m&quot;

一些产生单行错误输出的 C 编译器的例子:
%f:%l:\ %t%*[^0123456789]%n:\ %m	Manx/Aztec C 出错信息
					(scanf() 不能理解 <span class="Special">[0-9]</span>)
%f\ %l\ %t%*[^0-9]%n:\ %m		SAS C
\&quot;%f\&quot;\\,%*[^0-9]%l:\ %m		通用 C 编译器
%f:%l:\ %m				GCC
%f:%l:\ %m,%Dgmake[%*\\d]:\ Entering\ directory\ `%f',
%Dgmake[%*\\d]:\ Leaving\ directory\ `%f'
					与 gmake 配合使用的 GCC (只有一行！)
%f(%l)\ :\ %*[^:]:\ %m			老式 SCO C 编译器 (OS5 之前)
%f(%l)\ :\ %t%*[^0-9]%n:\ %m		同上，增加错误类型和错误号
%f:%l:\ %m,In\ file\ included\ from\ %f:%l:,\^I\^Ifrom\ %f:%l%m
					GCC，一些附加信息

对多行信息处理更深入的例子，参见 <span class="Ignore">|</span><a href="quickfix.html#errorformat-Jikes"><span class="Identifier">errorformat-Jikes</span></a><span class="Ignore">|</span> 和 <span class="Ignore">|</span><a href="quickfix.html#errorformat-LaTeX"><span class="Identifier">errorformat-LaTeX</span></a><span class="Ignore">|</span>。

注意在空格和双引号前的反斜杠。这对 :set 命令是必需的。在逗号前有两个反斜杠，一
个是为 :set 命令需要，一个是为避免将逗号视为出错格式的分隔符。

过 滤 信 息

如果编译器产生的错误信息和格式串不适合，你可以写一个程序将出错信息转化为适合格
式。通过设定 <span class="Type">'makeprg'</span> 选项，你可以用 &quot;:make&quot; 命令运行它。比如:<span class="Ignore"> &gt;</span>
<span class="Comment">   :set mp=make\ \\\|&amp;\ error_filter</span>
管道符前的那些反斜杠是为了避免将其视作命令分隔符。每个空格前的反斜杠是 :set 命
令所必需的。

<span class="PreProc">=============================================================================</span>
8. 目录栈					<span class="Ignore">*</span><span id="quickfix-directory-stack" class="String anchor">quickfix-directory-stack</span><span class="Ignore">*</span>

Quickfix 根据 make 输出，维护一个保存所有使用过的目录的栈。对 GNU-make 来讲，
这非常简单，因为它总是输出绝对路径，不管是通过 makefile 中的一个 <span class="Type">'cd'</span> 命令还是
以 &quot;-C dir&quot; (在读入 makefile 之前进入到指定目录) 参数运行。'-w' 选项可用来强制
GNU-make 在处理前后输出当前目录。

如果你使用的不是 GNU-make，那目录栈的维护就会复杂得多。比如 AIX-make 从不输出
有关当前目录的任何信息。这样你就需要在 makefile 上多花些功夫。Lesstif 的
makefile 中有一个命令可以显示 &quot;Making <span class="Special">{target}</span> in <span class="Special">{dir}</span>&quot;。这里的问题是它并不在
离开目录时输出信息，而且它不输出绝对路径。

为解决相对路径和缺少 &quot;退出目录&quot; 信息问题，Vim 使用下面的算法:

1) 检查给定目录是否为当前目录的子目录。如是，则将其存为当前目录。
2) 如果不是，则检查它是否为上级目录之一的某个子目录。
3) 如果目录仍没找到，则假定为它为 Vim 当前目录的子目录。

此外，每一个文件都被检查，看其是否存在于识别出的目录中。如果不存在，则在目录栈
(_不是_子目录树！) 的其它目录中查找。如果仍没找到，则假定它在 Vim 当前目录中。

此算法仍有限制。本例假定 make 只在进入到一个目录时输出类似 &quot;Making all in dir&quot;
的信息。

1) 假定你有以下目录和文件:
   ./dir1
   ./dir1/file1.c
   ./file1.c

   如果 make 在处理当前目录前处理 &quot;./dir1&quot; 目录，而在文件 &quot;./file1.c&quot; 中存在
   一处错误，Vim 会载入文件 &quot;./dir1/file.c&quot;。

   这只能靠 &quot;退出目录&quot; 信息解决。

2) 假定你有以下目录和文件:
   ./dir1
   ./dir1/dir2
   ./dir2

   你得到如下结果:

   Make 输出			  Vim 理解的目录
   ------------------------	  ----------------------------
   Making all in dir1		  ./dir1
   Making all in dir2		  ./dir1/dir2
   Making all in dir2		  ./dir1/dir2

   这可以通过在 &quot;进入目录&quot; 信息中输出绝对路径或是输出 &quot;退出目录&quot; 信息的方法解
   决。

为避免这些问题，要确保输出绝对路径和 &quot;退出目录&quot; 信息。

Makefiles 例子:

Unix:
    libs:
	    for dn in $(LIBDIRS); do				\
		(cd $$dn; echo &quot;Entering dir '$$(pwd)'&quot;; make); \
		echo &quot;Leaving dir&quot;;				\
	    done

并将
    %DEntering\ dir\ '%f',%XLeaving\ dir
加到 <span class="Type">'errorformat'</span> 选项中以处理上面的输出。

注意 Vim 并不检查 &quot;退出目录&quot; 信息中的目录是否为当前目录。因此只要使用 &quot;Leaving
dir&quot; 这样的信息就可以了。

<span class="PreProc">=============================================================================</span>
9. 特定错误格式					<span class="Ignore">*</span><span id="errorformats" class="String anchor">errorformats</span><span class="Ignore">*</span>

						<span class="Ignore">*</span><span id="errorformat-Jikes" class="String anchor">errorformat-Jikes</span><span class="Ignore">*</span>
Jikes(TM) 是 IBM Research 发布的一个源码到字节码的 Java 编译器。它提供简单的多
行错误信息。

下面是一个与其所产生的信息相匹配的 <span class="Type">'errorformat'</span> 格式字符串。这几行可加到用户
的 <span class="Ignore">|</span><a href="starting.html#vimrc"><span class="Identifier">vimrc</span></a><span class="Ignore">|</span> 以覆盖 Vim 识别的缺省模式。或者，你可以参考 <span class="Ignore">|</span><span class="Identifier">:set+=</span><span class="Ignore">|</span> 将这个模式安装
到缺省格式之中。<span class="Ignore"> &gt;</span>

<span class="Comment">  :set efm=%A%f:%l:%c:%*\\d:%*\\d:,</span>
<span class="Comment">	\%C%*\\s%trror:%m,</span>
<span class="Comment">	\%+C%*[^:]%trror:%m,</span>
<span class="Comment">	\%C%*\\s%tarning:%m,</span>
<span class="Comment">	\%C%m</span>
<span class="Ignore">&lt;</span>
以 &quot;+E&quot; 选项启动时，Jikes(TM) 产生一个单行信息。对此，可以这样匹配:<span class="Ignore"> &gt;</span>

<span class="Comment">  :setl efm=%f:%l:%v:%*\\d:%*\\d:%*\\s%m</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span id="errorformat-javac" class="String anchor">errorformat-javac</span><span class="Ignore">*</span>
<span class="Type">'errorformat'</span> 可以很好的和 javac 工作，javac 的输出中用 &quot;^&quot; 表示错误所在列:<span class="Ignore"> &gt;</span>
<span class="Comment">  :setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#</span>
或者:<span class="Ignore"> &gt;</span>
<span class="Comment">  :setl efm=%A%f:%l:\ %m,%+Z%p^,%+C%.%#,%-G%.%#</span>
<span class="Ignore">&lt;</span>
这里还有一个用于 Unix 的替代方法，由 Michael F. Lamb 提供。首先过滤错误:<span class="Ignore"> &gt;</span>
<span class="Comment">  :setl errorformat=%Z%f:%l:\ %m,%A%p^,%-G%*[^sl]%.%#</span>
<span class="Comment">  :setl makeprg=javac\ %:S\ 2&gt;&amp;1\ \\\|\ vim-javac-filter</span>

然后，你需要在路径的某处 (如 ~/bin) 加入 &quot;vim-javac-filter&quot; 并使之可执行。它包
含如下内容:<span class="Ignore"> &gt;</span>
<span class="Comment">   #!/bin/sed -f</span>
<span class="Comment">   /\^$/s/\t/\ /g;/:[0-9]\+:/{h;d};/^[ \t]*\^/G;</span>

用中文来说，该 sed 脚本:
- 把单个制表符换成单个空格；并
- 把包含文件名、行号及错误信息的行移到指针行下方。这样，两者之间无用的错误文本
  就不会打破 vim &quot;多行消息&quot; 的概念，我们也不用硬要把它当作 &quot;多行信息的继续&quot;。

						<span class="Ignore">*</span><span id="errorformat-ant" class="String anchor">errorformat-ant</span><span class="Ignore">*</span>
ant (<span class="String"><a href="http://jakarta.apache.org/">http://jakarta.apache.org/</a></span>) 输出的每个行首都为 <span class="Special">[javac]</span>，这样我们可将上面
的格式修改如下:<span class="Ignore"> &gt;</span>
<span class="Comment">  :set efm=%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#</span>

<span class="Type">'errorformat'</span> 还可以处理与 javac 或 jikes 之一配合使用的 ant。如使用 jikes，你
需要告诉 ant 使用 jikes 的 +E 选项以使 jikes 产生单行错误信息。这就是下面 (一
个 build.xml 文件的) 第二行所做的:<span class="Ignore"> &gt;</span>
<span class="Comment">  &lt;property name = &quot;build.compiler&quot;       value = &quot;jikes&quot;/&gt;</span>
<span class="Comment">  &lt;property name = &quot;build.compiler.emacs&quot; value = &quot;true&quot;/&gt;</span>

下面的 <span class="Type">'errorformat'</span> 能同时处理与 javac 和 jikes 配合使用的 ant:<span class="Ignore"> &gt;</span>
<span class="Comment">  :set efm=\ %#[javac]\ %#%f:%l:%c:%*\\d:%*\\d:\ %t%[%^:]%#:%m,</span>
<span class="Comment">	   \%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span id="errorformat-jade" class="String anchor">errorformat-jade</span><span class="Ignore">*</span>
解析 jade (见 <span class="String"><a href="http://www.jclark.com/">http://www.jclark.com/</a></span>) 错误十分简单:<span class="Ignore"> &gt;</span>
<span class="Comment">  :set efm=jade:%f:%l:%c:%t:%m</span>
<span class="Ignore">&lt;</span>
						<span class="Ignore">*</span><span id="errorformat-LaTeX" class="String anchor">errorformat-LaTeX</span><span class="Ignore">*</span>
下面是 <span class="Type">'errorformat'</span> 处理 (La)TeX 产生的多行错误输出的例子。&quot;:clist&quot; 和 &quot;:cc&quot;
等命令将多行错误信息显示在一行，开头的空格被删除。
将 LaTeX 的错误格式运用于其它产生多行错误信息的编译器就很简单了。

这些命令可被加到 <span class="Ignore">|</span><a href="starting.html#vimrc"><span class="Identifier">vimrc</span></a><span class="Ignore">|</span> 或是其它 Vim 脚本 －－ 比如一个仅在编辑 LaTeX 源文件
时才载入的含有 LaTeX 相关内容的脚本。
确保将例子中的所有行都拷贝 (按照给定顺序)，然后可删除注释行。行首的 '\' 可以参
考 <span class="Ignore">|</span><a href="repeat.html#line-continuation"><span class="Identifier">line-continuation</span></a><span class="Ignore">|</span>。

		首先设定 <span class="Type">'makeprg'</span> 使 LaTeX 可以报告多个错误；不在首个错误发生
		时就停止:<span class="Ignore"> &gt;</span>
<span class="Comment"> :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}</span>
<span class="Ignore">&lt;</span>
		多行错误信息开始:<span class="Ignore"> &gt;</span>
<span class="Comment"> :set efm=%E!\ LaTeX\ %trror:\ %m,</span>
<span class="Comment">	\%E!\ %m,</span>
<span class="Ignore">&lt;</span>		多行警告信息开始；开始的两个包含行号。若干正则表达式的含义:
		  - &quot;%.%#&quot;  (&quot;.*&quot;)   匹配一个字符串 (可为空)
		  - &quot;%*\\d&quot; (&quot;\d\+&quot;) 匹配一个数字<span class="Ignore"> &gt;</span>
<span class="Comment">	\%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#,</span>
<span class="Comment">	\%+W%.%#\ at\ lines\ %l--%*\\d,</span>
<span class="Comment">	\%WLaTeX\ %.%#Warning:\ %m,</span>
<span class="Ignore">&lt;</span>		错误/警告信息可能的续行；其中的首行也含有行号:<span class="Ignore"> &gt;</span>
<span class="Comment">	\%Cl.%l\ %m,</span>
<span class="Comment">	\%+C\ \ %m.,</span>
<span class="Comment">	\%+C%.%#-%.%#,</span>
<span class="Comment">	\%+C%.%#[]%.%#,</span>
<span class="Comment">	\%+C[]%.%#,</span>
<span class="Comment">	\%+C%.%#%[{}\\]%.%#,</span>
<span class="Comment">	\%+C&lt;%.%#&gt;%.%#,</span>
<span class="Comment">	\%C\ \ %m,</span>
<span class="Ignore">&lt;</span>		匹配下面模式的行不含有任何重要的信息；将其忽略:<span class="Ignore"> &gt;</span>
<span class="Comment">	\%-GSee\ the\ LaTeX%m,</span>
<span class="Comment">	\%-GType\ \ H\ &lt;return&gt;%m,</span>
<span class="Comment">	\%-G\ ...%.%#,</span>
<span class="Comment">	\%-G%.%#\ (C)\ %.%#,</span>
<span class="Comment">	\%-G(see\ the\ transcript%.%#),</span>
<span class="Ignore">&lt;</span>		删除所有空白行:<span class="Ignore"> &gt;</span>
<span class="Comment">	\%-G\\s%#,</span>
<span class="Ignore">&lt;</span>		LaTeX 输出并不在每一行中都指定出错的文件名；而只在括号中指定
		一次。
		下面的模式试图匹配这些文件名并将它们保存到内部栈中。这些模式
		可能扫描相同行 (一个接一个的)，结尾的 &quot;%r&quot; 表示行中 &quot;余下&quot; 的
		部分，这些部分在下轮被重新解析，直到遇到行尾为止。

		过读 '('...')' 包含的文件名；不将其入栈，因为此文件不含有任何
		错误:<span class="Ignore"> &gt;</span>
<span class="Comment">	\%+O(%f)%r,</span>
<span class="Ignore">&lt;</span>		将 '(' 后的文件名入栈:<span class="Ignore"> &gt;</span>
<span class="Comment">	\%+P(%f%r,</span>
<span class="Comment">	\%+P\ %\\=(%f%r,</span>
<span class="Comment">	\%+P%*[^()](%f%r,</span>
<span class="Comment">	\%+P[%\\d%[^()]%#(%f%r,</span>
<span class="Ignore">&lt;</span>		当扫描到 ')'，将最后一个文件名出栈:<span class="Ignore"> &gt;</span>
<span class="Comment">	\%+Q)%r,</span>
<span class="Comment">	\%+Q%*[^()])%r,</span>
<span class="Comment">	\%+Q[%\\d%*[^()])%r</span>

注意某些情况下，LaTeX 输出中的文件名不能正确解析。解析会被不成对的括号打乱。上
面的例子只试图捕获最普通的情况。你可以根据你的需要而修改有关设定，比如，所有烦
人的 &quot;Overfull ...&quot; 警告可不被视为出错。
除了过滤 LaTeX 的输出信息外你还可以直接读入 <span class="Special">[La]</span>TeX 编译器生成的 *.log 文件。
这包括其它的一些由错误引起的有用信息。但要解析这么复杂的文件，你需要使用外部过
滤器。参考上面关于 Vim 过滤器的描述。

						<span class="Ignore">*</span><span id="errorformat-Perl" class="String anchor">errorformat-Perl</span><span class="Ignore">*</span>
在 $VIMRUNTIME/tools 中，你可以找到 efm_perl.pl 脚本。它将 Perl 出错信息过滤为
quickfix 模式可以理解的格式。使用方法可以查看该文件的开头部分。(此脚本已过时，
见 <span class="Ignore">|</span><a href="quickfix.html#compiler-perl"><span class="Identifier">compiler-perl</span></a><span class="Ignore">|</span>。)

</pre>
<!-- vim: set foldmethod=manual : -->

            </pre>
        </article>
    </div>
    <footer class="site-footer">
        <div class="wrap">
            <div class="footer-content">
              <i>Generated by vimtohtml.rb on </i>
              <a href="http://www.zuiniude.com/vim-zh/usr_toc.html">www.zuiniude.com</a>
            </div>
        </div>
    </footer>
</body>
</html>
