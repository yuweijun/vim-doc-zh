<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/github.com/yuweijun/yuweijun.github.io/vim-zh/tips.cnx.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="help">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="molokai">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #d0d0d0; background-color: #121212; }
body { font-family: monospace; color: #d0d0d0; background-color: #121212; }
* { font-size: 1em; }
.String { color: #afaf87; }
.Type { color: #5fd7ff; }
.PreProc { color: #87ff00; }
.Identifier { color: #ff8700; }
.Comment { color: #5f5f5f; }
.Special { color: #5fd7ff; }
.Ignore { color: #808080; background-color: #080808; padding-bottom: 1px; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Ignore">*</span><span class="String">tips.txt</span><span class="Ignore">*</span>	For <span class="Identifier">Vim version 8.0.</span>  最近更新: 2010年5月


		  VIM 参考手册    by Bram Moolenaar
	   译者: iCrazy &lt;icrazy@ustc.edu&gt;, tocer <span class="String"><a href="http://vimcdoc.sf.net">http://vimcdoc.sf.net</a></span>


使用 Vim 的技巧						<span class="Ignore">*</span><span class="String">tips</span><span class="Ignore">*</span>

这里只是一小部分我们认为会对很多用户有用的技巧。更多的技巧都在 wiki 上。URL 可
以从这里找到:
<span class="String"><a href="http://www.vim.org">http://www.vim.org</a></span>

别忘记浏览用户手册，里面也有很多实用的技巧 <span class="Ignore">|</span><span class="Identifier">usr_toc.txt</span><span class="Ignore">|</span>。

编辑 C 程序					<span class="Ignore">|</span><span class="Identifier">C-editing</span><span class="Ignore">|</span>
查找使用标识符的地方				<span class="Ignore">|</span><span class="Identifier">ident-search</span><span class="Ignore">|</span>
在 xterm 中切换屏幕				<span class="Ignore">|</span><span class="Identifier">xterm-screens</span><span class="Ignore">|</span>
在插入模式下滚屏				<span class="Ignore">|</span><span class="Identifier">scroll-insert</span><span class="Ignore">|</span>
平滑的滚屏					<span class="Ignore">|</span><span class="Identifier">scroll-smooth</span><span class="Ignore">|</span>
纠正普通的录入错误				<span class="Ignore">|</span><span class="Identifier">type-mistakes</span><span class="Ignore">|</span>
统计单词数、行数等				<span class="Ignore">|</span><span class="Identifier">count-items</span><span class="Ignore">|</span>
恢复光标位置					<span class="Ignore">|</span><span class="Identifier">restore-position</span><span class="Ignore">|</span>
文件更名					<span class="Ignore">|</span><span class="Identifier">rename-files</span><span class="Ignore">|</span>
更改多个文件中的一个名字			<span class="Ignore">|</span><span class="Identifier">change-name</span><span class="Ignore">|</span>
加速外部命令的执行				<span class="Ignore">|</span><span class="Identifier">speed-up</span><span class="Ignore">|</span>
一些有用的映射					<span class="Ignore">|</span><span class="Identifier">useful-mappings</span><span class="Ignore">|</span>
压缩帮助文件					<span class="Ignore">|</span><span class="Identifier">gzip-helpfile</span><span class="Ignore">|</span>
在一个窗口中执行 shell 命令			<span class="Ignore">|</span><span class="Identifier">shell-window</span><span class="Ignore">|</span>
十六进制编辑					<span class="Ignore">|</span><span class="Identifier">hex-editing</span><span class="Ignore">|</span>
在自动命令中使用 &lt;&gt; 记法			<span class="Ignore">|</span><span class="Identifier">autocmd-&lt;&gt;</span><span class="Ignore">|</span>
高亮匹配括号					<span class="Ignore">|</span><span class="Identifier">match-parens</span><span class="Ignore">|</span>

<span class="PreProc">==============================================================================</span>
编辑 C 程序						<span class="Ignore">*</span><span class="String">C-editing</span><span class="Ignore">*</span>

Vim 里面有不少功能可以帮助你们编辑 C 程序。以下是一个概括，你们可以使用标签跳
转到具体的内容中去:

<span class="Ignore">|</span><span class="Identifier">usr_29.txt</span><span class="Ignore">|</span>		用户手册中关于在程序的不同部分间移动的内容。
<span class="Ignore">|</span><span class="Identifier">usr_30.txt</span><span class="Ignore">|</span>		用户手册中关于编辑程序的内容。
<span class="Ignore">|</span><span class="Identifier">C-indenting</span><span class="Ignore">|</span>		输入时自动设置每行的缩进。
<span class="Ignore">|</span><span class="Identifier">=</span><span class="Ignore">|</span>			重新缩进一些行。
<span class="Ignore">|</span><span class="Identifier">format-comments</span><span class="Ignore">|</span>	对注释进行排版。

<span class="Ignore">|</span><span class="Identifier">:checkpath</span><span class="Ignore">|</span>		显示所有被 (嵌套) 包含的文件。
<span class="Ignore">|</span><span class="Identifier">[i</span><span class="Ignore">|</span>			在当前和被包含的文件中查找光标所在的的标识符。
<span class="Ignore">|</span><span class="Identifier">[_CTRL-I</span><span class="Ignore">|</span>		跳到 &quot;[i&quot; 的匹配。
<span class="Ignore">|</span><span class="Identifier">[I</span><span class="Ignore">|</span>			列出在当前和被包含的文件中匹配光标所在的标识符的行。
<span class="Ignore">|</span><span class="Identifier">[d</span><span class="Ignore">|</span>			在当前和被包含的文件中查找光标所在的标识符的宏定义。

<span class="Ignore">|</span><span class="Identifier">CTRL-]</span><span class="Ignore">|</span>		跳到光标所在的标签处 (例如: 函数的定义)。
<span class="Ignore">|</span><span class="Identifier">CTRL-T</span><span class="Ignore">|</span>		跳回执行 <span class="Special">CTRL-]</span> 命令前的地方。
<span class="Ignore">|</span><span class="Identifier">:tselect</span><span class="Ignore">|</span>		从一连串匹配的标签中选出一个。

<span class="Ignore">|</span><span class="Identifier">gd</span><span class="Ignore">|</span>			跳到光标所在的局部变量的声明处。
<span class="Ignore">|</span><span class="Identifier">gD</span><span class="Ignore">|</span>			跳到光标所在的全局变量的声明处。

<span class="Ignore">|</span><span class="Identifier">gf</span><span class="Ignore">|</span>			跳到光标所在的文件名表示的文件。

<span class="Ignore">|</span><span class="Identifier">%</span><span class="Ignore">|</span>			跳到匹配的 ()、{}、[]、/* */、#if、#else、#endif 处。
<span class="Ignore">|</span><span class="Identifier">[/</span><span class="Ignore">|</span>			跳到上一个注释开始的位置。
<span class="Ignore">|</span><span class="Identifier">]/</span><span class="Ignore">|</span>			跳到下一个注释结束的位置。
<span class="Ignore">|</span><span class="Identifier">[#</span><span class="Ignore">|</span>			反向到未闭合的 #if、#ifdef 或 #else 处。
<span class="Ignore">|</span><span class="Identifier">]#</span><span class="Ignore">|</span>			正向到未闭合的 #else 或 #endif 处。
<span class="Ignore">|</span><span class="Identifier">[(</span><span class="Ignore">|</span>			反向到未闭合的 '(' 处。
<span class="Ignore">|</span><span class="Identifier">])</span><span class="Ignore">|</span>			正向到未闭合的 ')' 处。
<span class="Ignore">|</span><span class="Identifier">[{</span><span class="Ignore">|</span>			反向到未闭合的 '{' 处。
<span class="Ignore">|</span><span class="Identifier">]}</span><span class="Ignore">|</span>			正向到未闭合的 '}' 处。

<span class="Ignore">|</span><span class="Identifier">v_ab</span><span class="Ignore">|</span>			选中 &quot;一个块&quot; (&quot;a block&quot;)，从 &quot;[(&quot; 至 &quot;])&quot;，含括号
<span class="Ignore">|</span><span class="Identifier">v_ib</span><span class="Ignore">|</span>			选中 &quot;内含块&quot; (&quot;inner block&quot;)，从 &quot;[(&quot; 至 &quot;])&quot;
<span class="Ignore">|</span><span class="Identifier">v_aB</span><span class="Ignore">|</span>			选中 &quot;一个大块&quot; (&quot;a Block&quot;)，从 &quot;[{&quot; 至 &quot;]}&quot;，含括号
<span class="Ignore">|</span><span class="Identifier">v_iB</span><span class="Ignore">|</span>			选中 &quot;内含大块&quot; (&quot;inner Block&quot;)，从 &quot;[{&quot; 至 &quot;]}&quot;

<span class="PreProc">==============================================================================</span>
查找使用标识符的地方					<span class="Ignore">*</span><span class="String">ident-search</span><span class="Ignore">*</span>

你应该已经知道 <span class="Ignore">|</span><span class="Identifier">tags</span><span class="Ignore">|</span> 可以被用来跳转到定义函数和变量的地方。但是有时你希望跳转
到使用函数和变量的地方。可以用以下两种方法实现:
1. 使用 <span class="Ignore">|</span><span class="Identifier">:grep</span><span class="Ignore">|</span> 命令。这个应该可以在大多数 Unix 系统上工作，但是速度会比较慢
(因为它读取所有的文件)，并且只能在一个目录中搜索。
2. 使用 ID 工具集。这个速度比较快而且可以搜索多个目录。它使用一个数据库来存放
定位信息。你需要一些额外的程序来使它得以工作，并且你必须使数据库不断保持更新。

使用 GNU id 工具集 (id-tools):

你所需要的:
- 安装 GNU id 工具集 (mkid 是用来创建 ID 的，lid 是用来运行宏的)
- 一个在当前目录下名为 &quot;ID&quot; 的标识符数据库。你可以用 shell 命令 &quot;mkid file1
  file2 ..&quot; 来创建它。

把这些添加写你的 .vimrc 文件中:<span class="Ignore"> &gt;</span>
<span class="Comment">	map _u :call ID_search()&lt;Bar&gt;execute &quot;/\\&lt;&quot; . g:word . &quot;\\&gt;&quot;&lt;CR&gt;</span>
<span class="Comment">	map _n :n&lt;Bar&gt;execute &quot;/\\&lt;&quot; . g:word . &quot;\\&gt;&quot;&lt;CR&gt;</span>

<span class="Comment">	function! ID_search()</span>
<span class="Comment">	  let g:word = expand(&quot;&lt;cword&gt;&quot;)</span>
<span class="Comment">	  let x = system(&quot;lid --key=none &quot;. g:word)</span>
<span class="Comment">	  let x = substitute(x, &quot;\n&quot;, &quot; &quot;, &quot;g&quot;)</span>
<span class="Comment">	  execute &quot;next &quot; . x</span>
<span class="Comment">	endfun</span>

使用的时候，把光标放在一个单词上，敲入 &quot;_u&quot;，然后 vim 会读入含有这个单词的文
件。使用 &quot;n&quot; 查找这个单词在相同文件中下一次的出现的地方。使用 &quot;_n&quot; 可以跳转到
下一个文件。

这些操作已经使用 id-utils-3.2 (这是位于距你最近的 gnu ftp 镜像服务器上的档案
名称) 测试通过了。

[这个的想法来自于 Andreas Kutschera]

<span class="PreProc">==============================================================================</span>
在 xterm 中切换屏幕			<span class="Ignore">*</span><span class="String">xterm-screens</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">xterm-save-screen</span><span class="Ignore">*</span>

(来源: comp.editors，作者: Juergen Weigert，回答一个问题的时候)

:&gt; 另一个问题就是退出 vim 后，屏幕内容就被留在那儿了，也就是说: 我刚刚正在查看
:&gt; (或编辑) 的内容就被留在屏幕上了。而我此前执行的命令 (例如: &quot;ls&quot;) 的输出却不
:&gt; 见了，换而言之在滚屏缓冲区里不存在了。我知道有个办法可以在退出 vim 或其他仿
:&gt; vi 的编辑器的时候恢复屏幕内容，但是我不知道该如何操作。请帮助我，谢谢！
:
: 我认为可能有人可以回答这个问题。我认为 vim 和 vi 在某个特定的 xterm 安装下和
: 别的程序一样工作。

他们并不一定完全相同，因为这牵扯到一个 termcap 对 terminfo 的问题。你们应该知
道针对一种特定的终端，有两种数据库可以用来描述它的属性: termcap 和 terminfo。
当它们中的条目不同，而且以上问题中的一个程序使用 terminfo，另一个使用 termcap
时，两个程序会出现差异 (请参见: <span class="Ignore">|</span><span class="Identifier">+terminfo</span><span class="Ignore">|</span>)。

在你的问题中，你可能需要以下的控制序列: ^[[?47h 和 ^[[?47l。他们用来在 xterm
备用和主屏幕缓冲区中切换。一个快速的临时解决方案使用如下的命令序列<span class="Ignore"> &gt;</span>
<span class="Comment">	echo -n &quot;^[[?47h&quot;; vim ... ; echo -n &quot;^[[?47l&quot;</span>
这可能就是你所需要的。(我用符号 ^[ 表示 ESC 字符，往后你还会看到数据库使用 \E
来表示它)。

在启动的时候，vim 把 termcap 中变量 ti (terminfo:smcup) 的值回显在终端上。退出
的时候，它回显 te (terminfo: rmcup) 的值。这样一来，这两个变量正好处于以上所述
的控制序列应该执行的位置。

把你的 xterm termcap 条目 (在 /etc/termcap 中) 和 xterm terminfo 条目 (用
&quot;infocmp -C xterm&quot; 得到) 比较一下。两者应该都会有与下面类似的条目:<span class="Ignore"> &gt;</span>
<span class="Comment">	:te=\E[2J\E[?47l\E8:ti=\E7\E[?47h:</span>

附: 如果你发现了任何差异，那么最好让某人 (或许是你的系统管理员) 彻底地检查一下
    termcap 和 terminfo 的一致性。

备注 1: 如果你在 feature.h 中定义了 FEAT_XTERM_SAVE 之后又重新编译了 Vim，那么
内置的 xterm 会有上述的 &quot;te&quot; 和 &quot;ti&quot; 条目。

备注 2: 如果你希望禁止屏幕切换，并且不希望改变你的 termcap，你可以在 .vimrc 文
件中加入这一行:<span class="Ignore"> &gt;</span>
<span class="Comment">	:set t_ti= t_te=</span>

<span class="PreProc">==============================================================================</span>
在插入模式下滚屏					<span class="Ignore">*</span><span class="String">scroll-insert</span><span class="Ignore">*</span>

如果你处于插入模式下并且希望看一些恰好在屏幕范围以外的东西，你可以使用 <span class="Special">CTRL-X</span>
<span class="Special">CTRL-E</span> 和 <span class="Special">CTRL-X</span> <span class="Special">CTRL-Y</span> 来滚屏。
						<span class="Ignore">|</span><span class="Identifier">i_CTRL-X_CTRL-E</span><span class="Ignore">|</span>

为了使这个简单些，你可以用这些映射:<span class="Ignore"> &gt;</span>
<span class="Comment">	:inoremap &lt;C-E&gt; &lt;C-X&gt;&lt;C-E&gt;</span>
<span class="Comment">	:inoremap &lt;C-Y&gt; &lt;C-X&gt;&lt;C-Y&gt;</span>
(逐字敲入这些字符，并确认 '&lt;' 标志位不在 <span class="Type">'cpoptions'</span> 选项中)。
不过这样你就不能使用从光标上一行/下一行拷贝文字的功能了 <span class="Ignore">|</span><span class="Identifier">i_CTRL-E</span><span class="Ignore">|</span>。

你还可以考虑把 <span class="Type">'scrolloff'</span> 设置得大一些，这样你就总能看到光标附近的上下文了。
如果 <span class="Type">'scrolloff'</span> 的值大于窗口高度的一半，在向上或向下移动光标时，文字会上下卷
动，但是光标会始终停留在屏幕中间的位置。

<span class="PreProc">==============================================================================</span>
平滑的滚屏						<span class="Ignore">*</span><span class="String">scroll-smooth</span><span class="Ignore">*</span>

如果你希望你的滚屏更加平滑一些，你可以使用以下的映射:<span class="Ignore"> &gt;</span>
<span class="Comment">	:map &lt;C-U&gt; &lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;&lt;C-Y&gt;</span>
<span class="Comment">	:map &lt;C-D&gt; &lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;&lt;C-E&gt;</span>

(逐字敲入这些字符，并确认 '&lt;' 标志位不在 <span class="Type">'cpoptions'</span> 选项中)。

<span class="PreProc">==============================================================================</span>
纠正普通的录入错误					<span class="Ignore">*</span><span class="String">type-mistakes</span><span class="Ignore">*</span>

如果有一些单词你总是敲错，你可以使用缩写来改正它们。例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:ab teh the</span>
<span class="Comment">	:ab fro for</span>

<span class="PreProc">==============================================================================</span>
统计单词数、行数等					<span class="Ignore">*</span><span class="String">count-items</span><span class="Ignore">*</span>

如果需要统计缓冲区中一个模式 (pattern) 出现的频率，使用 substitute 命令并加入
'n' 标志位以避免实际的替代。Vim 报告的已替代的数目就是模式出现的次数。例:<span class="Ignore"> &gt;</span>

<span class="Comment">	:%s/./&amp;/gn		字符数</span>
<span class="Comment">	:%s/\i\+/&amp;/gn		单词数</span>
<span class="Comment">	:%s/^//n		行数</span>
<span class="Comment">	:%s/the/&amp;/gn		任何地方出现的 &quot;the&quot;</span>
<span class="Comment">	:%s/\&lt;the\&gt;/&amp;/gn	作为单词出现的 &quot;the&quot;</span>

你可能希望复位 <span class="Type">'hlsearch'</span> 或者使用 &quot;:nohlsearch&quot;。
如果你希望没有匹配的时候不显示错误，那么增加标志位 'e'。

另一种办法就是在可视模式下使用 <span class="Ignore">|</span><span class="Identifier">v_g_CTRL-G</span><span class="Ignore">|</span>。

如果你想在多个文件中查找匹配，用 <span class="Ignore">|</span><span class="Identifier">:vimgrep</span><span class="Ignore">|</span>。

							<span class="Ignore">*</span><span class="String">count-bytes</span><span class="Ignore">*</span>
如果你想数字节数，你可以这样做:

	选中那些字符 (列块选择也可以)
	使用 &quot;y&quot; 来拷贝这些字符
	使用 strlen() 函数:<span class="Ignore"> &gt;</span>
<span class="Comment">		:echo strlen(@&quot;)</span>
一个换行符被当做一个字节。

<span class="PreProc">==============================================================================</span>
恢复光标位置						<span class="Ignore">*</span><span class="String">restore-position</span><span class="Ignore">*</span>

有时你希望写一个映射，让它在文件中的其他地方做一些修改然后恢复光标的位置 (不滚
动文本)。例如，修改一个文件中的日期标记:<span class="Ignore"> &gt;</span>

<span class="Comment">   :map &lt;F2&gt; msHmtgg/Last [cC]hange:\s*/e+1&lt;CR&gt;&quot;_D&quot;=strftime(&quot;%Y %b %d&quot;)&lt;CR&gt;p'tzt`s</span>

分解出保存位置的命令:
	ms	把光标位置存放在位置标记 's' 中
	H	跳转到窗口的顶端
	mt	把这个位置存放在位置标记 't' 中

分解出恢复位置的命令:
	't	跳转到先前位于窗口顶端的那一行
	zt	滚屏，使这一行位于窗口的顶端
	`s	跳转到最初光标的位置

更高级的功能见 <span class="Ignore">|</span><span class="Identifier">winsaveview()</span><span class="Ignore">|</span> 和 <span class="Ignore">|</span><span class="Identifier">winrestview()</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
文件更名						<span class="Ignore">*</span><span class="String">rename-files</span><span class="Ignore">*</span>

假如我有一个目录，里面有如下的文件 (目录是随机选取的):

buffer.c
charset.c
digraph.c
...

现在我希望把 *.c 更名为 *.bla。我可以这样做:<span class="Ignore"> &gt;</span>

<span class="Comment">	$ vim</span>
<span class="Comment">	:r !ls *.c</span>
<span class="Comment">	:%s/\(.*\).c/mv &amp; \1.bla</span>
<span class="Comment">	:w !sh</span>
<span class="Comment">	:q!</span>

<span class="PreProc">==============================================================================</span>
更改多个文件中的一个名字				<span class="Ignore">*</span><span class="String">change-name</span><span class="Ignore">*</span>

使用脚本文件在若干文件中更改一个名字的示例:

	创建文件 &quot;subs.vim&quot;，包含替代命令和 :update 命令:<span class="Ignore"> &gt;</span>
<span class="Comment">		:%s/Jones/Smith/g</span>
<span class="Comment">		:%s/Allen/Peter/g</span>
<span class="Comment">		:update</span>
<span class="Ignore">&lt;</span>
	在所有你要改动的文件上执行 Vim，然后为每个参数执行脚本:<span class="Ignore"> &gt;</span>

<span class="Comment">		vim *.let</span>
<span class="Comment">		argdo source subs.vim</span>

参见 <span class="Ignore">|</span><span class="Identifier">:argdo</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
加速外部命令的执行					<span class="Ignore">*</span><span class="String">speed-up</span><span class="Ignore">*</span>

在一些情况下，外部命令执行起来非常地慢。而且还会减慢 Unix 上的通配符扩展。这儿
有一些建议可以加快速度:

如果你的 .cshrc 文件 (根据你使用的 shell，文件名可能不同) 非常地长，你应该把它
分割成两节: 需要和用户交互的、无需和用户交互的 (经常被称作二级 shell)。当你在
Vim 中执行一个类似 &quot;:!ls&quot; 的命令时，你就不需要和用户交互的那一部分 (例如: 设置
提示符)。把那些不必要的部分放到下面这些行后面去:<span class="Ignore"> &gt;</span>

<span class="Comment">	if ($?prompt == 0) then</span>
<span class="Comment">		exit 0</span>
<span class="Comment">	endif</span>

另一个办法是在 <span class="Type">'shell'</span> 选项中包含 &quot;-f&quot; 参数，例如:<span class="Ignore"> &gt;</span>

<span class="Comment">	:set shell=csh\ -f</span>

(这儿的反斜杠是必需的，这样才能在选项中表示一个空格)。
这样就会使 csh 完全跳过 .cshrc 文件。不过这样可能会造成一些程序不能正常运行。

<span class="PreProc">==============================================================================</span>
一些有用的映射					<span class="Ignore">*</span><span class="String">useful-mappings</span><span class="Ignore">*</span>

这里有一些人们喜欢使用的映射。

							<span class="Ignore">*</span><span class="String">map-backtick</span><span class="Ignore">*</span> <span class="Ignore"> &gt;</span>
<span class="Comment">	:map ' `</span>
使得单引号和 ' 一样工作。把光标移动到一个位置标记所在的列，而不是那一行的第一
个非空白字符。

							<span class="Ignore">*</span><span class="String">emacs-keys</span><span class="Ignore">*</span>
要在命令行上实现 Emacs 风格的编辑操作:<span class="Ignore"> &gt;</span>
<span class="Comment">	&quot; 至行首</span>
<span class="Comment">	:cnoremap &lt;C-A&gt;		&lt;Home&gt;</span>
<span class="Comment">	&quot; 后退一个字符</span>
<span class="Comment">	:cnoremap &lt;C-B&gt;		&lt;Left&gt;</span>
<span class="Comment">	&quot; 删除光标所在的字符</span>
<span class="Comment">	:cnoremap &lt;C-D&gt;		&lt;Del&gt;</span>
<span class="Comment">	&quot; 至行尾</span>
<span class="Comment">	:cnoremap &lt;C-E&gt;		&lt;End&gt;</span>
<span class="Comment">	&quot; 前进一个字符</span>
<span class="Comment">	:cnoremap &lt;C-F&gt;		&lt;Right&gt;</span>
<span class="Comment">	&quot; 取回较新的命令行</span>
<span class="Comment">	:cnoremap &lt;C-N&gt;		&lt;Down&gt;</span>
<span class="Comment">	&quot; 取回以前 (较旧的) 命令行</span>
<span class="Comment">	:cnoremap &lt;C-P&gt;		&lt;Up&gt;</span>
<span class="Comment">	&quot; 后退一个单词</span>
<span class="Comment">	:cnoremap &lt;Esc&gt;&lt;C-B&gt;	&lt;S-Left&gt;</span>
<span class="Comment">	&quot; 前进一个单词</span>
<span class="Comment">	:cnoremap &lt;Esc&gt;&lt;C-F&gt;	&lt;S-Right&gt;</span>

备注: 前提条件是 '&lt;' 标志位不在 <span class="Type">'cpoptions'</span> 选项中。<span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span>

							<span class="Ignore">*</span><span class="String">format-bullet-list</span><span class="Ignore">*</span>
这个映射可以格式化任何带符号的 (bullet) 列表，不过它需要在每一个条目的上下都各
有一个空行。使用表达式命令，以便对映射的部分进行注释:<span class="Ignore"> &gt;</span>

<span class="Comment">	:let m =     &quot;:map _f  :set ai&lt;CR&gt;&quot;   &quot; 需要置位 'autoindent'</span>
<span class="Comment">	:let m = m . &quot;{O&lt;Esc&gt;&quot;		      &quot; 在项目上面加入空行</span>
<span class="Comment">	:let m = m . &quot;}{)^W&quot;		      &quot; 跳转到 bullet 之后的文本</span>
<span class="Comment">	:let m = m . &quot;i     &lt;CR&gt;     &lt;Esc&gt;&quot;   &quot; 为缩进加空格</span>
<span class="Comment">	:let m = m . &quot;gq}&quot;		      &quot; 排版 bullet 之后的文本</span>
<span class="Comment">	:let m = m . &quot;{dd&quot;		      &quot; 删除空行</span>
<span class="Comment">	:let m = m . &quot;5lDJ&quot;		      &quot; 把文本放到 bullet 之后</span>
<span class="Comment">	:execute m			      |&quot; 定义这个 mapping</span>

(&lt;&gt; 记法 <span class="Ignore">|</span><span class="Identifier">&lt;&gt;</span><span class="Ignore">|</span>。注意 必须按照字面逐个输入。^W 是 &quot;^&quot; 和 &quot;W&quot;，而不是 <span class="Special">CTRL-W</span>。如
果 '&lt;' 标志位不在 <span class="Type">'cpoptions'</span> 选项中，你可以把这些拷贝/粘贴代码给 Vim 执行。)

注意 最后一个注释以 |&quot; 开始，因为 &quot;:execute&quot; 不能直接识别一个注释。

你还需要把 <span class="Type">'textwidth'</span> 设置成一个非 0 值，例如:<span class="Ignore"> &gt;</span>
<span class="Comment">	:set tw=70</span>

以下这个映射可以达到同样的效果，不过它从第一行获得列表的缩进 (备注: 这个映射其
实只有一行，其中有很多空格):<span class="Ignore"> &gt;</span>
<span class="Comment">	:map _f :set ai&lt;CR&gt;}{a                                                          &lt;Esc&gt;WWmmkD`mi&lt;CR&gt;&lt;Esc&gt;kkddpJgq}'mJO&lt;Esc&gt;j</span>
<span class="Ignore">&lt;</span>
							<span class="Ignore">*</span><span class="String">collapse</span><span class="Ignore">*</span>
这两个映射可以把一连串的空行 (;b) 或空白行 (;n) 压缩到一行<span class="Ignore"> &gt;</span>
<span class="Comment">    :map ;b   GoZ&lt;Esc&gt;:g/^$/.,/./-j&lt;CR&gt;Gdd</span>
<span class="Comment">    :map ;n   GoZ&lt;Esc&gt;:g/^[ &lt;Tab&gt;]*$/.,/[^ &lt;Tab&gt;]/-j&lt;CR&gt;Gdd</span>

<span class="PreProc">==============================================================================</span>
压缩帮助文件						<span class="Ignore">*</span><span class="String">gzip-helpfile</span><span class="Ignore">*</span>

对于那些磁盘空间极度紧张的人来说，你们可以压缩帮助文件。这样会使得查看帮助文
件时稍微慢一点，并且需要 &quot;gzip&quot; 这个程序的支持。

(1) 压缩所有帮助文件: &quot;gzip doc/*.txt&quot;。

(2) 编辑文件 &quot;doc/tags&quot;，用 &quot;.txt.gz&quot; 替换 &quot;.txt&quot;:<span class="Ignore"> &gt;</span>
<span class="Comment">	:%s=\(\t.*\.txt\)\t=\1.gz\t=</span>

(3) 把这一行加入到你的 vimrc 文件中:<span class="Ignore"> &gt;</span>
<span class="Comment">	set helpfile={dirname}/help.txt.gz</span>

这儿 <span class="Special">{dirname}</span> 是存放帮助文件的目录。<span class="Ignore">|</span><span class="Identifier">gzip</span><span class="Ignore">|</span> 这个插件会负责解压缩这些文件的。
如果其它 Vim 文件所在的位置和存放压缩帮助的 &quot;doc&quot; 目录不一致，你必须肯定已经把
$VIMRUNTIME 设置成存放 Vim 文件的目录。参见: <span class="Ignore">|</span><span class="Identifier">$VIMRUNTIME</span><span class="Ignore">|</span>。

<span class="PreProc">==============================================================================</span>
在一个窗口中执行 shell 命令				<span class="Ignore">*</span><span class="String">shell-window</span><span class="Ignore">*</span>

很多人都询问能不能在 Vim 中的一个窗口内执行 shell 命令。答案是: 不行！加入这个
功能会给 Vim 增加很多代码量，这也是为什么我们没有这样做的一个很好的理由。毕
竟，Vim 只是一个编辑器，它本身并不是用来做那些非编辑类工作的。然而，要达到这样
的目的，你可以用 &quot;splitvt&quot; 程序把你的终端屏幕或显示窗口进行分割。在一些 ftp 服
务器上你可以找到这个工具。Sam Lantinga &lt;slouken@cs.ucdavis.edu&gt; 对此了解颇多。
另一种办法是使用在 BSD Unix 系统上出现的 &quot;window&quot; 命令，它支持多个重叠的窗口。
或者使用最先出现在 <span class="String">www.uni-erlangen.de</span> 上的 &quot;screen&quot; 程序，它支持窗口栈。

<span class="PreProc">==============================================================================</span>
十六进制编辑					<span class="Ignore">*</span><span class="String">hex-editing</span><span class="Ignore">*</span> <span class="Ignore">*</span><span class="String">using-xxd</span><span class="Ignore">*</span>

请看用户手册的第 <span class="Ignore">|</span><span class="Identifier">23.4</span><span class="Ignore">|</span> 节。

如果你用一些专门的扩展名来命名二进制文件 (诸如 exe，bin 等等)，你会发现以下在
&lt;.vimrc&gt; 文件中使用的一些命令在自动处理这些文件时非常有用。你可以用你希望编辑
的文件扩展名 (用逗号分隔) 替换以下的 &quot;*.bin&quot;:<span class="Ignore"> &gt;</span>

<span class="Comment">	&quot; vim -b : edit binary using xxd-format!</span>
<span class="Comment">	augroup Binary</span>
<span class="Comment">	  au!</span>
<span class="Comment">	  au BufReadPre  *.bin let &amp;bin=1</span>
<span class="Comment">	  au BufReadPost *.bin if &amp;bin | %!xxd</span>
<span class="Comment">	  au BufReadPost *.bin set ft=xxd | endif</span>
<span class="Comment">	  au BufWritePre *.bin if &amp;bin | %!xxd -r</span>
<span class="Comment">	  au BufWritePre *.bin endif</span>
<span class="Comment">	  au BufWritePost *.bin if &amp;bin | %!xxd</span>
<span class="Comment">	  au BufWritePost *.bin set nomod | endif</span>
<span class="Comment">	augroup END</span>

<span class="PreProc">==============================================================================</span>
在自动命令中使用 &lt;&gt; 记法				<span class="Ignore">*</span><span class="String">autocmd-&lt;&gt;</span><span class="Ignore">*</span>

在自动命令的参数中，不能识别 &lt;&gt; 记法。为避免使用特殊的字符，你可以使用一个可以
自我毁灭的映射来得到 &lt;&gt; 记法，然后从自动命令中调用这个映射。举例如下:

						<span class="Ignore">*</span><span class="String">map-self-destroy</span><span class="Ignore">*</span> <span class="Ignore"> &gt;</span>
<span class="Comment"> &quot; 此命令自动把文件名加入到菜单列表中。</span>
<span class="Comment"> &quot; 它使用了一个可以自我毁灭的映射！</span>
<span class="Comment"> &quot; 1. 用缓冲区中的一行把文件名中的点 ('dots') 转换成 \.</span>
<span class="Comment"> &quot; 2. 把该行存放在寄存器 '&quot;' 中</span>
<span class="Comment"> &quot; 3. 把该名字加入缓冲区菜单列表</span>
<span class="Comment"> &quot; 警 告: 这会有些副作用，比如: 覆盖当前的寄存器内容和删除任何 &quot;i&quot; 命令的映射</span>
<span class="Comment"> &quot;</span>
<span class="Comment"> autocmd BufNewFile,BufReadPre * nmap i :nunmap i&lt;CR&gt;O&lt;C-R&gt;%&lt;Esc&gt;:.g/\./s/\./\\./g&lt;CR&gt;0&quot;9y$u:menu Buffers.&lt;C-R&gt;9 :buffer &lt;C-R&gt;%&lt;C-V&gt;&lt;CR&gt;&lt;CR&gt;</span>
<span class="Comment"> autocmd BufNewFile,BufReadPre * normal i</span>

另一个或许更好一些的办法就是使用 &quot;:execute&quot; 命令。在字符串中，你可以通过在 &lt;&gt;
记法前面加一个反斜杠的方法来使用它。别忘了加倍已经存在的反斜杠的数目以及在 '&quot;'
前面放一个反斜杠。<span class="Ignore"> &gt;</span>

<span class="Comment">  autocmd BufNewFile,BufReadPre * exe &quot;normal O\&lt;C-R&gt;%\&lt;Esc&gt;:.g/\\./s/\\./\\\\./g\&lt;CR&gt;0\&quot;9y$u:menu Buffers.\&lt;C-R&gt;9 :buffer \&lt;C-R&gt;%\&lt;C-V&gt;\&lt;CR&gt;\&lt;CR&gt;&quot;</span>

为了建立一个真正的缓冲区菜单，需要用到用户函数 (参见 <span class="Ignore">|</span><span class="Identifier">:function</span><span class="Ignore">|</span>)，不过那里不
使用 &lt;&gt; 记法，所以失去了在这里举例的意义。

<span class="PreProc">==============================================================================</span>
高亮匹配括号							<span class="Ignore">*</span><span class="String">match-parens</span><span class="Ignore">*</span>

本例演示一些高级技巧的用法:
- 使用 <span class="Ignore">|</span><span class="Identifier">CursorMoved</span><span class="Ignore">|</span> 自动命令事件
- 使用 <span class="Ignore">|</span><span class="Identifier">searchpairpos()</span><span class="Ignore">|</span> 查找匹配括号
- 使用 <span class="Ignore">|</span><span class="Identifier">synID()</span><span class="Ignore">|</span> 检测光标是否在字符串或注释上
- 使用 <span class="Ignore">|</span><span class="Identifier">:match</span><span class="Ignore">|</span> 高亮一些内容
- 使用 <span class="Ignore">|</span><span class="Identifier">pattern</span><span class="Ignore">|</span> 匹配文件的特定位置。

它应该被放在 Vim 脚本里，因为使用了局部于脚本的变量。它跳过字符串或注释里的匹
配，除非光标起始于字符串或者注释的内部。这需要语法高亮的支持。

<span class="Ignore">|</span><span class="Identifier">matchparen</span><span class="Ignore">|</span> 插件使用稍稍改进的版本。
<span class="Ignore">&gt;</span>
<span class="Comment">	let s:paren_hl_on = 0</span>
<span class="Comment">	function s:Highlight_Matching_Paren()</span>
<span class="Comment">	  if s:paren_hl_on</span>
<span class="Comment">	    match none</span>
<span class="Comment">	    let s:paren_hl_on = 0</span>
<span class="Comment">	  endif</span>

<span class="Comment">	  let c_lnum = line('.')</span>
<span class="Comment">	  let c_col = col('.')</span>

<span class="Comment">	  let c = getline(c_lnum)[c_col - 1]</span>
<span class="Comment">	  let plist = split(&amp;matchpairs, ':\|,')</span>
<span class="Comment">	  let i = index(plist, c)</span>
<span class="Comment">	  if i &lt; 0</span>
<span class="Comment">	    return</span>
<span class="Comment">	  endif</span>
<span class="Comment">	  if i % 2 == 0</span>
<span class="Comment">	    let s_flags = 'nW'</span>
<span class="Comment">	    let c2 = plist[i + 1]</span>
<span class="Comment">	  else</span>
<span class="Comment">	    let s_flags = 'nbW'</span>
<span class="Comment">	    let c2 = c</span>
<span class="Comment">	    let c = plist[i - 1]</span>
<span class="Comment">	  endif</span>
<span class="Comment">	  if c == '['</span>
<span class="Comment">	    let c = '\['</span>
<span class="Comment">	    let c2 = '\]'</span>
<span class="Comment">	  endif</span>
<span class="Comment">	  let s_skip ='synIDattr(synID(line(&quot;.&quot;), col(&quot;.&quot;), 0), &quot;name&quot;) ' .</span>
<span class="Comment">		\ '=~?  &quot;string\\|comment&quot;'</span>
<span class="Comment">	  execute 'if' s_skip '| let s_skip = 0 | endif'</span>

<span class="Comment">	  let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip)</span>

<span class="Comment">	  if m_lnum &gt; 0 &amp;&amp; m_lnum &gt;= line('w0') &amp;&amp; m_lnum &lt;= line('w$')</span>
<span class="Comment">	    exe 'match Search /\(\%' . c_lnum . 'l\%' . c_col .</span>
<span class="Comment">		  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'</span>
<span class="Comment">	    let s:paren_hl_on = 1</span>
<span class="Comment">	  endif</span>
<span class="Comment">	endfunction</span>

<span class="Comment">	autocmd CursorMoved,CursorMovedI * call s:Highlight_Matching_Paren()</span>
<span class="Comment">	autocmd InsertEnter * match none</span>
<span class="Ignore">&lt;</span>

 vim&#0058;tw=78:ts=8:ft=help:norl:
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
